rule TSD :
    input:
        "get_TE_seq.done",
        fasta_TE  = config["DATA"]["TE_DB"],

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/report_TSD.txt",
        #directory(config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/" + "TSD"),

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),
        name_genome    = config["DATA"]["GENOME"].split("/")[-1].split(".")[0],

    shell:
        """
        rm -f report_TSD.txt;
        touch report_TSD.txt;

        echo '-----------TSD----------' ;
        mkdir -p {params.work_directory}/TSD ;
        path_to_pipline=`dirname {params.path_snk}`
        
        read_directory="{params.work_directory}/READ_FASTQ_TE"
        fasta_dir_find="{params.work_directory}/FASTA_FIND"

        NB_FILE=`ls {params.work_directory}/ET_FIND_FA | wc -l` ;
        i=0 ;
        for TE_found_fa in `ls {params.work_directory}/ET_FIND_FA/`; do

            i=$(($i + 1)) ;
            echo "[TSD:snk] $i/$NB_FILE" ;
            nameTE=`echo $TE_found_fa | grep -o "_[^_]*\." | grep -o "[^_]*" | sed 's/\.$//g'` ;
            SIZE_TSD=`grep -w "${{nameTE}}" ${{path_to_pipline}}/TSD/TE_SIZE_TSD.txt || echo "NONE"`; # EX: ZAM 4 :or: -1
            echo "hihi   $SIZE_TSD"
            if [[ $SIZE_TSD != "NONE" ]]; then
                SIZE_TSD=`echo $SIZE_TSD | awk '{{print $2}}'`;
                echo "here"
            fi;
            size_tsd=`grep -w "${{nameTE}}" ${{path_to_pipline}}/TSD/TE_SIZE_TSD.txt || echo NONE`
            echo "TE=$nameTE SIZE_TSD=$size_tsd  ss=$SIZE_TSD" 
            sh ${{path_to_pipline}}/TSD/find_fq_to_fasta.sh {params.work_directory}/ET_FIND_FA/$TE_found_fa \
               ${{read_directory}} \
               ${{fasta_dir_find}} ;

            sh ${{path_to_pipline}}/TSD/tsd_te.sh {params.work_directory}/ET_FIND_FA/$TE_found_fa \
                ${{read_directory}} \
                ${{fasta_dir_find}} \
                {input.fasta_TE} 30 $SIZE_TSD ;
            
            mv total_results_tsd.txt total_results_tsd_${{nameTE}}.txt ;
            mv total_results_tsd_${{nameTE}}.txt {params.work_directory}/TSD/ ;
            echo ${{nameTE}} >> report_TSD.txt
            tail -n 8 {params.work_directory}/TSD/total_results_tsd_${{nameTE}}.txt >> {params.work_directory}/report_TSD.txt
        done;

        """


#END TSD

#Get just sequence potentiel candidate of TE
rule get_TE_seq :
    input:
        "extract_read.done",
        all_te            = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        snif_seqs         = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SEQUENCE_INDEL.fasta",
        assembly_active   = ASSEMBLY_RULE,

    output:
        temp(touch("get_TE_seq.done")),
        directory(config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/" + "ET_FIND_FA"),


    params:
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

    shell:
        """
        mkdir -p {params.work_directory}/ET_FIND_FA ;
        
        rep="{params.work_directory}/ET_FIND_FA" 
        prefix="TE_REPORT"
        cat {input.all_te} | sed -e 's/:[-+]//g' > {params.work_directory}/tmp_TE_all.csv
        head {params.work_directory}/tmp_TE_all.csv
        awk -v dir="$rep" -v prefix="$prefix" 'BEGIN{{OFS="\t"}} NR>1 {{if($8<$9){{print $2, $8-1, $9  >> dir"/"prefix"_find_"$1".bed"}} else{{print $2, $9-1, $8  >> dir"/"prefix"_find_"$1".bed"}} }}' {params.work_directory}/tmp_TE_all.csv ;
        for i in `ls {params.work_directory}/ET_FIND_FA | grep ".bed$"`; do
            bedtools getfasta -fi {input.snif_seqs} \
               -bed {params.work_directory}/ET_FIND_FA/$i > {params.work_directory}/ET_FIND_FA/TE_REPORT_find_`echo $i | grep -o "_[^_]*\." | grep -o "[^_]*" | sed 's/\.$//g'`.fasta; 
        done ;

        rm -f {params.work_directory}/ET_FIND_FA/*.bed ;
        cat {params.work_directory}/ET_FIND_FA/* > {params.work_directory}/TE_REPORT_total_find.fasta ;
        """

#END get_TE_seq


rule assembly_flye :
    input:
        vcf      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SV.vcf",
        read     = config["DATA"]["SAMPLE"],
        fasta_TE = config["DATA"]["TE_DB"],
        all_te   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        bln      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/BLAST_SEQUENCE_INDEL_vs_DBTE.bln",
        active   = "extract_read.done" if config["LOCAL_ASSEMBLY"]["FLYE"] else [],

    output:
        temp(touch("FLYE")),

    group: "assembly"

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

    shell:
        """
        printf "%s\n" "{params.cmess} [SNK] ASSEMBLY FLYE [^-^] {params.cend}"

        path_to_pipline=`dirname {params.path_snk}`

        NB_FILE=`ls {params.work_directory}/ID_READS_TE | wc -l` ;
        i=0 ;
        for read_file in `ls {params.work_directory}/ID_READS_TE`; do
            region=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]"` ;
            id=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]" | cut -d":" -f 2`

            #nb_read=`grep ":$id:" {input.all_te} | cut -f 2 | cut -d ":" -f 6`
            nb_read=`awk -v ID="$id" '{{if($3 == ID){{print $0}}}}' {input.vcf} | grep -o -e "RE=[0-9]*" | cut -d"=" -f 2`
            TE=`grep ":$id:[0-9]*:[IP]" {input.all_te} | cut -f 1 || echo "NONE"`

            i=$(($i + 1)) ;
            echo "[extract_read:snk] $read_file"
            echo "[extract_read:snk] $i/$NB_FILE : nb_read=$nb_read : id=$id" ;

            ##if it is in TE REPORT
            (! test -e {params.work_directory}/READ_FASTQ_TE/reads_$region.fastq && grep -w $id {params.work_directory}/ID_TE_SV_REPORT.txt && samtools fqidx {input.read} -r {params.work_directory}/ID_READS_TE/$read_file > {params.work_directory}/READ_FASTQ_TE/reads_$region.fq) || echo "$id NOT FOUND" ;
            
            if ! test -e {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_Flye_${{region}}.fasta; then

                if [ $nb_read -ne 1 ]; then
                    ! test -e {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq && \
                    samtools fqidx {input.read} -r {params.work_directory}/ID_READS_TE/$read_file > {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq ;
                    #rm -f no_asm.txt;

                    ! test -e {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq && \
                    python3 ${{path_to_pipline}}/scripts_python/fastq_to_fastq.py \
                     {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq \
                     {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq

                    rm -f {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq

                    if ! test -e {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_Flye_${{region}}.fasta; then
                        flye -t 8 --nano-raw {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq --out-dir {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/ASM_FLYE_$region \
                            --plasmids \
                            --genome-size 500K \
                            -i 4 -m 1000 \
                          || ( echo $id >> not_assembly.txt && touch no_asm.txt )
                        
                        if ! test -e no_asm.txt; then
                            printf "[extract_read:snk] BLAST ASSEMBLY $TE"
                            ### BLAST assembly on DATABASE TE
                            
                            blastn -db {input.fasta_TE} -query {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/ASM_FLYE_$region/assembly.fasta -outfmt 6 -out {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_Flye_${{region}}.bln ;
                            echo "[extract_read:snk] BLAST ASSEMBLY $TE PHASE 2"
                            echo "#ID:$id:$TE" >> {params.work_directory}/resume.bln ;
                            cat {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_Flye_${{region}}.bln >> {params.work_directory}/resume.bln ;

                            cat {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_Flye_${{region}}.bln | sort -k 12 -n | tail -n 1 | sed -e "s/contig_*/"$region"":""FLYE:$TE"/g" >> {params.work_directory}/all_TE_assembly.bln
                        fi;
                    fi;
                fi;
            fi;
        done;

        rm -fr {params.work_directory}/WTDGB/

        echo "ASSEMBLY DONE ----------------------------------------";

        for i in `cat {params.work_directory}/all_TE_assembly.bln | cut -f 1 | cut -d":" -f 2`; do 
            qseqid=`grep ":$i:" {params.work_directory}/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv | cut -f 2`;
            if [[ `echo $qseqid` = "" ]]; then 
                qseqid=`grep ":$i:" {params.work_directory}/BLAST_SEQUENCE_INDEL_vs_DBTE.bln | cut -f 1 | head -n 1`;
                qseqid=`echo $qseqid":ONLY_ASM"`
                ET=`grep ":$i:" {params.work_directory}/BLAST_SEQUENCE_INDEL_vs_DBTE.bln | cut -f 2 | head -n 1`;
            else
                ET=`grep ":$i:" {params.work_directory}/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv | cut -f 1`;
            fi;

            qid_old=`grep ":$i:" {params.work_directory}/all_TE_assembly.bln | cut -f 1`;
            echo "[extract_read:snk] $qseqid -- $qid_old -- $ET -- $i" ;
            cat {params.work_directory}/all_TE_assembly.bln | grep ":$i:" | sed "s/$qid_old/$qseqid":"$ET/g";
        done > {params.work_directory}/all_TE_assembly_format_old.bln;

        python3 ${{path_to_pipline}}/scripts_python/parse_blast_main.py {params.work_directory}/all_TE_assembly_format_old.bln {params.work_directory}/all_TE_assembly.csv ;

        NB_REGION=`ls {params.work_directory}/ID_READS_TE | wc -l` ;
        NB_READS=`ls {params.work_directory}/READ_FASTQ_TE | wc -l` ;

        rm -f reads_format.fastq;

        #if [ $NB_REGION -ne $NB_READS ]; then rm -f {params.work_directory}/resume.txt ; echo 'Error : the number of files region it is not equal the number reads files'; fi;

        echo "[extract_read:snk] $NB_READS AND $NB_REGION";

        """

#END assembly_flye



rule assembly_wdtgb :
    input:
        vcf      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SV.vcf",
        read     = config["DATA"]["SAMPLE"],
        fasta_TE = config["DATA"]["TE_DB"],
        all_te   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        bln      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/BLAST_SEQUENCE_INDEL_vs_DBTE.bln",
        active   = "extract_read.done" if config["LOCAL_ASSEMBLY"]["WTDGB"] else [],

    output:
        temp(touch("WTDGB")),

    group: "assembly"

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

    shell:
        """
        printf "%s\n" "{params.cmess} [SNK] ASSEMBLY WTDGB [^-^] {params.cend}"

        path_to_pipline=`dirname {params.path_snk}`

        makeblastdb -in {input.fasta_TE} -dbtype nucl ;

        NB_FILE=`ls {params.work_directory}/ID_READS_TE | wc -l` ;
        i=0 ;
        for read_file in `ls {params.work_directory}/ID_READS_TE`; do
            region=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]"` ;
            id=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]" | cut -d":" -f 2`

            #nb_read=`grep ":$id:" {input.all_te} | cut -f 2 | cut -d ":" -f 6`
            nb_read=`awk -v ID="$id" '{{if($3 == ID){{print $0}}}}' {input.vcf} | grep -o -e "RE=[0-9]*" | cut -d"=" -f 2`
            TE=`grep ":$id:[0-9]*:[IP]" {input.all_te} | cut -f 1 || echo "NONE"`

            i=$(($i + 1)) ;
            echo "[extract_read:snk] $read_file"
            echo "[extract_read:snk] $i/$NB_FILE : nb_read=$nb_read : id=$id" ;

            ##if it is in TE REPORT
            (! test -e {params.work_directory}/READ_FASTQ_TE/reads_$region.fastq && grep -w $id {params.work_directory}/ID_TE_SV_REPORT.txt && samtools fqidx {input.read} -r {params.work_directory}/ID_READS_TE/$read_file > {params.work_directory}/READ_FASTQ_TE/reads_$region.fq) || echo "$id NOT FOUND" ;
            
            ! test -e {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq && \
                python3 ${{path_to_pipline}}/scripts_python/fastq_to_fastq.py \
                     {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq \
                     {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq

            if ! test -e {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_WTDBG_${{region}}.fasta; then

                if [ $nb_read -ne 1 ]; then
                    ! test -e {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq && \
                    samtools fqidx {input.read} -r {params.work_directory}/ID_READS_TE/$read_file > {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq ;
                    #rm -f no_asm.txt;

                    rm -f {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq

                    if ! test -e {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_WTDBG_${{region}}.fasta; then
                        mkdir -p {params.work_directory}/WTDGB
                        wtdbg2 -i {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq -fo {params.work_directory}/WTDGB/dbg || ( echo $id >> not_assembly.txt && touch no_asm.txt )
                        wtpoa-cns -t 6 -i {params.work_directory}/WTDGB/dbg.ctg.lay.gz -fo {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_WTDBG_${{region}}.fasta || ( echo $id >> not_assembly.txt && touch no_asm.txt && echo "PROBLEMEEEE" )
                    
                        if ! test -e no_asm.txt; then
                            printf "%s\n" "[extract_read:snk] BLAST ASSEMBLY $TE"
                            ### BLAST assembly on DATABASE TE
                            
                            blastn -db {input.fasta_TE} \
                               -query {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_WTDBG_${{region}}.fasta \
                               -outfmt 6 \
                               -out {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_WTDBG_${{region}}.bln ;

                            echo "[extract_read:snk] BLAST ASSEMBLY $TE PHASE 2"
                            echo "#ID:$id:$TE" >> {params.work_directory}/resume.bln ;
                            cat {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_WTDBG_${{region}}.bln >> {params.work_directory}/resume.bln ;

                            cat {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_WTDBG_${{region}}.bln | sort -k 12 -n | tail -n 1 | sed -e "s/ctg*/$region":WTDGB:"$TE/g" >> {params.work_directory}/all_TE_assembly.bln
                        fi;
                    fi;
                fi;
            fi;
        done;

        rm -fr {params.work_directory}/WTDGB/

        echo "ASSEMBLY DONE ----------------------------------------";

        for i in `cat {params.work_directory}/all_TE_assembly.bln | cut -f 1 | cut -d":" -f 2`; do 
            qseqid=`grep ":$i:" {params.work_directory}/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv | cut -f 2`;
            if [[ `echo $qseqid` = "" ]]; then 
                qseqid=`grep ":$i:" {params.work_directory}/BLAST_SEQUENCE_INDEL_vs_DBTE.bln | cut -f 1 | head -n 1`;
                qseqid=`echo $qseqid":ONLY_ASM"`
                ET=`grep ":$i:" {params.work_directory}/BLAST_SEQUENCE_INDEL_vs_DBTE.bln | cut -f 2 | head -n 1`;
            else
                ET=`grep ":$i:" {params.work_directory}/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv | cut -f 1`;
            fi;

            qid_old=`grep ":$i:" {params.work_directory}/all_TE_assembly.bln | cut -f 1`;
            echo "[extract_read:snk] $qseqid -- $qid_old -- $ET -- $i" ;
            cat {params.work_directory}/all_TE_assembly.bln | grep ":$i:" | sed "s/$qid_old/$qseqid":"$ET/g";
        done > {params.work_directory}/all_TE_assembly_format_old.bln;

        python3 ${{path_to_pipline}}/scripts_python/parse_blast_main.py {params.work_directory}/all_TE_assembly_format_old.bln {params.work_directory}/all_TE_assembly.csv ;

        NB_REGION=`ls {params.work_directory}/ID_READS_TE | wc -l` ;
        NB_READS=`ls {params.work_directory}/READ_FASTQ_TE | wc -l` ;

        rm -f reads_format.fastq;

        #if [ $NB_REGION -ne $NB_READS ]; then rm -f {params.work_directory}/resume.txt ; echo 'Error : the number of files region it is not equal the number reads files'; fi;

        echo "[extract_read:snk] $NB_READS AND $NB_REGION";

        """

#END assembly_wdtgb


#Get reads supports
rule extract_read :
    input:
        vcf      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SV.vcf",
        read     = config["DATA"]["SAMPLE"],
        fasta_TE = config["DATA"]["TE_DB"],
        all_te   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        bln      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/BLAST_SEQUENCE_INDEL_vs_DBTE.bln",

    output:
        touch("extract_read.done"),

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        #Choice
        FLYE           = config["LOCAL_ASSEMBLY"]["FLYE"],
        WTDGB          = config["LOCAL_ASSEMBLY"]["WTDGB"],

        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

    shell:
        """
        printf "%s\n" "{params.cmess} [SNK] GET READS AND ASSEMBLY [^-^] {params.cend}"

        #rm -fr {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/
        #rm -fr {params.work_directory}/READ_FASTQ_TE

        mkdir -p {params.work_directory}/READ_FASTQ_TE ;
        mkdir -p {params.work_directory}/READ_FASTQ_TE_ASSEMBLY ;

        #BUG
        test -e {params.work_directory}/all_TE_assembly.bln && cat {params.work_directory}/all_TE_assembly.bln > {params.work_directory}/all_TE_assembly_before.bln

        path_to_pipline=`dirname {params.path_snk}`

        ##only TE found
        awk 'NR>1 {{print $2}}' {input.all_te} | cut -d":" -f 5 > {params.work_directory}/ID_TE_SV_REPORT.txt ; 

        #GET ID match BLAST
        #cat {input.bln} | cut -f 1 | sort | uniq | cut -d":" -f 5 > {params.work_directory}/ID_SV_ALL.txt

        #TEST
        cat {params.work_directory}/ID_TE_SV_REPORT.txt > {params.work_directory}/ID_SV_ALL.txt

        python3 ${{path_to_pipline}}/scripts_python/extract_region_reads_vcf.py {input.vcf} \
         -d {params.work_directory}/ID_READS_TE \
         -i {params.work_directory}/ID_SV_ALL.txt > {params.work_directory}/resume.txt;
        
        makeblastdb -in {input.fasta_TE} -dbtype nucl ;

        NB_FILE=`ls {params.work_directory}/ID_READS_TE | wc -l` ;
        i=0 ;
        for read_file in `ls {params.work_directory}/ID_READS_TE`; do
            region=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]"` ;
            id=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]" | cut -d":" -f 2`

            nb_read=`awk -v ID="$id" '{{if($3 == ID){{print $0}}}}' {input.vcf} | grep -o -e "RE=[0-9]*" | cut -d"=" -f 2`
            TE=`grep ":$id:[0-9]*:[IP]" {input.all_te} | cut -f 1 || echo "NONE"`

            i=$(($i + 1)) ;
            echo "[extract_read:snk] $read_file"
            echo "[extract_read:snk] $i/$NB_FILE : nb_read=$nb_read : id=$id" ;

            (! test -e {params.work_directory}/READ_FASTQ_TE/reads_$region.fastq && grep -w $id {params.work_directory}/ID_TE_SV_REPORT.txt && samtools fqidx {input.read} -r {params.work_directory}/ID_READS_TE/$read_file > {params.work_directory}/READ_FASTQ_TE/reads_$region.fq) || echo "$id NOT FOUND" ;
            
            if ! test -e {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_${{region}}.fasta; then

                if [ $nb_read -ne 1 ]; then
                    ! test -e {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq && \
                    samtools fqidx {input.read} -r {params.work_directory}/ID_READS_TE/$read_file > {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq ;

                    ! test -e {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq && \
                    python3 ${{path_to_pipline}}/scripts_python/fastq_to_fastq.py \
                     {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq \
                     {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq

                    rm -f {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq
                fi;
            fi;
        done;

        NB_REGION=`ls {params.work_directory}/ID_READS_TE | wc -l` ;
        NB_READS=`ls {params.work_directory}/READ_FASTQ_TE | wc -l` ;

        echo "[extract_read:snk] $NB_READS AND $NB_REGION";

        """

#END extract_read


#BLASt database of TE against SV (Structural variant)
rule blast :
    input:
        vcf      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SV.vcf",
        fasta_TE = config["DATA"]["TE_DB"],

    output:
        snif_seqs = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SEQUENCE_INDEL.fasta",
        bln       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/BLAST_SEQUENCE_INDEL_vs_DBTE.bln",
        all_te    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        
    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

    shell:
        """
        printf "%s\n" "{params.cmess} [SNK] BLAST [^-^] {params.cend}"

        path_to_pipline=`dirname {params.path_snk}`

        # GET SEQUENCE REPORT #
        python3 ${{path_to_pipline}}/scripts_python/get_seq_vcf.py -m 150 {input.vcf} {output.snif_seqs} ;

        # BLAST SEQUENCE VCF on DATABASE TE #
        makeblastdb -in {input.fasta_TE} -dbtype nucl ;
        blastn -db {input.fasta_TE} -query {output.snif_seqs} -outfmt 6 -out {output.bln} ;

        # FILTER TE BLAST #
        python3 ${{path_to_pipline}}/scripts_python/parse_blast_main.py {output.bln} {output.all_te} ;
        
        """

#END blast



#Get Strucural Variant (vcf file)
rule sniffles :
    input:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME_MD.sorted.bam",

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SV.vcf", 
        
    params:
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

    shell:
        """
        printf "%s\n" "{params.cmess} [SNK] SNIFFLES [^-^] {params.cend}"

        sniffles --report_seq -s 1 -m {input} -v {output} -n -1 ;
        """

#END sniffles


#Sort and callmd
rule samtools :
    input:
        sam    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME.sam",
        genome = config["DATA"]["GENOME"],

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME_MD.sorted.bam",
        
    params:
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,

    shell:
        """
        printf "%s\n" "{params.cmess} [SNK] SAMTOOLS [^-^] {params.cend}"

        samtools view -S -b {input.sam} > {input.sam}.bam ;
        samtools sort {input.sam}.bam -o {input.sam}.sorted.bam ;
        samtools calmd -b {input.sam}.sorted.bam {input.genome} > {output} ; #CALL MD for sniffles

        rm -f {input.sam} \
        {input.sam}.bam \
        {input.sam}.sorted.bam \
        {input.sam}.sorted.bam;
        """

#END samtools


#Map reads on assembly genome
rule mapping :
    input:  
        read   = config["DATA"]["SAMPLE"],
        genome = config["DATA"]["GENOME"],

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME.sam",
    
    params:
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),
        config         = json.dumps(config),

        preset         = config["params"]["MINIMAP2"]["PRESET_OPTION"] if config["params"]["MINIMAP2"]["PRESET_OPTION"] != "" else "map-ont",
        option         = config["params"]["MINIMAP2"]["OPTION"],

        #COLOR 
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
    shell:
        """
        printf "%s\n" "{params.cmess} [SNK] MINIMAP2 MAPPING {params.cend}"

        minimap2 -x  {params.preset} -d {input.genome}.mmi {input.genome} ;
        minimap2 -ax {params.preset} {params.option} {input.genome} {input.read} > {output} ;
        """
   

#END mapping
