###################################################################################################################################
#
# Copyright 2019-2020 IRD-CNRS-Lyon1 University
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/> or
# write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301, USA.
#
# You should have received a copy of the CeCILL-C license with this program.
# If not see <http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.txt>
#
# Intellectual property belongs to authors and IRD, CNRS, and Lyon 1 University  for all versions
# Version 0.1 written by Mourdas Mohamed
#                                                                                                                                   
####################################################################################################################################


#IMPORT
import json
import os

#Class
class bcolors:
    VIOLET    = '\033[95m'
    RED       = '\033[91m'
    BLUE      = '\033[94m'
    CYAN      = '\033[96m'
    GREEN     = '\033[92m'
    WARNING   = '\033[93m'
    FAIL      = '\033[91m'
    BOLD      = '\033[1m'
    END       = '\033[0m'
    UNDERLINE = '\033[4m'

def message_color(color, text):
    return color + text + bcolors.END

#create ouput folder
os.system("mkdir -p " + config["DATA"]["WORK_DIRECTORY"])

#remember the parameters associated with the output folder
with open(config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/params.log", "w") as file:
    file.write(json.dumps(config))



## Get path snakefile
path_snk = ""

i = 0
while i < len(sys.argv) and path_snk == "" :
    if sys.argv[i] == "--snakefile" :
        path_snk = sys.argv[i + 1]

    i += 1
#

os.system("cat `dirname " + path_snk + "`/TrEMOLO.txt")

rule TSD :
    input:
        total     = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/TE_REPORT_total_find.fasta",
        fasta_TE  = config["DATA"]["TE_DB"],

    output:
        "resume_TSD.txt",

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),
        name_genome    = config["DATA"]["GENOME"].split("/")[-1].split(".")[0],

    shell:
        """
        rm -f resume_TSD.txt;
        touch resume_TSD.txt;
        echo '-----------TSD----------' ;
        mkdir -p {params.work_directory}/TSD ;
        path_to_pipline=`dirname {params.path_snk}`
        
        read_directory="{params.work_directory}/READ_FASTQ_TE"
        fasta_dir_find="{params.work_directory}/FASTA_FIND"

        NB_FILE=`ls {params.work_directory}/ET_FIND_FA | wc -l` ;
        i=0 ;
        for TE_found_fa in `ls {params.work_directory}/ET_FIND_FA/`; do

            i=$(($i + 1)) ;
            echo "[TSD:snk] $i/$NB_FILE" ;
            name_te=`echo $TE_found_fa | grep -o "_[^_]*\." | grep -o "[^_]*" | sed 's/\.$//g'` ;
            SIZE_TSD=`grep -w "${{name_te}}" ${{path_to_pipline}}/TSD/TE_SIZE_TSD.txt || echo -1`##EX: ZAM 4 :or: -1
            if [[ $SIZE_TSD -ne -1 ]]; then
                SIZE_TSD=`echo $SIZE_TSD | awk '{print $2}'`##EX: 4
            fi;
            echo TE=$nameTE SIZE_TSD = `grep -w "${{name_te}}" ${{path_to_pipline}}/TSD/TE_SIZE_TSD.txt || echo NONE`
            sh ${{path_to_pipline}}/TSD/find_fq_to_fasta.sh {params.work_directory}/ET_FIND_FA/$TE_found_fa ${{read_directory}} ${{fasta_dir_find}} ;
            sh ${{path_to_pipline}}/TSD/tsd_te.sh {params.work_directory}/ET_FIND_FA/$TE_found_fa ${{read_directory}} ${{fasta_dir_find}} {input.fasta_TE} 30 $SIZE_TSD ;
            
            mv total_results_tsd.txt total_results_tsd_${{name_te}}.txt ;
            mv total_results_tsd_${{name_te}}.txt {params.work_directory}/TSD/ ;
            echo ${{name_te}} >> resume_TSD.txt
            tail -n 8 {params.work_directory}/TSD/total_results_tsd_${{name_te}}.txt >> resume_TSD.txt
        done;

        echo '-----------TSD DONE----------' ; 

        """


#Get pifluster flanking genes
# rule picluster_flanking_genes :
#     input:
#         config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/" + "resume.txt",
#         genome    = config["DATA"]["GENOME"],
#         all_te    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/" + config["name_out"] + "_cnTE_ALL_ET.csv",
#         snif_seqs = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/" + config["name_out"] + "_sniffle.fasta",

#     output:
#         config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/PICLUSTER/"  + config["DATA"]["GENOME"].split("/")[-1].split(".")[0] + "_IN_CLUSTER_COV_hit_map.csv",

#     params:
#         path_snk       = path_snk,
#         name_out       = config["name_out"],
#         work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),
#         name_genome    = config["DATA"]["GENOME"].split("/")[-1].split(".")[0],

#     shell:
#         """

#         echo '-----------PiCluster----------' ;
#         #mkdir -p {params.work_directory} ;
#         path_to_pipline=`dirname {params.path_snk}`
        
#         makeblastdb -in {input.genome} -dbtype nucl ;
#         blastn -db {input.genome} -query ${{path_to_pipline}}/data_test/picluster/genes_dm_picl.fasta -outfmt 6 -out {params.work_directory}/Gene_{params.name_genome}_full.bln ;
        
#         python3 ${{path_to_pipline}}/scripts_python/picluster_gene.py {input.genome} {params.work_directory}/Gene_{params.name_genome}_full.bln ${{path_to_pipline}}/data_test/picluster/pair_genes.csv {input.all_te} ;
#         #Rscript --vanilla ${{path_to_pipline}}/scripts_R/hit_pilcuster.R PICLUSTER/{params.name_genome}_IN_CLUSTER_COV_hit_map.csv ;
#         mv PICLUSTER/ {params.work_directory}/

#         """


#Get just sequence potentiel candidate of TE
rule get_TE_seq :
    input:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/" + "resume.txt",
        all_te    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        snif_seqs = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SEQUENCE_INDEL.fasta",

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/TE_REPORT_total_find.fasta",

    params:
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

    shell:
        """
        mkdir -p {params.work_directory}/ET_FIND_FA ;
        
        rep="{params.work_directory}/ET_FIND_FA" 
        prefix="TE_REPORT"
        
        awk -v dir="$rep" -v prefix="$prefix" 'BEGIN{{OFS="\t"}} NR>1 {{if($8<$9){{print $2, $8-1, $9  >> dir"/"prefix"_find_"$1".bed"}}else{{print $2, $9-1, $8  >> dir"/"prefix"_find_"$1".bed"}} }}' {input.all_te} ;
        for i in `ls {params.work_directory}/ET_FIND_FA`; do
            bedtools getfasta -fi {input.snif_seqs} \
             -bed {params.work_directory}/ET_FIND_FA/$i > {params.work_directory}/ET_FIND_FA/TE_REPORT_find_`echo $i | grep -o "_[^_]*\." | grep -o "[^_]*" | sed 's/\.$//g'`.fasta; 
        done ;

        rm -f {params.work_directory}/ET_FIND_FA/*.bed ;
        cat {params.work_directory}/ET_FIND_FA/* > {params.work_directory}/TE_REPORT_total_find.fasta ;
        """


#Get reads supports
rule extract_read :
    input:
        vcf      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SV.vcf",
        read     = config["DATA"]["SAMPLE"],
        fasta_TE = config["DATA"]["TE_DB"],
        all_te   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        bln      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/BLAST_SEQUENCE_INDEL_vs_DBTE.bln",

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/" + "resume.txt",

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        #Choice
        FLYE           = config["LOCAL_ASSEMBLY"]["FLYE"],
        WTDGB          = config["LOCAL_ASSEMBLY"]["WTDGB"],

        #Color message
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

    shell:
        """
        echo '<<<<<<<<<<<<<<<< GET READS >>>>>>>>>>>>>>>>>>>>>>>' ;
        printf "%s\n" "{params.cmess} [SNK] GET READS AND ASSEMBLY [^-^] {params.cend}"

        mkdir -p {params.work_directory}/READ_FASTQ_TE ;
        mkdir -p {params.work_directory}/READ_FASTQ_TE_ASSEMBLY ;

        #BUG
        test -e {params.work_directory}/all_TE_assembly.bln && cat {params.work_directory}/all_TE_assembly.bln > {params.work_directory}/all_TE_assembly_before.bln
        rm -f {params.work_directory}/all_TE_assembly.bln
        touch {params.work_directory}/all_TE_assembly.bln

        rm -f {params.work_directory}/resume.bln
        touch {params.work_directory}/resume.bln

        rm -f {params.work_directory}/not_assembly.txt
        touch {params.work_directory}/not_assembly.txt

        path_to_pipline=`dirname {params.path_snk}`

        ##only TE found
        awk 'NR>1 {{print $2}}' {input.all_te} | cut -d":" -f 5 > {params.work_directory}/ID_TE_SV_REPORT.txt ; 

        ##Get ID if RE>5
        #grep -E "<INS>" {input.vcf} | awk '{{ split($8, a, "RE="); read_support=a[2]; if(read_support > 5){{print $3}} }}' > {params.work_directory}/ID_SV.txt

        #GET ID match BLAST
        cat {input.bln} | cut -f 1 | sort | uniq | cut -d":" -f 5 > {params.work_directory}/ID_SV_ALL.txt

        python3 ${{path_to_pipline}}/scripts_python/extract_region_reads_vcf.py {input.vcf} \
         -d {params.work_directory}/ID_READS_TE \
         -i {params.work_directory}/ID_SV_ALL.txt > {params.work_directory}/resume.txt;
        
        #cat {params.work_directory}/resume.txt;

        makeblastdb -in {input.fasta_TE} -dbtype nucl ;

        NB_FILE=`ls {params.work_directory}/ID_READS_TE | wc -l` ;
        i=0 ;
        for read_file in `ls {params.work_directory}/ID_READS_TE`; do
            region=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]"` ;
            id=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]" | cut -d":" -f 2`

            #nb_read=`grep ":$id:" {input.all_te} | cut -f 2 | cut -d ":" -f 6`
            nb_read=`awk -v ID="$id" '{{if($3 == ID){{print $0}}}}' {input.vcf} | grep -o -e "RE=[0-9]*" | cut -d"=" -f 2`
            TE=`grep ":$id:[0-9]*:[IP]" {input.all_te} | cut -f 1 || echo "NONE"`

            i=$(($i + 1)) ;
            echo "[extract_read:snk] $read_file"
            echo "[extract_read:snk] $i/$NB_FILE : nb_read=$nb_read : id=$id" ;

            ##if it is in TE REPORT
            (! test -e {params.work_directory}/READ_FASTQ_TE/reads_$region.fastq && grep -w $id {params.work_directory}/ID_TE_SV_REPORT.txt && samtools fqidx {input.read} -r {params.work_directory}/ID_READS_TE/$read_file > {params.work_directory}/READ_FASTQ_TE/reads_$region.fastq) || echo "$id NOT FOUND" ;
            
            if ! test -e {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_${{region}}.fasta; then

                if [ $nb_read -ne 1 ]; then
                    ! test -e {params.work_directory}/READ_FASTQ_TE/reads_$region.fastq && \
                    samtools fqidx {input.read} -r {params.work_directory}/ID_READS_TE/$read_file > {params.work_directory}/READ_FASTQ_TE/reads_$region.fastq ;
                    rm -f no_asm.txt;
                    python3 ${{path_to_pipline}}/scripts_python/fastq_to_fastq.py {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq reads_format.fastq
                    
                    if [ {params.FLYE} = "True" ]; then
                        ${{path_to_pipline}}/bin/Flye/bin/flye -t 8 --nano-raw reads_format.fastq --out-dir flye_out --plasmids --genome-size 500K -i 4 -m 1000 || ( echo $id >> not_assembly.txt && touch no_asm.txt )
                        
                        if ! test -e no_asm.txt; then
                            printf "[extract_read:snk] BLAST ASSEMBLY $TE"
                            ### BLAST assembly on DATABASE TE
                            
                            blastn -db {input.fasta_TE} -query flye_out/assembly.fasta -outfmt 6 -out {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_${{region}}.bln ;
                            echo "[extract_read:snk] BLAST ASSEMBLY $TE PHASE 2"
                            echo "#ID:$id:$TE" >> {params.work_directory}/resume.bln ;
                            cat {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_${{region}}.bln >> {params.work_directory}/resume.bln ;

                            cat {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_${{region}}.bln | sort -k 12 -n | tail -n 1 | sed -e "s/contig_[0-9]*/"$region"":""ASM"/g" >> {params.work_directory}/all_TE_assembly.bln
                            
                            ### ASSEMBLY LOCAL
                            cp flye_out/assembly.fasta {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_Flye_${{region}}.fasta
                            mv flye_out {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/ASM_FLYE_$region
                        fi;

                    elif [ {params.WTDGB} = "True" ]; then
                        wtdbg2 -i reads_format.fastq -fo {params.work_directory}/WTDGB/dbg
                        wtpoa-cns -t 16 -i {params.work_directory}/WTDGB/dbg.ctg.lay.gz -fo {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_WTDBG_${{region}}.fasta
                    fi;
                fi;
            fi;
        done;

        rm -fr {params.work_directory}/WTDGB/

        for i in `cat {params.work_directory}/all_TE_assembly.bln | cut -f 1 | cut -d":" -f 2`; do 
            qseqid=`grep ":$i:" {params.work_directory}/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv | cut -f 2`;
            if [[ `echo $qseqid` = "" ]]; then 
                qseqid=`grep ":$i:" {params.work_directory}/BLAST_SEQUENCE_INDEL_vs_DBTE.bln | cut -f 1 | head -n 1`;
                qseqid=`echo $qseqid":ONLY_ASM"`
                ET=`grep ":$i:" {params.work_directory}/BLAST_SEQUENCE_INDEL_vs_DBTE.bln | cut -f 2 | head -n 1`;
            else
                ET=`grep ":$i:" {params.work_directory}/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv | cut -f 1`;
            fi;

            qid_old=`grep ":$i:" {params.work_directory}/all_TE_assembly.bln | cut -f 1`;
            cat {params.work_directory}/all_TE_assembly.bln | grep ":$i:" | sed "s/$qid_old/$qseqid":"$ET/g";
        done > {params.work_directory}/all_TE_assembly_format_old.bln;

        python3 ${{path_to_pipline}}/scripts_python/parse_blast_main.py {params.work_directory}/all_TE_assembly_format_old.bln {params.work_directory}/all_TE_assembly.csv ;

        NB_REGION=`ls {params.work_directory}/ID_READS_TE | wc -l` ;
        NB_READS=`ls {params.work_directory}/READ_FASTQ_TE | wc -l` ;

        rm -f reads_format.fastq;

        #if [ $NB_REGION -ne $NB_READS ]; then rm -f {params.work_directory}/resume.txt ; echo 'Error : the number of files region it is not equal the number reads files'; fi;

        echo "[extract_read:snk] $NB_READS AND $NB_REGION";

        """


#BLASt database of TE against SV (Structural variant)
rule blast :
    input:
        vcf      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SV.vcf",
        fasta_TE = config["DATA"]["TE_DB"],

    output:
        snif_seqs = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SEQUENCE_INDEL.fasta",
        bln       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/BLAST_SEQUENCE_INDEL_vs_DBTE.bln",
        all_te    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        
    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

    shell:
        """
        ####echo '<<<<<<<<<<<<<<<< BLAST >>>>>>>>>>>>>>>>>>>>>>>' ;
        printf "%s\n" "{params.cmess} [SNK] BLAST [^-^] {params.cend}"

        path_to_pipline=`dirname {params.path_snk}`

        ### GET SEQUENCE REPORT 
        python3 ${{path_to_pipline}}/scripts_python/get_seq_vcf.py {input.vcf} {output.snif_seqs} ;

        ### BLAST SEQUENCE VCF on DATABASE TE
        makeblastdb -in {input.fasta_TE} -dbtype nucl ;
        blastn -db {input.fasta_TE} -query {output.snif_seqs} -outfmt 6 -out {output.bln} ;

        ### FILTER BLAST
        python3 ${{path_to_pipline}}/scripts_python/parse_blast_main.py {output.bln} {output.all_te} ;
        
        #####python3 ${{path_to_pipline}}/scripts_python/parse_blast_main.py {output.bln} {output.all_te} ;

        """


#Get Strucural Variant (vcf file)
rule sniffles :
    input:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME_MD.sorted.bam",

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SV.vcf", 
        
    params:
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),


        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

    shell:
        """
        #echo '<<<<<<<<<<<<<<<< SNIFFLES >>>>>>>>>>>>>>>>>>>>>>>' ;
        printf "%s\n" "{params.cmess} [SNK] SNIFFLES [^-^] {params.cend}"

        (which sniffles && printf "%s\n" "{params.cmess} [^-^] sniffles [OK] {params.cend}") \
        || (printf "%s\n" "{params.cfail} [~-~] ERROR {params.cend} sniffles access error not found in \$PATH" && exit 1)        

        sniffles --report_seq -s 1 -m {input} -v {output} -n -1 ;
        """


#Sort and callmd
rule samtools :
    input:
        sam    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME.sam",
        genome = config["DATA"]["GENOME"],

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME_MD.sorted.bam",
        
    params:
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

    shell:
        """
        #####echo '<<<<<<<<<<<<<<<< SAMTOOLS >>>>>>>>>>>>>>>>>>>>>>>' ;
        printf "%s\n" "{params.cmess} [SNK] SAMTOOLS [^-^] {params.cend}"

        (which samtools && printf "%s\n" "{params.cmess} [^-^] samtools [OK] {params.cend}") \
        || (printf "%s\n" "{params.cfail} [~-~] ERROR {params.cend} samtools access error not found in \$PATH" && exit 1)

        samtools view -S -b {input.sam} > {input.sam}.bam ;
        samtools sort {input.sam}.bam -o {input.sam}.sorted.bam ;
        samtools calmd -b {input.sam}.sorted.bam {input.genome} > {output} ; #CALL MD for sniffles

        rm -f {input.sam} ;
        rm -f {input.sam}.bam ;
        rm -f {input.sam}.sorted.bam ;
        rm -f {input.sam}.sorted.bam ;
        """


#Map reads on assembly genome
rule mapping :
    input:  
        read   = config["DATA"]["SAMPLE"],
        genome = config["DATA"]["GENOME"],

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME.sam",
    
    params:
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),
        config         = json.dumps(config),

        preset         = config["params"]["MINIMAP2"]["PRESET_OPTION"] if config["params"]["MINIMAP2"]["PRESET_OPTION"] != "" else "map-ont",
        thread         = config["params"]["MINIMAP2"]["THREAD"] if config["params"]["MINIMAP2"]["THREAD"] >= 1 else 8,

        #COLOR 
        #mess           = message_color(bcolors.CYAN, "[SNK] MINIMAP2 MAPPING [^-^]")
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
    shell:
        """
        ####echo '<<<<<<<<<<<<<<<<<<< MINIMAP2 MAPPING >>>>>>>>>>>>>>>>>>>>' ;
        printf "%s\n" "{params.cmess} [SNK] MINIMAP2 MAPPING [^-^] {params.cend}"

        (which minimap2 && printf "%s\n" "{params.cmess} [^-^] minimap2 [OK] {params.cend}") \
        || (printf "%s\n" "{params.cfail} [~-~] ERROR {params.cend} minimap2 access error not found in \$PATH" && exit 1)
        
        minimap2 -x  {params.preset} -d {input.genome}.mmi {input.genome} ;
        minimap2 -ax {params.preset} -t {params.thread} {input.genome} {input.read} > {output} ;
        """
        

#for i in `cat ID_nameTE.txt`; do mkdir READ_BY_TE^Cgrep $i G73vsG73TEST_cnTE_ALL_ET.csv; done;
#for i in `cat all_TE_assembly.bln | cut -f 1 | cut -d":" -f 2`; do qseqid=`grep ":$i:" G73vsG73LR_cnTE_ALL_ET.csv | cut -f 2`; qid_old=`grep ":$i:" all_TE_assembly.bln | cut -f 1`; ET=`grep ":$i:" G73vsG73LR_cnTE_ALL_ET.csv | cut -f 1`; cat all_TE_assembly.bln | grep ":$i:" | sed "s/$qid_old/$qseqid":"$ET/g"; done > new.bln;

#ASFL
#rm -f   && touch
# while read l; do 
#     chrom=`echo $l | cut -d" " -f 1`
#     start=`echo $l | awk '{print $2-140}'`;
#     end=`echo $l | awk '{print $3+140}'`; 
#     #echo $chrom  $start   $end
#     awk -v start="$start" -v end="$end"  '{if($2>start && $3<end){print $0}}' ETLRvsG73_addVR_2L.bed
#     echo "#----"
#     #grep $chrom ETLRvsG73_addVR.bed | awk '{if($2>start && $3<end){print $0}}' 
# done < true_bed.bed | tr " " "\t" > ETSR_on_TE.bed;