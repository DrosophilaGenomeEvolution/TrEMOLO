
####
####
############# OUTSIDER VARIANT
####
####


#TODO TSD file to work_directory
rule RENAME_PSEUDO_TE:
    input:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/LIST_HEADER_DB_TE.csv",
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/REPORT/report.html",
    output:
        
    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        choice_outsider_sv  = config["CHOICE"]["PIPELINE"]["OUTSIDER_VARIANT"],
        choice_insider_sv   = config["CHOICE"]["PIPELINE"]["INSIDER_VARIANT"],

        INTERMEDIATE_FILE   = config["CHOICE"]["INTERMEDIATE_FILE"],

        CHROM_KEEP       = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["CHROM_KEEP"],
        
        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/RENAME",


    shell:
        """
        {params.env}

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] RENAME PSEUDO TE [^-^] {params.cend}"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        rm -f {log}.*
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        
        path_to_pipline=`dirname {params.path_snk}`

        ## TODO DELETE THIS
        sed -i 's/original=>//g' {params.work_directory}/LIST_HEADER_DB_TE.csv
        sed -i 's/pseudo=>//g' {params.work_directory}/LIST_HEADER_DB_TE.csv

        ## CHANGE DIRECTORY
        old_path=`pwd`
        _realpath=`realpath {params.work_directory}`
        basename=`basename {params.work_directory}`
        cd {params.work_directory}/REPORT/mini_report/web/js/

        awk  'NR>1 {{ split($4, sp, "|"); print sp[1] }}' ${{_realpath}}/TE_INFOS.bed | sort -u > ${{_realpath}}/tmp_LIST_TE_TO_CHANGE.txt

        ## RENAME TE IN REPORT JS
        echo "RENAME TE IN REPORT JS...";
        
        for file in `ls | grep ".js$" | grep -e  "SIDER" | grep -v "TRUE_NAME_" | grep -v "TE_INSIDER_DEL"`; do
            echo "FILE : $file";
            #rm -f TRUE_NAME_$file && cat $file > TRUE_NAME_$file;
            for ID in `cat ${{_realpath}}/tmp_LIST_TE_TO_CHANGE.txt`; do 
                new=`grep -w $ID ../../../../LIST_HEADER_DB_TE.csv | cut -f 1 || echo ""`
                #echo "ID: $ID; new : $new;"
                #sed -i "s/$ID\\"/$new\\"/g" TRUE_NAME_$file;
                if [ -n "$new" ] && [ "$ID" != "$new" ]; then
                    #sed -i "s/$ID\\"/$new\\"/g" $file;
                    python3 ${{path_to_pipline}}/lib/python/others/replace.py "$ID" "$new" $file
                fi;
            done;
            #template_file=`grep -rnw "$file" ../lib/ | cut -d ":" -f 1`
            #echo "change data on template_file : $template_file --"
            # if [ -n "$template_file" ]; then
            #     echo "REPLACE";
            #     sed -i "s/${{file}}/TRUE_NAME_${{file}}/g" ${{template_file}};
            # fi;
        done;
        #rm -f ${{_realpath}}/tmp_LIST_TE_TO_CHANGE.txt

        #rm -f TRUE_NAME_COUNT_TE_INSIDER_DEL.js && cat COUNT_TE_INSIDER_DEL.js > TRUE_NAME_COUNT_TE_INSIDER_DEL.js;
        for ID in `grep -w "TrEMOLOTE[0-9]*" COUNT_TE_INSIDER_DEL.js -o | sort -u`; do 
            new=`grep -w $ID ../../../../LIST_HEADER_DB_TE.csv | cut -f 1 || echo ""`
            
            if [ -n "$new" ] && [ "$ID" != "$new" ]; then
                #sed -i "s/$ID\\"/$new\\"/g" COUNT_TE_INSIDER_DEL.js;
                python3 ${{path_to_pipline}}/lib/python/others/replace.py "$ID" "$new" COUNT_TE_INSIDER_DEL.js
            fi;
        done;
        sed -i "s/COUNT_TE_INSIDER_DEL.js/TRUE_NAME_COUNT_TE_INSIDER_DEL.js/g" ../lib/template_COUNT_TE_INSIDER_DEL.html;

        cd ${{old_path}};

        #RENAME BED
        echo "RENAME TE BED..."

        NB_TE=`ls {params.work_directory} | grep ".bed$" -c`;

        i=0;
        show_step="$i/$NB_TE FILE"
        number_of_char=`echo "$show_step" | wc -c`
        number_of_char=$(($number_of_char-1));
        printf "\b%.0s" `seq 1 $number_of_char`
        printf "$show_step";

        for file in `ls {params.work_directory} | grep ".bed$"`; do
            for ID in `awk  '{{ split($4, sp, "|"); print sp[1] }}' {params.work_directory}/$file | sort -u`; do 
                new=`grep -w "$ID" {params.work_directory}/LIST_HEADER_DB_TE.csv | cut -f 1 || echo ""`

                if [ -n "$new" ] && [ "$ID" != "$new" ]; then
                    #sed -i "s/${{ID}}/${{new}}/g" {params.work_directory}/$file;
                    python3 ${{path_to_pipline}}/lib/python/others/replace.py "$ID" "$new" {params.work_directory}/$file;
                fi;
            done;

            i=$(($i+1));
            show_step="$i/$NB_TE FILE"
            number_of_char=`echo "$show_step" | wc -c`
            number_of_char=$(($number_of_char-1));
            printf "\b%.0s" `seq 1 $number_of_char`
            printf "$show_step";
        done;

        ## RENAME CSV
        echo -e "\\nRENAME TE CSV..."
        for file in `ls {params.work_directory} | grep ".csv$" | grep -v "LIST_HEADER_DB_TE.csv"`; do
            for ID in `cat {params.work_directory}/tmp_LIST_TE_TO_CHANGE.txt`; do
                new=`grep -w $ID {params.work_directory}/LIST_HEADER_DB_TE.csv | cut -f 1`

                #sed -i "s/$ID/$new/g" {params.work_directory}/$file
                python3 ${{path_to_pipline}}/lib/python/others/replace.py "$ID" "$new" {params.work_directory}/$file;
            done;
        done;


        #OUTSIDER sniffles
        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv && \
            for file in `ls {params.work_directory}/OUTSIDER/TE_DETECTION | grep ".csv$" `; do
                for ID in `cat {params.work_directory}/tmp_LIST_TE_TO_CHANGE.txt`; do
                    new=`grep -w $ID {params.work_directory}/LIST_HEADER_DB_TE.csv | cut -f 1`
                    # echo "new : $new; ID : $ID";
                    #sed -i "s/$ID/$new/g" {params.work_directory}/OUTSIDER/TE_DETECTION/$file;
                    python3 ${{path_to_pipline}}/lib/python/others/replace.py "$ID" "$new" {params.work_directory}/OUTSIDER/TE_DETECTION/$file;
                done;
            done;


        #OUTSIDER TrEMOLO
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.bed && \
            for file in `ls {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/ | grep ".csv$" `; do
                for ID in `cat {params.work_directory}/tmp_LIST_TE_TO_CHANGE.txt`; do
                    new=`grep -w $ID {params.work_directory}/LIST_HEADER_DB_TE.csv | cut -f 1`

                    #sed -i "s/$ID/$new/g" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/$file;
                    python3 ${{path_to_pipline}}/lib/python/others/replace.py "$ID" "$new" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/$file;
                done;
            done;


        #OUTSIDER SOFT
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.csv && \
            for file in `ls {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/ | grep -E ".csv$" `; do
                for ID in `cat {params.work_directory}/tmp_LIST_TE_TO_CHANGE.txt`; do
                    new=`grep -w $ID {params.work_directory}/LIST_HEADER_DB_TE.csv | cut -f 1`

                    #sed -i "s/$ID/$new/g" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/$file;
                    python3 ${{path_to_pipline}}/lib/python/others/replace.py "$ID" "$new" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/$file;
                done;
            done;


        #OUTSIDER HARD
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.csv && \
            for file in `ls {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/ | grep -E ".csv$" `; do
                for ID in `cat {params.work_directory}/tmp_LIST_TE_TO_CHANGE.txt`; do
                    new=`grep -w $ID {params.work_directory}/LIST_HEADER_DB_TE.csv | cut -f 1`

                    #sed -i "s/$ID/$new/g" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/$file;
                    python3 ${{path_to_pipline}}/lib/python/others/replace.py "$ID" "$new" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/$file;
                done;
            done;


        #INSIDER
        test -s {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv && \
            for file in ` ls {params.work_directory}/INSIDER/TE_DETECTION | grep ".csv$" `; do
                for ID in `cat {params.work_directory}/tmp_LIST_TE_TO_CHANGE.txt`; do
                    new=`grep -w $ID {params.work_directory}/LIST_HEADER_DB_TE.csv | cut -f 1`

                    #sed -i "s/$ID/$new/g" {params.work_directory}/INSIDER/TE_DETECTION/$file;
                    python3 ${{path_to_pipline}}/lib/python/others/replace.py "$ID" "$new" {params.work_directory}/INSIDER/TE_DETECTION/$file;
                done;
            done;


        test -s {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.bln && \
            python3 ${{path_to_pipline}}/lib/python/others/replace_2.py {params.work_directory}/LIST_HEADER_DB_TE.csv \
                {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.bln \
                2 > {params.work_directory}/tmp.bln && \
                    cat {params.work_directory}/tmp.bln > {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.bln && \
                    rm -f {params.work_directory}/tmp.bln


        test -s {params.work_directory}/INSIDER/TE_DETECTION/DELETION.bln && \
            python3 ${{path_to_pipline}}/lib/python/others/replace_2.py {params.work_directory}/LIST_HEADER_DB_TE.csv \
                {params.work_directory}/INSIDER/TE_DETECTION/DELETION.bln \
                2 > {params.work_directory}/tmp.bln && \
                    cat {params.work_directory}/tmp.bln > {params.work_directory}/INSIDER/TE_DETECTION/DELETION.bln && \
                    rm -f {params.work_directory}/tmp.bln

        ## REMAKE FOR TRUE NAME REPORT
        cd {params.work_directory}/REPORT/mini_report/

        make

        cd ${{old_path}};

        #rm -f {params.work_directory}/tmp*;

        """

#END RENAME_PSEUDO_TE


rule REPORT :
    input:
        genome = config["DATA"]["GENOME"],
        input_link=[],

    output:
        #config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/TE_INFOS.bed",
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/REPORT/report.html",
        #output_link=[],
        
    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        choice_outsider_sv  = config["CHOICE"]["PIPELINE"]["OUTSIDER_VARIANT"],
        choice_insider_sv   = config["CHOICE"]["PIPELINE"]["INSIDER_VARIANT"],

        REPORT              = config["CHOICE"]["PIPELINE"]["REPORT"],
        INTERMEDIATE_FILE   = config["CHOICE"]["INTERMEDIATE_FILE"],

        CHROM_KEEP       = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["CHROM_KEEP"],
        
        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/REPORT",


    shell:
        #TODO broullion
        """

        {params.env}

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] BUILD REPORT [^-^] {params.cend}"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        rm -fr {params.work_directory}/REPORT/
        mkdir -p {params.work_directory}/REPORT/
        rm -f {log}.*
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        
        path_to_pipline=`dirname {params.path_snk}`

        
        ###BUILD BED ALL INFOS
        echo "BUILD BED ALL INFOS..."

        ##TODO remove commandes doublons
        test -s {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_TE.bed && \
            cat {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_TE.bed | bedtools sort | awk 'OFS="\t"{{ print $1, $2, $3, $4, $3-$2, $5 }}' > {params.work_directory}/POSITION_TE_INSIDER.bed

        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed && \
            ln -sfr {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed {params.work_directory}/POSITION_TE_OUTSIDER.bed
        
        #OUTSIDER
        NB_TE_OUT=`(test -s {params.work_directory}/POSITION_TE_OUTSIDER.bed && cat {params.work_directory}/POSITION_TE_OUTSIDER.bed | wc -l) || echo 0`
        NB_TE_IN=`(test -s {params.work_directory}/POSITION_TE_INSIDER.bed && cat {params.work_directory}/POSITION_TE_INSIDER.bed | wc -l) || echo 0`

        NB_TE=$(($NB_TE_OUT + $NB_TE_IN));

        ## CHECK INTERSECT TO DELETION
        echo "CHECK INTERSECT TO DELETION INSIDER...";
        test -s {params.work_directory}/POSITION_TE_OUTSIDER.bed && test -s {params.work_directory}/DELETION_TE.bed && bedtools window -a {params.work_directory}/POSITION_TE_OUTSIDER.bed -b {params.work_directory}/DELETION_TE.bed -w 30 | \
            awk '{{ split($4, sp1, "|"); split($10, sp2, "|"); if(sp1[1] == sp2[1]){{ print sp1[2] }} }}' > {params.work_directory}/ID_OUTSIDER_INTERSECT_TO_DEL.txt

        #BUILD TE_INFO OUTSIDER
        test -s {params.work_directory}/POSITION_TE_OUTSIDER.bed && \
            echo "BUILD TE_INFO OUTSIDER...";

        i=0;
        show_step="$i/$NB_TE TE"
        number_of_char=`echo "$show_step" | wc -c`
        number_of_char=$(($number_of_char-1));
        printf "\b%.0s" `seq 1 $number_of_char`
        printf "$show_step";
        rm -f {params.work_directory}/TE_INFOS.bed
        echo -e "#chrom\tstart\tend\tTE|ID\tstrand\tTSD\tpident\tpsize_TE\tSIZE_TE\tNEW_POS\tFREQ\tFREQ_WITH_CLIPPED\tSV_SIZE\tID_TrEMOLO\tTYPE" > {params.work_directory}/TE_INFOS.bed
        test -s {params.work_directory}/POSITION_TE_OUTSIDER.bed && \
            while read line;
        do
            read -r chrom start end TE ID strand <<< $(echo $line | awk 'OFS="\t"{{split($4, TE, "|"); print $1, $2, $3, TE[1], TE[2], $6}}')
            pident=`(grep -w "$ID" {params.work_directory}/OUTSIDER/TE_DETECTION/COMBINE_TE.csv || grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/COMBINE_INS_TREMOLO.csv || grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.csv || grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.csv) | cut -f 3 || echo "NONE"`;
            size_per=`(grep -w "$ID" {params.work_directory}/OUTSIDER/TE_DETECTION/COMBINE_TE.csv || grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/COMBINE_INS_TREMOLO.csv || grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.csv || grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.csv) | cut -f 4 || echo "NONE"`

            test -s {params.work_directory}/ID_OUTSIDER_INTERSECT_TO_DEL.txt && \
                intersect_to_del=`grep -w "$ID" {params.work_directory}/ID_OUTSIDER_INTERSECT_TO_DEL.txt || echo ""` || intersect_to_del="";

            TYPE_TrEMOLO=`echo "$ID" | grep -E -o "SOFT|HARD|DEL|INS" || echo "UNDEFINED"`;
            if [ -n "$intersect_to_del" ]; then
                TYPE_TrEMOLO="${{TYPE_TrEMOLO}}_DEL";
            fi;

            #TSD
            SIZE_TE="";
            TSD_OK=`grep -w "$ID" {params.work_directory}/OUTSIDER/TSD/TSD_TE.tsv | cut -f 2 || echo ""`
            if [ ! -n "$TSD_OK" ]; then
                TSD_OK="NONE"
                SIZE_TE=`grep ":$ID:[0-9]*:[IP]" {params.work_directory}/OUTSIDER/TE_DETECTION/COMBINE_TE.csv | cut -f 7 || echo "NONE"`
            else
                SIZE_TE=`grep -w "$ID" {params.work_directory}/OUTSIDER/TSD/TSD_TE.tsv | cut -f 4 | cut -d ":" -f 1 || echo "NONE"`
            fi;
            #echo "TSD_OK : $TSD_OK";

            if [ ! -n "$SIZE_TE" ]; then
                SIZE_TE="NONE"; 
            fi;

            #TSD NEW POS
            NEW_POS=`(test -s {params.work_directory}/OUTSIDER/TSD/TSD_TE.tsv && grep -w $ID {params.work_directory}/OUTSIDER/TSD/TSD_TE.tsv | cut -f 3) || echo "$start"`

            FREQ_BEFOR="";
            FREQ_AFTER="";

            test -s {params.work_directory}/OUTSIDER/FREQUENCY/FREQUENCY_TE_INS_PRECISE.tsv && \
                FREQ_BEFOR=`grep -w "$ID" {params.work_directory}/OUTSIDER/FREQUENCY/FREQUENCY_TE_INS_PRECISE.tsv | awk '$9<=100{{ print $9; }} $9>100{{ print "NONE"; }}' || echo "NONE"` && \
                FREQ_AFTER=`grep -w "$ID" {params.work_directory}/OUTSIDER/FREQUENCY/FREQUENCY_TE_INS_PRECISE.tsv | awk '$10<=100{{ print $10; }} $10>100{{ print "NONE"; }}' || echo "NONE"`;
            
            if [ "$FREQ_BEFOR" == "" ] || [ "$FREQ_BEFOR" == "NONE" ] || [ "$FREQ_AFTER" == "" ] || [ "$FREQ_AFTER" == "NONE" ]; then
                FREQ_BEFOR=`grep -w "$ID" {params.work_directory}/OUTSIDER/FREQUENCY/FREQUENCY_TE_INS.tsv | cut -f 9 || echo "NONE"`;
                FREQ_AFTER=`grep -w "$ID" {params.work_directory}/OUTSIDER/FREQUENCY/FREQUENCY_TE_INS.tsv | cut -f 10 || echo "NONE"`;
            fi;

            ! test -n "$FREQ_BEFOR" && FREQ_BEFOR="NONE-FREQB" && echo "NONE-FREQB";
            ! test -n "$FREQ_AFTER" && FREQ_AFTER="NONE-FREQA" && echo "NONE-FREQA";

            ##SIZE SV
            SV_SIZE=`grep -w "$ID" {params.work_directory}/OUTSIDER/FREQUENCY/SV_SIZE.tsv | awk 'max<$2{{ max=$2; }} END{{ if(max!=""){{ print max }} }}' || echo "NONE"`;
            ! test -n "$SV_SIZE" && SV_SIZE="NONE";

            ##ID TrEMOLO
            IS_CLIPPED=`echo "$ID" | grep -E -o "SOFT|HARD" || echo ""`

            if ! test -n "$IS_CLIPPED"; then
                #GET ID_TrEMOLO
                ID_POS=`echo $line | awk '{{print $1":"$2}}' | ${{path_to_pipline}}/lib/C++/bin/chain_to_id 2>/dev/null || echo "0"`
                TYPE=`(grep -w "$ID" {params.work_directory}/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv || grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv ) | cut -f 2  | cut -d ":" -f 2 | sed 's/[<>]//g'`
                RS=`(test -s {params.work_directory}/OUTSIDER/FREQUENCY/FREQUENCY_TE_INS.tsv && grep -w "$ID" {params.work_directory}/OUTSIDER/FREQUENCY/FREQUENCY_TE_INS.tsv | cut -f 4 | ${{path_to_pipline}}/lib/C++/bin/chain_to_id 2>/dev/null) || echo "ERROR_RS_$ID" >{log}.err`
                ! test -n "$RS" && RS=0;
                ID_TrEMOLO="TE_ID_OUTSIDER.$ID_POS.$TYPE.$RS";
            else
                ID_TrEMOLO="TE_ID_OUTSIDER.$ID"
            fi;

            echo -e "$chrom\t$start\t$end\t$TE|$ID\t$strand\t$TSD_OK\t$pident\t$size_per\t$SIZE_TE\t$NEW_POS\t$FREQ_BEFOR\t$FREQ_AFTER\t$SV_SIZE\t$ID_TrEMOLO\t$TYPE_TrEMOLO" >> {params.work_directory}/TE_INFOS.bed

            i=$(($i + 1));
            show_step="$i/$NB_TE TE "
            number_of_char=`echo "$show_step" | wc -c`
            number_of_char=$(($number_of_char-1));
            printf "\b%.0s" `seq 1 $number_of_char`
            printf "$show_step";
        done < {params.work_directory}/POSITION_TE_OUTSIDER.bed 2>&2;
        rm -f {params.work_directory}/tmp.txt
        rm -f {params.work_directory}/ID_OUTSIDER_INTERSECT_TO_DEL.txt

        printf "\b%.0s" `seq 1 10`

        awk '
            BEGIN{{
                OFS="\t"; 
                print "x", "y", "condition";
            }} 
            
            NR>1 && $6!="NONE" {{
                split($4, sp, "|"); 
                FAMILY[sp[1]]=1; 
                TSDOK[sp[1]]+=1;
            }} 
            
            NR>1 && $6=="NONE" {{
                split($4, sp, "|"); 
                FAMILY[sp[1]]; 
                TSDKO[sp[1]]+=1;
            }}
            
            END{{
                for(key in FAMILY){{
                    print key, (TSDOK[key]!="" ? TSDOK[key] : 0), "TSD OK"; 
                    print key, (TSDKO[key]!="" ? TSDKO[key] : 0 ), "TSD KO"; 
                }}
            }}' {params.work_directory}/TE_INFOS.bed > {params.work_directory}/VALUES_TSD_GROUP_OUTSIDER.csv
        
        echo "..."
        #BUILD TE_INFO INSIDER
        #INSIDER
        test -s {params.work_directory}/POSITION_TE_INSIDER.bed && \
            echo "BUILD TE_INFO INSIDER..."

        num_TE_INSIDER=0;
        test -s {params.work_directory}/POSITION_TE_INSIDER.bed && while read line;
        do
            ID=`echo "$line" | cut -f 4 | cut -d "|" -f 2`
            TE=`echo "$line" | cut -f 4 | cut -d "|" -f 1`
            chrom=`echo "$line" | cut -f 1`
            start=`echo "$line" | cut -f 2`
            end=`echo "$line" | cut -f 3`

            strand=`echo "$line" | cut -f 6`
            pident=`grep -w "$ID" {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_COMBINE_TE.csv | cut -f 3 || echo "NONE"`;
            size_per=`grep -w "$ID" {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_COMBINE_TE.csv | cut -f 4 || echo "NONE"`

            #TSD
            SIZE_TE="";
            TSD_OK=`grep -w "$ID" {params.work_directory}/INSIDER/TSD/TSD_TE.tsv | cut -f 2 || echo ""`
            if [ ! -n "$TSD_OK" ]; then
                TSD_OK="NONE"
                SIZE_TE=`grep "$ID:[+-]:" {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_COMBINE_TE.csv | cut -f 5 || echo "NONE"`
            else
                SIZE_TE=`grep -w "$ID" {params.work_directory}/INSIDER/TSD/TSD_TE.tsv | cut -f 4 || echo ""`
            fi;

            if [ ! -n "$SIZE_TE" ]; then
                SIZE_TE="NONE";
            fi;

            #TSD NEW POS
            NEW_POS=`grep -w "$ID" {params.work_directory}/INSIDER/TSD/TSD_TE.tsv | cut -f 3 || echo "$start"`

            #FREQUENCE
            FREQ_BEFOR=`grep -w "$TE|$ID" {params.work_directory}/INSIDER/FREQ_INSIDER/DEPTH_TE_INSIDER.csv 2>/dev/null | cut -f 6 || echo "NONE"`
            FREQ_AFTER="INSIDER";

            #GET ID_TrEMOLO
            ID_POS=`echo $line | awk '{{print $1":"$2}}' | ${{path_to_pipline}}/lib/C++/bin/chain_to_id 2>/dev/null || echo "0"`
            TYPE=`grep -w "$ID" {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_COMBINE_TE.csv | cut -f 2 | cut -d ":" -f 3 || echo "UNKNOWN"`

            SV_SIZE=`grep -w "$ID" {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out.Assemblytics_structural_variants.bed | awk '
                $7=="Deletion" || $7=="Repeat_contraction" || $7=="Tandem_contraction" {{ print $5 }} 
                $7=="Insertion" || $7=="Repeat_expansion" || $7=="Tandem_expansion" {{ print $9 }}
                ' || echo "NONE"`;
            ! test -n "$SV_SIZE" && SV_SIZE="NONE";

            ##ID_TrEMOLO="TE_ID_INSIDER.$ID_POS.$TYPE.$num_TE_INSIDER";
            ID_TrEMOLO="TE_ID_INSIDER.$ID_POS.$TYPE";

            echo -e "$chrom\t$start\t$end\t$TE|$ID\t$strand\t$TSD_OK\t$pident\t$size_per\t$SIZE_TE\t$NEW_POS\t$FREQ_BEFOR\t$FREQ_AFTER\t$SV_SIZE\t$ID_TrEMOLO\t$TYPE" >> {params.work_directory}/TE_INFOS.bed

            i=$(($i + 1));

            show_step="$i/$NB_TE TE"
            number_of_char=`echo "$show_step" | wc -c`
            number_of_char=$(($number_of_char-1));
            printf "\b%.0s" `seq 1 $number_of_char`
            printf "$show_step";

            num_TE_INSIDER=$(($num_TE_INSIDER+1));
        done < {params.work_directory}/POSITION_TE_INSIDER.bed;
        rm -f {params.work_directory}/ID_INSIDER_INTERSECT_TO_DEL.txt

        echo

        ( test -s {params.work_directory}/POSITION_TE_INSIDER.bed && test -s {params.work_directory}/TE_INFOS.bed && \
            grep "_INSIDER" {params.work_directory}/TE_INFOS.bed | awk '
                BEGIN{{
                    OFS="\t"; 
                    print "x", "y", "condition";
                }} 
                
                $6!="NONE" {{
                    split($4, sp, "|"); 
                    FAMILY[sp[1]]=1; 
                    TSDOK[sp[1]]+=1;
                }} 
                
                $6=="NONE" {{
                    split($4, sp, "|"); 
                    FAMILY[sp[1]]; 
                    TSDKO[sp[1]]+=1;
                }}
                
                END{{
                    for(key in FAMILY){{
                        print key, (TSDOK[key]!="" ? TSDOK[key] : 0), "TSD OK"; 
                        print key, (TSDKO[key]!="" ? TSDKO[key] : 0 ), "TSD KO"; 
                    }}
                }}' > {params.work_directory}/VALUES_TSD_INSIDER_GROUP.csv ) || \
                ( test -s {params.work_directory}/POSITION_TE_INSIDER.bed && warn_msg "Warning : NO INSIDER IN REPORT\\n" ) || echo "...";

        test -s {params.work_directory}/TE_INFOS.bed &&
            awk '
                BEGIN{{
                    OFS="\t"; 
                    print "x", "y", "condition";
                }} 
                
                NR>1 && $6!="NONE" {{
                    split($4, sp, "|"); 
                    FAMILY[sp[1]]=1; 
                    TSDOK[sp[1]]+=1;
                }} 
                
                NR>1 && $6=="NONE" {{
                    split($4, sp, "|"); 
                    FAMILY[sp[1]]; 
                    TSDKO[sp[1]]+=1;
                }}
                
                END{{
                    for(key in FAMILY){{
                        print key, (TSDOK[key]!="" ? TSDOK[key] : 0), "TSD OK"; 
                        print key, (TSDKO[key]!="" ? TSDKO[key] : 0 ), "TSD KO"; 
                    }}
                }}' {params.work_directory}/TE_INFOS.bed > {params.work_directory}/VALUES_TSD_ALL_GROUP.csv || \
                    warn_msg "WARN : NO TE DETECTED..."

        ######------------------------------
        #BUILD FILE to report.html
        echo "BUILD FILE report.html..."
        if [ {params.REPORT}  = "True" ]; then

            cp -r ${{path_to_pipline}}/report/* {params.work_directory}/REPORT/

            ## TSD
            echo "  BUILD TSD CHART..."
            echo "TSD OK" >  {params.work_directory}/.tmp_orderc.txt
            echo "TSD KO" >> {params.work_directory}/.tmp_orderc.txt

            test -s {params.work_directory}/VALUES_TSD_GROUP_OUTSIDER.csv && \
                python3 ${{path_to_pipline}}/lib/python/graphs/conv_js_histo_grouped_ggplot.py \
                {params.work_directory}/VALUES_TSD_GROUP_OUTSIDER.csv data -c {params.work_directory}/.tmp_orderc.txt > {params.work_directory}/REPORT/mini_report/js/TSD_OUTSIDER.js && \
                sed 's/%%VAR_JS%%/TSD_OUTSIDER.js/g' {params.work_directory}/REPORT/mini_report/lib/template_TSD_CHART.html \
                 > {params.work_directory}/REPORT/mini_report/lib/template_TSD_OUTSIDER_CHART.html

            test -s {params.work_directory}/VALUES_TSD_INSIDER_GROUP.csv && \
                python3 ${{path_to_pipline}}/lib/python/graphs/conv_js_histo_grouped_ggplot.py \
                {params.work_directory}/VALUES_TSD_INSIDER_GROUP.csv data -c {params.work_directory}/.tmp_orderc.txt > {params.work_directory}/REPORT/mini_report/js/TSD_INSIDER.js && \
                sed 's/%%VAR_JS%%/TSD_INSIDER.js/g' {params.work_directory}/REPORT/mini_report/lib/template_TSD_CHART.html \
                 > {params.work_directory}/REPORT/mini_report/lib/template_TSD_INSIDER_CHART.html \
                || sed -i '/TSD_INSIDER_histo/d' {params.work_directory}/REPORT/mini_report/insider.Rmd

            test -s {params.work_directory}/VALUES_TSD_ALL_GROUP.csv && \
                python3 ${{path_to_pipline}}/lib/python/graphs/conv_js_histo_grouped_ggplot.py \
                {params.work_directory}/VALUES_TSD_ALL_GROUP.csv data -c {params.work_directory}/.tmp_orderc.txt > {params.work_directory}/REPORT/mini_report/js/TSD_INOUTSIDER.js && \
                sed 's/%%VAR_JS%%/TSD_INOUTSIDER.js/g' {params.work_directory}/REPORT/mini_report/lib/template_TSD_CHART.html \
                 > {params.work_directory}/REPORT/mini_report/lib/template_TSD_INOUTSIDER_CHART.html\
                || sed -i '/TSD_ALL_histo/d' {params.work_directory}/REPORT/mini_report/inoutsider.Rmd

            rm -f {params.work_directory}/.tmp_orderc.txt

            samtools faidx {input.genome}
            mkdir -p {params.work_directory}/js

            echo "  BUILD chroms for scatter FREQUENCY js ..."
            cut -f 1 {params.work_directory}/TE_INFOS.bed | sort -u > {params.work_directory}/tmp_chrom_with_TE.txt
            grep -E `echo "{params.CHROM_KEEP}" | tr "," "|"` {input.genome}.fai | grep -w -f {params.work_directory}/tmp_chrom_with_TE.txt | awk 'BEGIN{{print "var chroms = {{"}} {{print "   \\""$1"\\" : "$2","}} END{{print "}}"}}'  > {params.work_directory}/js/chroms.js || fail_msg "ERROR : NO CHROM IN REPORT\\n"
            # grep -E `echo "{params.CHROM_KEEP}" | tr "," "|"` {input.genome}.fai | grep -w -f {params.work_directory}/tmp_chrom_with_TE.txt | awk 'BEGIN{{print "const all_data = {{"}} {{print "   \\""$1"\\" : data"$1","}} END{{print "}}"}}'   > {params.work_directory}/js/data_ALL_FREQ_CHROM.js || fail_msg "ERROR : NO TE FOR FREQUENCY IN REPORT\\n"
            path_fai=`realpath {input.genome}.fai`;

            echo "  BUILD group for scatter FREQUENCY js ..."

            ###GET SV TYPE
            grep OUTSIDER {params.work_directory}/TE_INFOS.bed | awk ' {{print $15}}' | sort -u | awk 'BEGIN{{chain="var typesSV = [";}} {{ if(NR==1){{chain=chain"\\""$1"\\""}}else{{chain=chain", \\""$1"\\""}} }} END{{chain=chain"]"; print chain; }}' > {params.work_directory}/js/groups_OUTSIDER.js || warn_msg "Warning : NO OUTSIDER IN REPORT\\n"
            grep INSIDER {params.work_directory}/TE_INFOS.bed | awk ' {{print $15}}' | sort -u | awk 'BEGIN{{chain="var typesSV = [";}} {{ if(NR==1){{chain=chain"\\""$1"\\""}}else{{chain=chain", \\""$1"\\""}} }} END{{chain=chain"]"; print chain; }}' > {params.work_directory}/js/groups_INSIDER.js || warn_msg "Warning : NO INSIDER IN REPORT\\n"
            #####INOUTSIDER
            awk 'NR>1 {{print $15}}' {params.work_directory}/TE_INFOS.bed | sort -u | awk 'BEGIN{{chain="var typesSV = [";}} {{ if(NR==1){{chain=chain"\\""$1"\\""}}else{{chain=chain", \\""$1"\\""}} }} END{{chain=chain"]"; print chain; }}' > {params.work_directory}/js/groups_INOUTSIDER.js || warn_msg "Warning : NO TE IN REPORT\\n"
            
            echo "  STRAND OUTSIDER"
            ## forward reverse OUTSIDER
            test -s {params.work_directory}/TE_INFOS.bed && test -s {params.work_directory}/POSITION_TE_OUTSIDER.bed && \
                grep OUTSIDER {params.work_directory}/TE_INFOS.bed | awk '{{
                    split($4, sp, "|"); 
                    
                    if($5 == "-"){{
                        dico["-"][sp[1]]+=1;
                        if(! dico["+"][sp[1]]){{
                            dico["+"][sp[1]] = 0;
                        }}
                    }}
                    else{{
                        dico["+"][sp[1]] += 1; 
                        if(! dico["-"][sp[1]]){{
                            dico["-"][sp[1]] = 0;
                        }}
                    }}
                }}

                END{{
                    chain = "var data = ["
                    for(TE in dico["-"]){{
                        chain = chain"\\n{{TEname: \\""TE"\\", reverse: -"dico["-"][TE]", forward: "dico["+"][TE]"}},"
                    }}
                    print substr(chain, 1, length(chain)-1)"\\n]";
                }}' > {params.work_directory}/REPORT/mini_report/js/TE_COUNT_SENS_ANTISENS_OUTSIDER.js
            
            sed 's/%%VAR_JS%%/TE_COUNT_SENS_ANTISENS_OUTSIDER.js/g' {params.work_directory}/REPORT/mini_report/lib/template_COUNT_TE_SENS_ANTISENS.html \
                 > {params.work_directory}/REPORT/mini_report/lib/template_COUNT_TE_SENS_ANTISENS_OUTSIDER.html


            echo "  STRAND INSIDER"
            ## STRAND INSIDER
            test -s {params.work_directory}/TE_INFOS.bed && test -s {params.work_directory}/POSITION_TE_INSIDER.bed && \
                grep INSIDER {params.work_directory}/TE_INFOS.bed | awk '{{
                    split($4, sp, "|"); 
                    
                    if($5 == "-"){{
                        dico["-"][sp[1]]+=1;
                        if(! dico["+"][sp[1]]){{
                            dico["+"][sp[1]] = 0;
                        }}
                    }}
                    else{{
                        dico["+"][sp[1]] += 1; 
                        if(! dico["-"][sp[1]]){{
                            dico["-"][sp[1]] = 0;
                        }}
                    }}
                }}

                END{{
                    chain = "var data = ["
                    for(TE in dico["-"]){{
                        chain = chain"\\n{{TEname: \\""TE"\\", reverse: -"dico["-"][TE]", forward: "dico["+"][TE]"}},"
                    }}
                    print substr(chain, 1, length(chain)-1)"\\n]";
                }}' > {params.work_directory}/REPORT/mini_report/js/TE_COUNT_SENS_ANTISENS_INSIDER.js
                

            sed 's/%%VAR_JS%%/TE_COUNT_SENS_ANTISENS_INSIDER.js/g' {params.work_directory}/REPORT/mini_report/lib/template_COUNT_TE_SENS_ANTISENS.html \
                 > {params.work_directory}/REPORT/mini_report/lib/template_COUNT_TE_SENS_ANTISENS_INSIDER.html

            
            echo "  STRAND INOUTSIDER"
            ## STRAND INOUTSIDER
            test -s {params.work_directory}/TE_INFOS.bed && \
                awk '{{
                    split($4, sp, "|"); 
                    
                    if($5 == "-"){{
                        dico["-"][sp[1]]+=1;
                        if(! dico["+"][sp[1]]){{
                            dico["+"][sp[1]] = 0;
                        }}
                    }}
                    else{{
                        dico["+"][sp[1]] += 1; 
                        if(! dico["-"][sp[1]]){{
                            dico["-"][sp[1]] = 0;
                        }}
                    }}
                }}

                END{{
                    chain = "var data = ["
                    for(TE in dico["-"]){{
                        chain = chain"\\n{{TEname: \\""TE"\\", reverse: -"dico["-"][TE]", forward: "dico["+"][TE]"}},"
                    }}
                    print substr(chain, 1, length(chain)-1)"\\n]";
                }}' {params.work_directory}/TE_INFOS.bed \
                     > {params.work_directory}/REPORT/mini_report/js/TE_COUNT_SENS_ANTISENS_INOUTSIDER.js

            sed 's/%%VAR_JS%%/TE_COUNT_SENS_ANTISENS_INOUTSIDER.js/g' {params.work_directory}/REPORT/mini_report/lib/template_COUNT_TE_SENS_ANTISENS.html \
                 > {params.work_directory}/REPORT/mini_report/lib/template_COUNT_TE_SENS_ANTISENS_INOUTSIDER.html


            cp {params.work_directory}/js/* {params.work_directory}/REPORT/mini_report/js/
            
            rm -fr {params.work_directory}/js


            ## CHANGE PATH
            old_path=`pwd`
            cd {params.work_directory}/REPORT/mini_report/

            #INSIDER
            ## TODO GESTION DE SUPPRESSION
            if [ {params.choice_insider_sv} != "True" ]; then
                rm -f insider.Rmd
            else
                ! test -s ../../INSIDER/FREQ_INSIDER/DEPTH_TE_INSIDER.csv && \
                   sed -i 's/r FREQIN, eval=TRUE,/r FREQIN, eval=FALSE,/g' insider.Rmd  && \
                   sed -i '/FREQUENCE/d' insider.Rmd
                cat insider.Rmd >> index.Rmd
                mv insider.Rmd insider.Rmd.tmp
            fi;

            #OUTSIDER
            ## TODO GESTION DE SUPPRESSION
            if [ {params.choice_outsider_sv} != "True" ]; then
                rm -f outsider.Rmd
            else
                cat outsider.Rmd >> index.Rmd
                mv outsider.Rmd outsider.Rmd.tmp
            fi;


            #INOUTSIDER
            ## TODO GESTION DE SUPPRESSION
            if [ {params.choice_outsider_sv} != "True" ] || [ {params.choice_insider_sv} != "True" ]; then
                rm -f inoutsider.Rmd
            else
                ! test -s ../../INSIDER/FREQ_INSIDER/DEPTH_TE_INSIDER.csv && \
                   sed -i 's/r FREQ_INOUT, eval=TRUE,/r FREQ_INOUT, eval=FALSE,/g' inoutsider.Rmd  && \
                   sed -i '/FREQUENCE/d' inoutsider.Rmd
                cat inoutsider.Rmd >> index.Rmd
                mv inoutsider.Rmd inoutsider.Rmd.tmp
            fi;

            #REMOVE OR COUNT INSIDER
            ## TODO GESTION DE SUPPRESSION
            if ! test -s ../../INSIDER/TE_DETECTION/INSERTION.csv ; then
                sed -i 's/r COUNT_TE_INSIDER_INSERTION, eval=TRUE,/r, eval=FALSE,/g' index.Rmd

                #DELET LINE USELESS
                sed -i '/TE_INSIDER_INS/d' index.Rmd
                sed -i '/TE_INSIDER.[a-z]/d' index.Rmd
            else
                #COUNT

                awk -F "\t" 'BEGIN{{print "name,value"}}NR>1{{print $2","$3}}' ../../INSIDER/TE_DETECTION/INSERTION_COUNT_TE.csv  > tmp.csv
                python3 ${{path_to_pipline}}/lib/python/graphs/conv_js_histo_grouped.py tmp.csv data > js/COUNT_TE_INSIDER.js


                test -s js/COUNT_TE_INSIDER.js && \
                    sed 's/%%VAR_JS%%/COUNT_TE_INSIDER.js/g' lib/template_COUNT_TE.html > lib/template_COUNT_TE_INSIDER.html;

                #FREQUENCE INSIDER
                test -s ../../INSIDER/FREQ_INSIDER/DEPTH_TE_INSIDER.csv && \
                    awk 'BEGIN{{print "name,value"}} NR>1 {{print $7","$6}}' ../../INSIDER/FREQ_INSIDER/DEPTH_TE_INSIDER.csv > tmp_freq.csv
                
                test -s tmp_freq.csv && \
                    python3 ${{path_to_pipline}}/lib/python/graphs/conv_js_histo_grouped.py tmp_freq.csv data_freq > js/FREQ_TE_INSIDER.js
                test -s ../../INSIDER/TE_DETECTION/INSERTION_COUNT_TE.csv && \
                    awk -F "\t" 'BEGIN{{chain="var order = ["}} NR>1 {{ if(NR!=2){{ chain=chain", \\""$2"\\""}}else{{chain=chain"\\""$2"\\""}} }} END{{print chain"]"}}' ../../INSIDER/TE_DETECTION/INSERTION_COUNT_TE.csv >> js/FREQ_TE_INSIDER.js


                #HERE
                test -s js/FREQ_TE_INSIDER.js && \
                    sed 's/%%VAR_JS%%/FREQ_TE_INSIDER.js/g' lib/template_FREQ_TE.html > lib/template_FREQ_TE_INSIDER.html;

                #TODO calcul FREQ

                bedtools sort -i ../../TE_INFOS.bed | grep INSIDER | awk -v IN_OUT="INSIDER" '
                    BEGIN{{print "chrom\tx\ty\tgroup\tname\ttype\tIN_OUT\tID"}} 
                    OFS="\t" {{
                        if($11 != "NONE" && $11 != "INSIDER"){{FREQ=$11}}else{{FREQ="NONE"}};  
                        if(FREQ!="NONE"){{ split($4, sp, "|"); split(sp[2], group, "."); print $1, $2, FREQ/100, $15, $1":"$2":"sp[1], $5, IN_OUT, $4}} 
                    }}' | tr "," "." > tmp_scatter.csv || (echo "ERROR: NO INSIDER FOR FREQUENCY FOUND")
                
                awk '
                    BEGIN{{
                        print "all_data = {{"
                        gen="";
                        name="";
                        chrom="";
                        id="";
                        type="";
                        IN_OUT="";
                    }} 

                    NR>1 {{
                        if( chrom != $1 ){{
                            if( chrom != "" ){{
                                print "\\"type\\": \\""type"\\",";
                                print "\\"id\\": \\""id"\\",";
                                print "\\"name\\": \\""name"\\"\\n}}],\\n\\n";
                            }}

                            chrom=$1;

                            print "\\""chrom"\\": [{{";
                            print "\\""$4"x\\": "$2",";
                            print "\\""$4"y\\": "$3",";
                            print "\\""$4"io\\": \\""$7"\\",";
                            gen=$4;
                            id=$5;
                            type=$6;
                            IN_OUT=$7;
                            split($5, sp, ":");
                            name=sp[3];
                        }}
                        else if( id != $5 ){{
                            print "\\"type\\": \\""type"\\",";
                            print "\\"id\\": \\""id"\\",";
                            print "\\"name\\": \\""name"\\"";
                            print "}}, {{\\n""\\""$4"x\\": "$2",";
                            print "\\""$4"y\\": "$3",";
                            print "\\""$4"io\\": \\""$7"\\",";
                            gen=$4;
                            id=$5;
                            type=$6;
                            IN_OUT=$7;
                            split($5, sp, ":");
                            name=sp[3];
                        }}
                        else {{
                            print "\\""$4"x\\": "$2",";
                            print "\\""$4"y\\": "$3",";
                            print "\\""$4"io\\": \\""$7"\\",";
                        }}
                    }}

                    END{{
                        print "\\"type\\": \\""type"\\",";
                        print "\\"id\\": \\""id"\\",";
                        print "\\"name\\": \\""name"\\"\\n}}]}};";
                    }}' tmp_scatter.csv > js/FREQ_TE_INSIDER_CHROM.js

                #rest chrom
                # awk 'NR>1 {{ print $1 }}' tmp_scatter.csv | sort -u > tmp_chrom.txt
                # grep -v -f tmp_chrom.txt ${{path_fai}} | cut -f 1 | awk '{{print "var data"$1" = []"}}' >> js/FREQ_TE_INSIDER_CHROM.js || echo ""

                test -s js/FREQ_TE_INSIDER_CHROM.js && \
                    sed 's/%%VAR_JS%%/FREQ_TE_INSIDER_CHROM.js/g' lib/template_FREQ_CHROM.html > lib/template_FREQ_CHROM_INSIDER.html

                test -s js/groups_INSIDER.js && \
                    sed -i 's/%%VAR_GROUP%%/groups_INSIDER.js/g' lib/template_FREQ_CHROM_INSIDER.html

                rm -f tmp.csv tmp_freq.csv
            fi;


            #REMOVE OR COUNT INSIDER DELETION
            ## TODO GESTION DE SUPPRESSION
            if ! test -s ../../INSIDER/TE_DETECTION/DELETION.csv ; then
                sed -i 's/r COUNT_TE_INSIDER_DELETION, eval=TRUE,/r, eval=FALSE,/g' index.Rmd
                
                #DELET LINE INUTILE
                sed -i '/TE_INSIDER_DEL/d' index.Rmd
            else
                awk -F "\t" 'BEGIN{{print "name,value"}}NR>1{{print $2","$3}}' ../../INSIDER/TE_DETECTION/DELETION_COUNT_TE.csv  > tmp.csv
                python3 ${{path_to_pipline}}/lib/python/graphs/conv_js_histo_grouped.py tmp.csv data > js/COUNT_TE_INSIDER_DEL.js
                rm -f tmp.csv
            fi;

            #REMOVE OR COUNT OUTSIDER
            ## TODO GESTION DE SUPPRESSION
            if ! test -s ../../OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv ; then
                sed -i 's/r NB_OUTSIDER, eval=TRUE,/r, eval=FALSE,/g' index.Rmd
                sed -i 's/r TSD, eval=TRUE,/r, eval=FALSE,/g' index.Rmd
                sed -i 's/r FREQ, eval=TRUE,/r, eval=FALSE,/g' index.Rmd

                sed -i '/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE/d' index.Rmd
            else
                #COUNT
                awk -F "\t" 'BEGIN{{print "name,value"}}NR>1{{print $2","$3}}' ../../OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL_COUNT.csv > tmp.csv
                python3 ${{path_to_pipline}}/lib/python/graphs/conv_js_histo_grouped.py tmp.csv data > js/COUNT_TE_OUTSIDER.js

                test -s js/COUNT_TE_OUTSIDER.js && \
                    sed 's/%%VAR_JS%%/COUNT_TE_OUTSIDER.js/g' lib/template_COUNT_TE.html > lib/template_COUNT_TE_OUTSIDER.html

                #FREQUENCE OUTSIDER
                test -s ../../TE_INFOS.bed && \
                    grep OUTSIDER ../../TE_INFOS.bed | awk '
                        BEGIN{{print "name,value"}} 
                        $12!="NONE" {{ split($4, TEID, "|"); print TEID[1]","$12 }}  
                        $12=="NONE" && $11!="NONE" {{ split($4, TEID, "|"); print TEID[1]","$11 }}
                        ' > tmp_freq.csv

                test -s tmp_freq.csv && \
                    python3 ${{path_to_pipline}}/lib/python/graphs/conv_js_histo_grouped.py tmp_freq.csv data_freq > js/FREQ_TE_OUTSIDER.js && \
                test -s ../../OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL_COUNT.csv && \
                    awk -F "\t" 'BEGIN{{chain="var order = ["}} NR>1 {{ if(NR!=2){{ chain=chain", \\""$2"\\""}}else{{chain=chain"\\""$2"\\""}} }} END{{print chain"]"}}' ../../OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL_COUNT.csv >> js/FREQ_TE_OUTSIDER.js

                test -s js/FREQ_TE_OUTSIDER.js && \
                    sed 's/%%VAR_JS%%/FREQ_TE_OUTSIDER.js/g' lib/template_FREQ_TE.html > lib/template_FREQ_TE_OUTSIDER.html

                
                #TODO calcul FREQ OUT

                 bedtools sort -i ../../TE_INFOS.bed | grep OUTSIDER | awk -v IN_OUT="OUTSIDER" '
                    BEGIN{{ print "chrom\tx\ty\tgroup\tname\ttype\tIN_OUT\tID" }} 
                    OFS="\t" {{ 
                        if($12 != "NONE"){{FREQ=$12}}else if($11 != "NONE"){{FREQ=$11}}else{{FREQ="NONE"}};  
                        if(FREQ!="NONE"){{ split($4, sp, "|"); split(sp[2], group, "."); print $1, $2, FREQ/100, $15, $1":"$2":"sp[1], $5, IN_OUT, $4}} 
                    }}' | tr "," "." > tmp_scatter.csv

                awk '
                    BEGIN{{
                        print "all_data = {{"
                        gen="";
                        name="";
                        chrom="";
                        id="";
                        type="";
                        IN_OUT="";
                    }} 

                    NR>1 {{
                        if( chrom != $1 ){{
                            if( chrom != "" ){{
                                print "\\"type\\": \\""type"\\",";
                                print "\\"id\\": \\""id"\\",";
                                print "\\"name\\": \\""name"\\"\\n}}],\\n\\n";
                            }}

                            chrom=$1;

                            print "\\""chrom"\\": [{{";
                            print "\\""$4"x\\": "$2",";
                            print "\\""$4"y\\": "$3",";
                            print "\\""$4"io\\": \\""$7"\\",";
                            gen=$4;
                            id=$5;
                            type=$6;
                            IN_OUT=$7;
                            split($5, sp, ":");
                            name=sp[3];
                        }}
                        else if( id != $5 ){{
                            print "\\"type\\": \\""type"\\",";
                            print "\\"id\\": \\""id"\\",";
                            print "\\"name\\": \\""name"\\"";
                            print "}}, {{\\n""\\""$4"x\\": "$2",";
                            print "\\""$4"y\\": "$3",";
                            print "\\""$4"io\\": \\""$7"\\",";
                            gen=$4;
                            id=$5;
                            type=$6;
                            IN_OUT=$7;
                            split($5, sp, ":");
                            name=sp[3];
                        }}
                        else {{
                            print "\\""$4"x\\": "$2",";
                            print "\\""$4"y\\": "$3",";
                            print "\\""$4"io\\": \\""$7"\\",";
                        }}
                    }}

                    END{{
                        print "\\"type\\": \\""type"\\",";
                        print "\\"id\\": \\""id"\\",";
                        print "\\"name\\": \\""name"\\"\\n}}]}};";
                    }}' tmp_scatter.csv > js/FREQ_TE_OUTSIDER_CHROM.js

                # cut -f 1 tmp_scatter.csv | sort -u > tmp_chrom.txt
                # grep -v -f tmp_chrom.txt ${{path_fai}} | cut -f 1 | awk '{{print "var data"$1" = []"}}' >> js/FREQ_TE_OUTSIDER_CHROM.js || echo ""
                test -s js/FREQ_TE_OUTSIDER_CHROM.js && \
                    sed 's/%%VAR_JS%%/FREQ_TE_OUTSIDER_CHROM.js/g' lib/template_FREQ_CHROM.html > lib/template_FREQ_CHROM_OUTSIDER.html

                test -s js/groups_OUTSIDER.js && \
                    sed -i 's/%%VAR_GROUP%%/groups_OUTSIDER.js/g' lib/template_FREQ_CHROM_OUTSIDER.html

                rm -f tmp.csv tmp_freq.csv tmp_scatter.csv

                rm -f tmp.csv
            fi;

            ## GET AUTHOR RANDOM
            #author=`(curl "localhost:4242/author" > tmp_author.txt && cat tmp_author.txt) || echo "<strong>Author<\/strong> : Maybe You ?"`
            author=`(curl https://author.infinity-atom.fr/author > tmp.txt && cat tmp.txt) || echo "<strong>Author<\/strong> : Maybe You ?"`
            
            if [ `echo $author | grep "404 Not Found" -c` -eq 1 ]; 
            then 
                sed -i "s/unknown/<strong>Author<\/strong> : Maybe You ?/g" index.Rmd
            else
                sed -i "s/unknown/$author/g" index.Rmd
            fi;

            #rm -f tmp_author.txt

            #REMOVE OR COUNT INOUTSIDER
            ## TODO GESTION DE SUPPRESSION
            if ! test -s ../../INSIDER/TE_DETECTION/INSERTION.csv || ! test -s ../../OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv; then
                echo "ERROR NO TE INSERTION FOUND";
            else
                test -s ../../TE_INFOS.bed && \
                    awk 'NR>1 {{split($4, sp, "|"); print sp[1]}}' ../../TE_INFOS.bed | sort | uniq -c | awk '{{print $1"\t"$2}}' | sort -k 1 -n | awk 'BEGIN{{print "x\ty\tz"}} OFS="\t"{{print "", $2, $1}}' > tmp_ALL_TE_COUNT.csv
                
                awk -F "\t" 'BEGIN{{print "name,value"}}NR>1{{print $2","$3}}' tmp_ALL_TE_COUNT.csv  > tmp.csv
                python3 ${{path_to_pipline}}/lib/python/graphs/conv_js_histo_grouped.py tmp.csv data > js/COUNT_TE_INOUTSIDER.js

                test -s js/COUNT_TE_INOUTSIDER.js && \
                    sed 's/%%VAR_JS%%/COUNT_TE_INOUTSIDER.js/g' lib/template_COUNT_TE.html > lib/template_COUNT_TE_INOUTSIDER.html

                #FREQUENCE INOUTSIDER
                #test -s ../../OUTSIDER/FREQUENCY/DEPTH_TE.csv && \
                #    awk 'BEGIN{{print "name,value"}} NR>1 {{print $7","$6}}' ../../OUTSIDER/FREQUENCY/DEPTH_TE.csv > tmp_freq.csv
                    
                #! test -s ../../OUTSIDER/FREQUENCY/DEPTH_TE.csv && test -s ../../OUTSIDER/TE_DETECTION/DEPTH_TE.csv && \
                #    awk 'BEGIN{{print "name,value"}} NR>1 {{print $7","$6}}' ../../OUTSIDER/TE_DETECTION/DEPTH_TE.csv > tmp_freq.csv
                
                #test -s ../../OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL_COUNT.csv && \
                #    awk -F "\t" 'BEGIN{{chain="var order = ["}} NR>1 {{ if(NR!=2){{ chain=chain", \\""$2"\\""}}else{{chain=chain"\\""$2"\\""}} }} END{{print chain"]"}}' ../../OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL_COUNT.csv >> js/FREQ_TE_OUTSIDER.js

                #test -s ../../INSIDER/FREQ_INSIDER/DEPTH_TE_INSIDER.csv && \
                #    awk 'NR>1 {{print $7","$6}}' ../../INSIDER/FREQ_INSIDER/DEPTH_TE_INSIDER.csv >> tmp_freq.csv

                #test -s tmp_freq.csv && \
                #    python3 ${{path_to_pipline}}/lib/python/graphs/conv_js_histo_grouped.py tmp_freq.csv data_freq > js/FREQ_TE_INOUTSIDER.js
                
                #test -s ../../INSIDER/TE_DETECTION/INSERTION_COUNT_TE.csv && \
                #    awk -F "\t" 'BEGIN{{chain="var order = ["}} NR>1 {{ if(NR!=2){{ chain=chain", \\""$2"\\""}}else{{chain=chain"\\""$2"\\""}} }} END{{print chain"]"}}' ../../INSIDER/TE_DETECTION/INSERTION_COUNT_TE.csv >> js/FREQ_TE_INOUTSIDER.js

                #test -s js/FREQ_TE_INOUTSIDER.js && \
                #    sed 's/%%VAR_JS%%/FREQ_TE_INOUTSIDER.js/g' lib/template_FREQ_TE.html > lib/template_FREQ_TE_INOUTSIDER.html;

                #TODO calcul FREQ INOUT
                bedtools sort -i ../../TE_INFOS.bed | awk -v IN_OUT="INOUTSIDER" '
                    BEGIN{{ print "chrom\tx\ty\tgroup\tname\ttype\tIN_OUT\tID" }} 
                    OFS="\t" {{ 
                        if($12 != "NONE"){{FREQ=$12}}else if($11 != "NONE"){{FREQ=$11}}else{{FREQ="NONE"}};  
                        if(FREQ!="NONE"){{ split($4, sp, "|"); split(sp[2], group, "."); print $1, $2, FREQ/100, $15, $1":"$2":"sp[1], $5, IN_OUT, $4}} 
                    }}' | tr "," "." > tmp_scatter.csv

                awk '
                    BEGIN{{
                        print "all_data = {{"
                        gen="";
                        name="";
                        chrom="";
                        id="";
                        type="";
                        IN_OUT="";
                    }} 

                    NR>1 {{
                        if( chrom != $1 ){{
                            if( chrom != "" ){{
                                print "\\"type\\": \\""type"\\",";
                                print "\\"id\\": \\""id"\\",";
                                print "\\"name\\": \\""name"\\"\\n}}],\\n\\n";
                            }}

                            chrom=$1;

                            print "\\""chrom"\\": [{{";
                            print "\\""$4"x\\": "$2",";
                            print "\\""$4"y\\": "$3",";
                            print "\\""$4"io\\": \\""$7"\\",";
                            gen=$4;
                            id=$5;
                            type=$6;
                            IN_OUT=$7;
                            split($5, sp, ":");
                            name=sp[3];
                        }}
                        else if( id != $5 ){{
                            print "\\"type\\": \\""type"\\",";
                            print "\\"id\\": \\""id"\\",";
                            print "\\"name\\": \\""name"\\"";
                            print "}}, {{\\n""\\""$4"x\\": "$2",";
                            print "\\""$4"y\\": "$3",";
                            print "\\""$4"io\\": \\""$7"\\",";
                            gen=$4;
                            id=$5;
                            type=$6;
                            IN_OUT=$7;
                            split($5, sp, ":");
                            name=sp[3];
                        }}
                        else {{
                            print "\\""$4"x\\": "$2",";
                            print "\\""$4"y\\": "$3",";
                            print "\\""$4"io\\": \\""$7"\\",";
                        }}
                    }}

                    END{{
                        print "\\"type\\": \\""type"\\",";
                        print "\\"id\\": \\""id"\\",";
                        print "\\"name\\": \\""name"\\"\\n}}]}};";
                    }}' tmp_scatter.csv > js/FREQ_TE_INOUTSIDER_CHROM.js

                cut -f 1 tmp_scatter.csv | sort -u > tmp_chrom.txt
                grep -v -f tmp_chrom.txt ${{path_fai}} | cut -f 1 | awk '{{print "var data"$1" = []"}}' >> js/FREQ_TE_INOUTSIDER_CHROM.js || echo ""
                test -s js/FREQ_TE_INOUTSIDER_CHROM.js && \
                    sed 's/%%VAR_JS%%/FREQ_TE_INOUTSIDER_CHROM.js/g' lib/template_FREQ_CHROM.html > lib/template_FREQ_CHROM_INOUTSIDER.html

                test -s js/groups_INOUTSIDER.js && \
                    sed -i 's/%%VAR_GROUP%%/groups_INOUTSIDER.js/g' lib/template_FREQ_CHROM_INOUTSIDER.html

                rm -f tmp.csv tmp_freq.csv tmp_scatter.csv
                rm -f tmp_ALL_TE_COUNT.csv
            fi;

            if ! test -e ../../VALUES_TSD_GROUP_OUTSIDER.csv; then
                sed -i 's/r TSD, eval=TRUE,/r, eval=FALSE,/g' index.Rmd
            fi;

            ## TIMELINE RULE ----------------------------------------------
            cat ../../log/Snakefile_*.err | grep "^rule" -B 2 | awk '
                BEGIN{{
                    chain=""
                }} 

                {{
                    if(substr($0, 1, 1) == "[" ){{ 
                        date=$0; 
                        rule="" 
                    }}else if(substr($0, 1, 4) == "rule"){{
                        split($0, sp, " "); 
                        rule=sp[2]; 
                        print date";"rule 
                    }} 
                }} ' > timeline.csv


            while read line; 
            do 

                date=`echo $line | cut -d ";" -f 1 | tr -d "[]"`; 
                rule=`echo $line | cut -d ";" -f 2 | tr -d ":"`;   
                datetime=`date -d "$date" +"%F %k:%M:%S"`; 
                echo "$datetime;$rule";  

            done < timeline.csv | awk -F ";" '
                BEGIN{{
                    start=""; 
                    end="";
                    print "data = [";
                }}
                {{
                    if( NR==1 ){{ 
                        start = $1; 
                        text=$2; 
                    }}
                    else{{
                        print "{{\\"category\\": \\""text"\\", \\"start\\": \\""start"\\", \\"end\\": \\""$1"\\", \\"text\\": \\""text"\\", color: colorSet.getIndex("(((NR * 4) % 16) + 1)")}},";
                        text=$2; 
                        start=$1;
                    }} 
                }}
                END{{
                    print "{{\\"category\\": \\""text"\\", \\"start\\": \\""start"\\", \\"end\\": \\""$1"\\", \\"text\\": \\""text"\\", color: colorSet.getIndex("((((NR+1) * 4) % 16) + 1)")}}\\n];";
                }} ' > js/data_timeline.js;


            #CHECKING R PACKAGES...
            echo "CHECKING R PACKAGES..."
            R --save -e 'if(!require(stringi)) install.packages("stringi")' >&2
            R --save -e 'if(!require(stringr)) install.packages("stringr")' >&2

            echo "MAKE REPORT"
            make

            cp -r ./lib ./js ./css ./web/

            path_to_report=`readlink -f ../report.html`

            printf "%s\\n" "{params.cmess} [SNK]--[`date`]--[INFO] CHECK $path_to_report [^-^] {params.cend}"

            cd $old_path
        fi;

        if [ {params.INTERMEDIATE_FILE} = "False" ]; then
            rm -fr {params.work_directory}/OUTSIDER
            rm -fr {params.work_directory}/INSIDER
            rm -f  {params.work_directory}/VALUES_TSD*
        fi;

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] BUILD REPORT DONE, CHECK {params.work_directory}/REPORT/report.html [^-^] {params.cend}"

        rm -f COMBINE_TE.csv
        rm -f {params.work_directory}/test.csv
        #rm -f {params.work_directory}/params.log;
        rm -fr {params.work_directory}/tmp* ;
        #rm -fr {params.work_directory}/INPUT
        """



#END REPORT






rule FIND_TE_ON_REF :
    input:
        ref         = config["DATA"]["REFERENCE"],
        genome_real = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_TOWARD_GENOME/PSEUDO_GENOME_TE_DB_ID.fasta",
        fasta_TE    = config["DATA"]["TE_DB"],
        all_te      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        sam         = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/INSIDER_VR/pm_against_ref.sam",
        delta       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/INSIDER_VR/pm_against_ref.sam.delta",
        bed         = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/INSIDER_VR/assemblytics_out.Assemblytics_structural_variants.bed",
        stats       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/INSIDER_VR/assemblytics_out.Assemblytics_assembly_stats.txt",
    output:
        output_link=[],
        
    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        call_sv        = config["CHOICE"]["OUTSIDER_VARIANT"]["CALL_SV"],

        env            = env, #source environnement

        pars_bln_option_insider = config["PARAMS"]["INSIDER_VARIANT"]["PARS_BLN_OPTION"],
        threads                 = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,


        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/FIND_TE_ON_REF",


    shell:
        #TODO broullion
        """

        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        rm -f `find {params.work_directory} -name "*.fai"`
        rm -f `find {params.work_directory} -name "*.fa*.fai"`

        samtools faidx {input.genome_real}
        samtools faidx {input.ref}
        samtools faidx {input.fasta_TE}

        rm -f {log}.*
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        
        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] ANNOT TE ON REF {params.cend}"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        {params.env}
        path_to_pipline=`dirname {params.path_snk}`
        
        rm -fr {params.work_directory}/INSIDER/TE_INSIDER_VR/*
        mkdir -p {params.work_directory}/INSIDER/TE_INSIDER_VR/

        #GETTING SEQUENCE FASTA INSERTION
        array_type=( "INSERTION" "Repeat_expansion" "Tandem_expansion" )
        for type in "${{array_type[@]}}"
        do
            echo "type=${{type}}";
            grep -i ${{type}} {input.bed} | awk '{{print $10":"$4}}' | awk -v type="${{type}}" -F ":" 'OFS="\t"{{split($2, a, "-"); print $1 , a[1], a[2], $4":"$3":"type}}' > {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bed || echo "[SNK  INFO]: ${{type}} NOT FOUND in bed file."
            test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bed || echo "[SNK  INFO]: ${{type}}.bed IS EMPTY"
            
            test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bed && \
                bedtools getfasta -fi {input.genome_real} -bed {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bed -name+ > {params.work_directory}/INSIDER/TE_INSIDER_VR/tmp_${{type}}_SEQ.fasta
            
            test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/tmp_${{type}}_SEQ.fasta || echo "[SNK  INFO]: tmp_${{type}}_SEQ.fasta IS EMPTY"
            
            #TODO warning get_seq_with_id.sh only svim
            ( test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/tmp_${{type}}_SEQ.fasta && \
                sh ${{path_to_pipline}}/lib/bash/get_seq_with_id.sh {params.work_directory}/INSIDER/TE_INSIDER_VR/tmp_${{type}}_SEQ.fasta {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta ) || echo "SEQUENCE $type NOT FOUND"
            
            #RENAME ID (ID_SV_ at on get_seq_with_id.sh)
            if [ {params.call_sv} = "svim" ]; then
                test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta && \
                    sed -i 's/ID_SV_/svim.INS./g' {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta
            else
                test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta && \
                    sed -i 's/ID_SV_//g' {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta
            fi;

            ( test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta && echo "NUMBER OF SEQUENCE" `grep ">" {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta -c ` ) || echo "[SNK  INFO]: ${{type}}_SEQ.fasta IS EMPTY"
            test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta && cat {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta >> {params.work_directory}/INSIDER/TE_INSIDER_VR/INSERTION_SEQ_ALL.fasta
        done;
        
        #cat {params.work_directory}/INSIDER/TE_INSIDER_VR/Tandem_expansion_SEQ.fasta {params.work_directory}/INSIDER/TE_INSIDER_VR/Repeat_expansion_SEQ.fasta {params.work_directory}/INSIDER/TE_INSIDER_VR/INSERTION_SEQ.fasta > {params.work_directory}/INSIDER/TE_INSIDER_VR/INSERTION_SEQ_ALL.fasta
        test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/INSERTION_SEQ_ALL.fasta && \
            cat {params.work_directory}/INSIDER/TE_INSIDER_VR/INSERTION_SEQ_ALL.fasta > {params.work_directory}/INSIDER/TE_INSIDER_VR/INSERTION_SEQ.fasta
        

        #GETTING SEQUENCE FASTA DELETION
        array_type_deletion=( "DELETION" "Repeat_contraction" "Tandem_contraction" );
        for type in "${{array_type_deletion[@]}}"
        do
            grep -i ${{type}}  {input.bed} | awk  -v type="$type" 'OFS="\t"{{print $1, $2, $3, $4":"$6":"type}}' > {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bed || echo "[SNK  INFO]: ${{type}} NOT FOUND in bed file."

            test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bed && \
                bedtools getfasta -fi {input.ref}  -bed {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bed -name+ > {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta

            test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta && cat {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta >> {params.work_directory}/INSIDER/TE_INSIDER_VR/DELETION_SEQ_ALL.fasta
        done;
        
        #cat {params.work_directory}/INSIDER/TE_INSIDER_VR/Tandem_contraction_SEQ.fasta {params.work_directory}/INSIDER/TE_INSIDER_VR/Repeat_contraction_SEQ.fasta {params.work_directory}/INSIDER/TE_INSIDER_VR/DELETION_SEQ.fasta > {params.work_directory}/INSIDER/TE_INSIDER_VR/DELETION_SEQ_ALL.fasta
        
        test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/DELETION_SEQ_ALL.fasta && \
            cat {params.work_directory}/INSIDER/TE_INSIDER_VR/DELETION_SEQ_ALL.fasta > {params.work_directory}/INSIDER/TE_INSIDER_VR/DELETION_SEQ.fasta

        #GETTING CSV TE
        array_type=( "INSERTION" "Repeat_expansion" "Tandem_expansion" "DELETION" "Repeat_contraction" "Tandem_contraction" )
        for type in "${{array_type[@]}}"
        do
            echo -e "\nTYPE : $type";

            if test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta; then
                
                awk 'BEGIN{{header="";}}{{if(substr($0, 1, 1) == ">"){{header=$0;}}else if(length($0)>30){{print header"\\n"$0}}}}' {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta > {params.work_directory}/INSIDER/TE_INSIDER_VR/tmp.fasta
                
                cat {params.work_directory}/INSIDER/TE_INSIDER_VR/tmp.fasta > {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta

                makeblastdb -in {input.fasta_TE} -dbtype nucl  2> {log}.err 1> {log}.out;

                blastn -num_threads {params.threads} -db {input.fasta_TE} \
                -query {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta \
                -outfmt 6 \
                -out {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bln 2> {log}.err 1> {log}.out;

                number_lines_bln=`cat {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bln | wc -l`
                if [ "$number_lines_bln" -gt 500000  ]; then
                    awk 'BEGIN{{qseqid=""; sseqid=""}}{{if(qseqid!=$1){{qseqid=$1; sseqid=$2; print $0;}}else if(sseqid==$2){{print $0}}}}' {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bln \
                        > {params.work_directory}/INSIDER/TE_INSIDER_VR/tmp_pre_filtre.bln

                    test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bln && \
                        python3 ${{path_to_pipline}}/lib/python/parsing/global_sv_id.py {params.pars_bln_option_insider} \
                             --combine_name {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_COMBINE_TE.csv \
                            {params.work_directory}/INSIDER/TE_INSIDER_VR/tmp_pre_filtre.bln \
                            {input.fasta_TE} \
                            {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.csv 
                else

                    test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bln && \
                        python3 ${{path_to_pipline}}/lib/python/parsing/global_sv_id.py {params.pars_bln_option_insider} \
                             --combine_name {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_COMBINE_TE.csv \
                            {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bln \
                            {input.fasta_TE} \
                            {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.csv 
                fi;
                

                test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.csv && \
                awk 'NR>1{{print $1}}' {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.csv | sort | uniq -c | sort -k 1 -n | \
                    awk 'BEGIN{{print "x\ty\tz"}} OFS="\t"{{print "", $2, $1}}' > {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_COUNT_TE.csv

            fi;
        done;

        rm -f {params.work_directory}/INSIDER/TE_INSIDER_VR/tmp_*

        REF=`realpath -s {input.ref}`
        QUERY=`realpath -s {input.genome_real}`
        TREMOLO_PATH=`readlink -f ${{path_to_pipline}}`

        echo "REF :$REF"
        echo "QUERY :$QUERY"
        #echo "TREMOLO_PATH :$TREMOLO_PATH"

        #### CD
        ## CHANGE DIRECTORY
        path_work=`realpath {params.work_directory}`
        old_path=`dirname $path_work`
        cd {params.work_directory}/INSIDER/TE_INSIDER_VR/



        if test -s INSERTION.csv; then

            awk '{{print $2}}' INSERTION.csv | cut -d ":" -f 1 > ID_asm.txt
            grep -w -f ID_asm.txt ../../OUTSIDER/INSIDER_VR/assemblytics_out.Assemblytics_structural_variants.bed | awk 'OFS="\t"{{print $1, $2, $3, $4"|"$7}}' > TE_FOUND.bed

            grep -v "INSERTION" INSERTION.csv | awk -v size="4000" 'NR>1 && OFS="\t"{{split($2, a, ":"); 
                split(a[6], b, "-"); 
                if(b[1]-size > 0){{ print a[5] , b[1]-size, b[1], a[1]":LEFT\\n" a[5], b[2], b[2]+size, a[1]":RIGTH" }} else{{ print a[5] , b[1], b[1]+1, a[1]":LEFT\\n" a[5], b[2], b[2]+size, a[1]":RIGTH" }}
            }}' > tmp_Repeat_expension.bed

            echo "TE GENOME FLANKING TO REFERENCE...";
            bedtools getfasta -fi $QUERY -bed tmp_Repeat_expension.bed -name+ > tmp_Repeat_expension.fasta

            makeblastdb -in $REF -dbtype nucl
            blastn -num_threads {params.threads} -db $REF \
            -query tmp_Repeat_expension.fasta \
            -outfmt 6 \
            -out position_Repeat_expension.bln



            rm -f pos_TE_expension.bed pos_TE_insertion.bed pos_TE_insertion.csv

            if test -s position_Repeat_expension.bln ; then
                awk '{{if(!dic[$1]){{dic[$1]=$1; print $0 }} }}' position_Repeat_expension.bln | awk '$3>80 && $4>1500' > position_Repeat_expension_best_score.csv

                python3 $TREMOLO_PATH/lib/python/parsing/global_position_expansion.py position_Repeat_expension_best_score.csv position_Repeat_expension_best_score_size_pos.csv

                test -s position_Repeat_expension_best_score_size_pos.csv && \
                    cat position_Repeat_expension_best_score_size_pos.csv | cut -f 3 | awk -F ":" 'NR>1 {{print $1}} ' > ID.txt || echo "NO TE EXPENSION FOUND"

                awk 'OFS="\t"{{ split($4, a, "|"); print $0, a[1], a[2] }}' TE_FOUND.bed > TE_FOUND.csv

                test -s position_Repeat_expension_best_score_size_pos.csv && \
                    awk 'NR>1 && OFS="\t"{{split($3, a, ":"); print $0, a[1], a[2]":"a[3]}}' position_Repeat_expension_best_score_size_pos.csv > pos_expension.csv

                ## sort le fichier pos_TE_expension.csv
                test -s pos_expension.csv && \
                    python3 $TREMOLO_PATH/lib/python/parsing/global_position_all.py TE_FOUND.csv INSERTION.csv pos_expension.csv pos_TE_expension.csv

                test -s pos_TE_expension.csv && \
                    awk 'NR>1 && OFS="\t" {{print $1, $2, $2+1, $7}}'  pos_TE_expension.csv > pos_TE_expension.bed
            fi;

            
            rm -f POS_ALT_TE_OUTSIDER_ON_REF.bed
            if test -s TE_FOUND.bed; then

                for ID in `cat TE_FOUND.bed | cut -f 4 | cut -d "|" -f 1`; do 

                    TE=`grep -w "$ID" INSERTION.csv | cut -f 1`; 
                    line=`grep -w "$ID" TE_FOUND.bed | cut -f 1-3`;
                    ID_OUTSIDER=`grep -w "$ID" INSERTION.csv | cut -f 2 | cut -d ":" -f 7` #ID svim, or sniffles

                    ID_OUTSIDER_T=`(awk 'NR>1' ../../OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv | cut -f 2 | cut -d ":" -f 5 | grep -w "$ID_OUTSIDER") || echo ""`;

                    if [ -n "$TE" ] && [ -n "$ID_OUTSIDER_T" ] ; then
                        echo -e "$line\t$TE|$ID|$ID_OUTSIDER_T" >> POS_ALT_TE_OUTSIDER_ON_REF.bed;
                    fi;
                done;
            fi;
        fi;

        test -s pos_TE_insertion.csv && awk 'NR>1 && OFS="\t"{{ print $17, $18, $18+1, $19 }}' pos_TE_insertion.csv > pos_TE_insertion.bed
        ##POSTITION START PAR ASSEMBLITICS
        test -s pos_TE_expension.bed && cat pos_TE_expension.bed > $path_work/POS_TE_OUTSIDER_ON_REF.bed
        test -s pos_TE_insertion.bed && cat pos_TE_insertion.bed >> $path_work/POS_TE_OUTSIDER_ON_REF.bed
        ##POSITION ENTIEREMENT FOURNI PAR ASSEMBLITICS
        test -s POS_ALT_TE_OUTSIDER_ON_REF.bed && ln -f -s -r POS_ALT_TE_OUTSIDER_ON_REF.bed $path_work/

        rm -f ID*.txt

        rm -f pos_*
        rm -f Repeat*
        rm -f Tandem*
        rm -f *SEQ_ALL.fasta
        rm -f tmp*

        cd "$old_path";

        test -s POS_TE_*_ON_REF.bed && cat {params.work_directory}/POS_TE_*_ON_REF.bed > {params.work_directory}/POSITION_TE_ON_REF.bed

        rm -f {params.work_directory}/ID.txt
        
        
        """


#END FIND_TE_ON_REF



rule FIND_SV_ON_REF :
    input:
        ref         = config["DATA"]["REFERENCE"],
        genome_real = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_TOWARD_GENOME/PSEUDO_GENOME_TE_DB_ID.fasta",
        fasta_TE    = config["DATA"]["TE_DB"],
        all_te      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        input_link=[],
    output:
        output_link=[],
        sam   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/INSIDER_VR/pm_against_ref.sam",
        delta = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/INSIDER_VR/pm_against_ref.sam.delta",
        bed   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/INSIDER_VR/assemblytics_out.Assemblytics_structural_variants.bed",
        stats = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/INSIDER_VR/assemblytics_out.Assemblytics_assembly_stats.txt",
        

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement
        threads        = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,

        preset         = config["PARAMS"]["INSIDER_VARIANT"]["MINIMAP2"]["PRESET_OPTION"] if config["PARAMS"]["INSIDER_VARIANT"]["MINIMAP2"]["PRESET_OPTION"] != "" else "asm5",
        option         = re.sub("-t [0-9]+", "", config["PARAMS"]["INSIDER_VARIANT"]["MINIMAP2"]["OPTION"]) + " -t " + str(config["PARAMS"]["THREADS"]),

        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

        step=0,

    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/FIND_TE_ON_REF",


    shell:
        #TODO broullion
        """

        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        rm -f {log}.*
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] FIND SV ON REF {params.cend}"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        mkdir -p {params.work_directory}/OUTSIDER/INSIDER_VR/
        mkdir -p {params.work_directory}/log/

        path_to_pipline=`dirname {params.path_snk}`

        minimap2 -ax {params.preset} {params.option} -t {params.threads} {input.ref} {input.genome_real} > {output.sam} 2> {params.work_directory}/log/pm_contigs_against_ref.sam.log

        python3 ${{path_to_pipline}}/lib/python/assemblitics/sam2delta.py {output.sam} || fail_msg "ERROR : SAM TO DELTA ✘\\n" | tee -a {log}.err;
        

        python3 ${{path_to_pipline}}/lib/python/assemblitics/Assemblytics_uniq_anchor.py \
            --delta {output.delta} \
            --unique-length 20000 \
            --out {params.work_directory}/OUTSIDER/INSIDER_VR/assemblytics_out \
            --keep-small-uniques || fail_msg "ERROR : Assemblytics_uniq_anchor.py ✘\\n" | tee -a {log}.err;


        perl ${{path_to_pipline}}/lib/perl/Assemblytics_between_alignments.pl \
            {params.work_directory}/OUTSIDER/INSIDER_VR/assemblytics_out.coords.tab \
            50 \
            20000 \
            all-chromosomes \
            exclude-longrange \
            bed > {params.work_directory}/OUTSIDER/INSIDER_VR/assemblytics_out.variants_between_alignments.bed || \
                fail_msg "ERROR : Assemblytics_between_alignments.pl ✘\\n" | tee -a {log}.err;


        python3 ${{path_to_pipline}}/lib/python/assemblitics/Assemblytics_within_alignment.py \
            --delta {params.work_directory}/OUTSIDER/INSIDER_VR/assemblytics_out.Assemblytics.unique_length_filtered_l20000.delta \
            --min 50 > {params.work_directory}/OUTSIDER/INSIDER_VR/assemblytics_out.variants_within_alignments.bed || \
                fail_msg "ERROR : Assemblytics_within_alignment.py ✘\\n" | tee -a {log}.err;


        test -s {params.work_directory}/OUTSIDER/INSIDER_VR/assemblytics_out.variants_between_alignments.bed && \
            cat {params.work_directory}/OUTSIDER/INSIDER_VR/assemblytics_out.variants_between_alignments.bed > {output.bed}

        test -s {params.work_directory}/OUTSIDER/INSIDER_VR/assemblytics_out.variants_within_alignments.bed && \
            cat {params.work_directory}/OUTSIDER/INSIDER_VR/assemblytics_out.variants_within_alignments.bed >> {output.bed}
        

        path_ref=`readlink -f {input.ref}`
        path_genome=`readlink -f {input.genome_real}`
        
        old_path=`pwd`
        
        cd {params.work_directory}/OUTSIDER/INSIDER_VR/
            python3 ${{path_to_pipline}}/lib/python/assemblitics/filter_gap_SVs.py ${{path_ref}} ${{path_genome}} || \
                fail_msg "ERROR : filter_gap_SVs.py ✘\\n" | tee -a {log}.err;
        cd ${{old_path}}

        name_ref=`basename {input.ref}`
        name_query=`basename {input.genome_real}`

        printf "%s\\n" "{params.cmess} [SNK]--[`date`]--[INFO] REFERENCE : $name_ref {params.cend}"
        printf "%s\\n\\n" "{params.cmess} [SNK]--[`date`]--[INFO] PSEUDO GENOME : $name_query {params.cend}"

        sed -i "s/file1/${{name_ref}}/g" {output.stats}
        sed -i "s/file2/${{name_query}}/g" {output.stats}

        """

#END FIND_SV_ON_REF


rule LIFT_OFF :
    input:
        ref         = config["DATA"]["REFERENCE"],
        genome      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_TOWARD_GENOME/PSEUDO_GENOME_TE_DB_ID.fasta",
        bed         = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE_PSEUDO.bed",
        input_link=[],
    output:
        output_link=[],

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement
        threads        = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,


        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

        step=0,

    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/LIFT_OFF",


    shell:
        #TODO broullion
        """

        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        rm -f {log}.*
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] LIFT_OFF {params.cend}"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        mkdir -p {params.work_directory}/OUTSIDER/INSIDER_VR/
        mkdir -p {params.work_directory}/log/

        path_to_pipline=`dirname {params.path_snk}`

        awk -v size="100000"  'OFS="\t" {{ 
                split($4, sp, ":"); 
                print $1, "Liftoff", "repeat_element", $2-size, $2, ".", "+", ".", "ID="sp[2]"; NAME="sp[1]"; SIDE=L"; 
                print $1, "Liftoff", "repeat_element", $3, $3+size, ".", "+", ".", "ID="sp[2]"; NAME="sp[1]"; SIDE=R";
            }}' {input.bed} | grep -E "sniffles.INS.[0-9]+|TrEMOLO.INS.[0-9]+" > {params.work_directory}/OUTSIDER/INSIDER_VR/INOUTSIDER.gff

        echo "repeat_element" > {params.work_directory}/OUTSIDER/INSIDER_VR/feature.txt

        liftoff -p {params.threads} -g {params.work_directory}/OUTSIDER/INSIDER_VR/INOUTSIDER.gff \
            -f {params.work_directory}/OUTSIDER/INSIDER_VR/feature.txt \
            -o {params.work_directory}/OUTSIDER/INSIDER_VR/output_INOUT.gff3 \
            {input.ref} \
            {input.genome} 2>> {log}.err

        ##Warning sniffles
        grep "SIDE=R" {params.work_directory}/OUTSIDER/INSIDER_VR/output_INOUT.gff3 | grep -E "sniffles.INS.[0-9]+|TrEMOLO.INS.[0-9]+" -o | sort -u > {params.work_directory}/OUTSIDER/INSIDER_VR/ID_FK_TE.txt

        rm -f {params.work_directory}/OUTSIDER/INSIDER_VR/POS_TE_LIFT.bed {params.work_directory}/OUTSIDER/INSIDER_VR/BAD_POS_TE_LIFT.bed;
        for id in `cat {params.work_directory}/OUTSIDER/INSIDER_VR/ID_FK_TE.txt`; 
        do
            #echo "deb... $id"
            chrom=`grep -w "$id" {params.work_directory}/OUTSIDER/INSIDER_VR/output_INOUT.gff3 | grep "SIDE=R" | cut -f 1 || echo ""`
            pos_end_L=`grep -w "$id" {params.work_directory}/OUTSIDER/INSIDER_VR/output_INOUT.gff3 | grep "SIDE=L" | cut -f 5 || echo ""`
            pos_start_R=`grep -w "$id" {params.work_directory}/OUTSIDER/INSIDER_VR/output_INOUT.gff3 | grep "SIDE=R" | cut -f 4 || echo ""`
            NAME=`grep -w "$id" {params.work_directory}/OUTSIDER/INSIDER_VR/output_INOUT.gff3 | grep "SIDE=R" | grep -E "NAME=[^;]+" -o | cut -d "=" -f 2 || echo ""`
            chromL=`grep -w "$id" {params.work_directory}/OUTSIDER/INSIDER_VR/output_INOUT.gff3 | grep "SIDE=L" | cut -f 1 || echo ""`
            
            #echo "deb : $chrom; $NAME; $chromL;"
            #echo "$id"
            
            coverageL=`grep -w "$id" {params.work_directory}/OUTSIDER/INSIDER_VR/output_INOUT.gff3 | grep "SIDE=L" | grep -E "coverage=[0-9\.]+" -o | cut -d "=" -f 2 | tr "." "," || echo ""`
            coverageR=`grep -w "$id" {params.work_directory}/OUTSIDER/INSIDER_VR/output_INOUT.gff3 | grep "SIDE=R" | grep -E "coverage=[0-9\.]+" -o | cut -d "=" -f 2 | tr "." "," || echo ""`

            best_coverage=`echo "" | awk -v coverageR="$coverageR" -v coverageL="$coverageL" '{{ if(coverageL >= coverageR){{ print "L" }}else{{ print "R" }} }}' || echo ""`
            if [ -n "$chromL" ] 
            then
                #echo "coverage : $coverageL-$coverageR  ==  $best_coverage"
                if [ "$chromL" = "$chrom" ]
                then
                    #echo "c=cl; $pos_start_R; $pos_end_L";
                    DIFF_SIZE=$(($pos_start_R-$pos_end_L));

                    if [ $DIFF_SIZE -ge 0 ] && [ $DIFF_SIZE -le 20000 ]
                    then
                        #echo "NAME=$NAME; ID=$id; FREQ=$FREQ; chrom=$chrom:$pos_end_L-$pos_start_R";
                        echo -e "$chrom\t$pos_end_L\t$pos_start_R\t$NAME|$id\t$DIFF_SIZE\tINSIDER" >> {params.work_directory}/OUTSIDER/INSIDER_VR/POS_TE_LIFT.bed;
                    elif [ $DIFF_SIZE -lt 0 ] && [ $DIFF_SIZE -ge -20000 ]; then
                        #echo "NAME=$NAME; ID=$id; FREQ=$FREQ; chrom=$chrom:$pos_end_L-$pos_start_R";
                        echo -e "$chrom\t$pos_start_R\t$pos_end_L\t$NAME|$id\t$DIFF_SIZE\tINSIDER" >> {params.work_directory}/OUTSIDER/INSIDER_VR/POS_TE_LIFT.bed;
                    else
                        #echo "NAME=$NAME; ID=$id; FREQ=$FREQ; chrom=$chrom:$pos_end_L-$pos_start_R";
                        echo -e "$chrom:$pos_start_R\t$chromL:$pos_end_L\t$pos_end_L\t$NAME|$id\t$DIFF_SIZE\tINSIDER" >> {params.work_directory}/OUTSIDER/INSIDER_VR/BAD_POS_TE_LIFT.bed;
                    fi;

                else
                    #echo "c!=cl"
                    if [ "$best_coverage" = "L" ]; then
                        echo -e "$chrom\t$pos_end_L\t$(($pos_end_L+1))\t$NAME|$id\t$DIFF_SIZE\tINSIDER" >> {params.work_directory}/OUTSIDER/INSIDER_VR/POS_TE_LIFT.bed;
                    else
                        echo -e "$chrom\t$pos_start_R\t$(($pos_start_R+1))\t$NAME|$id\t$DIFF_SIZE\tINSIDER" >> {params.work_directory}/OUTSIDER/INSIDER_VR/POS_TE_LIFT.bed;
                    fi;

                    #echo "NAME=$NAME; ID=$id; FREQ=$FREQ; chrom=$chrom:$pos_end_L-$pos_start_R";
                    echo -e "$chrom:$pos_start_R\t$chromL:$pos_end_L\t$pos_end_L\t$NAME|$id\t$DIFF_SIZE\tINSIDER\t$best_coverage" >> {params.work_directory}/OUTSIDER/INSIDER_VR/BAD_POS_TE_LIFT.bed;
                fi;
            fi;

            #echo "ID:$id";
        done;

        test -s {params.work_directory}/OUTSIDER/INSIDER_VR/POS_TE_LIFT.bed && cut -f -4 {params.work_directory}/OUTSIDER/INSIDER_VR/POS_TE_LIFT.bed > {params.work_directory}/POS_TE_OUTSIDER_ON_REF.bed
        test -s {params.work_directory}/POS_TE_OUTSIDER_ON_REF.bed && cat {params.work_directory}/POS_TE_*_ON_REF.bed > {params.work_directory}/POSITION_TE_ON_REF.bed
        """

#END LIFT_OFF



rule TE_TOWARD_GENOME :
    input:
        input_link=[],
        fasta_TE     = config["DATA"]["TE_DB"],
        genome       = config["DATA"]["GENOME"],
        all_te       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        snif_seqs    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/VARIANT_CALLING/SEQUENCE_INDEL.fasta",
        
    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_TOWARD_GENOME/PSEUDO_GENOME_TE_DB_ID.fasta",
        #config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_TOWARD_GENOME/NEO_GENOME.fasta",
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE_PSEUDO.bed",
        output_link=[],

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        #FOR DETECTION ON ASM
        choice_insider_sv   = config["CHOICE"]["PIPELINE"]["INSIDER_VARIANT"],

        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/TE_TOWARD_GENOME",


    shell:
        """

        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] PUT TE OUTSIDER ON GENOME... {params.cend}"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        mkdir -p {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/
        rm -f {log}*
        rm -f {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/PSEUDO_GENOME_TE_DB_ID.fasta.fai

        echo "[`date`] LOG TASK {log}.out, {log}.err"

        echo "REFORMAT FASTA GENOME FOR TE INTEGRATION..."
        python3 ${{path_to_pipline}}/lib/python/format_files/fasta_to_fasta.py {input.genome} > {params.work_directory}/tmp_genome_format.fasta

        ##CHECK_FT_GENOME
        echo "CHECK FORMAT GENOME..." | tee -a {log}.out {log}.err
        awk 'BEGIN{{h_s="H"; is_fasta="True"}} 
            {{
                if( h_s == "H" && $0!="" ){{ 
                    if(substr($0, 1, 1) != ">"){{
                        is_fasta="NO_HEADER"; 
                        print $0; 
                        exit 0;
                    }}; 
                    h_s="S";
                }}
                else if(h_s == "S" && $0 != ""){{ 
                    if(! match($0, /^[ACGTURYKMSWBDHVNacgturykmswbdhvn-]*$/)){{
                        is_fasta="NO_NT";
                        print $0;
                        exit 0
                    }}; 
                        h_s = "H"; 
                }}  
            }} 

            END{{print is_fasta}}' {params.work_directory}/tmp_genome_format.fasta > {params.work_directory}/.tmp_check_ft_genome.txt;

        cat {params.work_directory}/.tmp_check_ft_genome.txt >> {log}.err

        [[ "`tail -n 1 {params.work_directory}/.tmp_check_ft_genome.txt`" != "True" ]] && fail_msg "ERROR : BAD FORMAT FASTA GENOME FOR INTEGRATION TE ✘\\n" && exit 6

        echo "CHECK FORMAT GENOME ✔" | tee -a {log}.out;

        #create index genome
        samtools faidx {params.work_directory}/tmp_genome_format.fasta

        ( test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed && \
            cut -f 4 {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed | cut -d "|" -f 2 > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/ID.txt && \
                echo "GET ID TE MERGE ✔" | tee -a {log}.out ) || fail_msg "ERROR : GET ID TE MERGE ✘\\n" | tee -a {log}.err

        rm -f {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_DB_TE.fasta && \
            touch {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_DB_TE.fasta

        #SEQ INDEL to Cannonical SEQ
        ( test -s {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/ID.txt && \
            for ID_TE in `cat "{params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/ID.txt"`; do
                IS_CLIPPED=`echo $ID_TE | grep -E -o "SOFT|HARD" || echo ""`

                if ! test -n "$IS_CLIPPED"; then
                    #seq_old=`( grep -w "$ID_TE" {input.snif_seqs} -A 1 || grep -w "$ID_TE" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.fasta ) | grep -v ">"`
                    
                    tmp_info_var=`( grep -w "$ID_TE" {input.all_te} || grep -w "$ID_TE" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv ) || echo ""`
                    
                    if test -n "$tmp_info_var";
                    then
                        TE=`( grep -w "$ID_TE" {input.all_te} || grep -w "$ID_TE" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv ) | cut -f 1`
                        strand=`( grep -w "$ID_TE" {input.all_te} || grep -w "$ID_TE" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv ) | grep ":[-+]" -o | tr -d ":"`
                        ID_CSV=`( grep -w "$ID_TE" {input.all_te} || grep -w "$ID_TE" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv ) | cut -f 2`

                        if [[ $strand = "+" ]]; then
                            seq_TE_cannonical=`grep -w "${{TE}}$" {input.fasta_TE} -A 1 | grep -v ">" | tr "atgcn" "ATGCN"`
                        else
                            seq_TE_cannonical=`grep -w "${{TE}}$" {input.fasta_TE} -A 1 | grep -v ">" | tr "ATGCatgcn" "TACGTACGN" | rev`
                        fi
                        
                        #echo "ID_TE:$ID_TE; TE:$TE; ID_CSV:$ID_CSV";
                        echo ">$ID_CSV" >> {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_DB_TE.fasta

                        #WARNING SEQ WITH NUMBER
                        echo "${{ID_TE}}$seq_TE_cannonical" >> {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_DB_TE.fasta
                    fi;
                fi;
            done && \
                echo "SEQ INDEL to Cannonical SEQ ✔" | tee -a {log}.out ) || fail_msg "ERROR : SEQ INDEL to Cannonical SEQ FAIL ✘\\n" | tee -a {log}.err;

        #************************
        ##INTEGRATION SEQUENCE DB
        ( test -s {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_DB_TE.fasta && \
            awk 'BEGIN{{start=0; header=0;}} OFS="\t"{{if(substr($0, 1, 1) == ">"){{split($0, sp, ":"); header=$0; start=sp[3];}}else{{print header, start, start+length($0)}} }}' \
                {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_DB_TE.fasta | sed 's/^>//g' > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL.bed && \
                    echo "INTEGRATION SEQUENCE DB ✔" | tee -a {log}.out ) || fail_msg "ERROR : INTEGRATION SEQUENCE DB ✘\\n" | tee -a {log}.err;
        

        ( test -s {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/ID.txt && \
            grep -w -f {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/ID.txt {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_DB_TE.fasta -A 1 | grep -v "^\-\-" \
                > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE.fasta ) || \
                    echo "ERROR : CONVERT FASTA SEQUENCE_INDEL_DB_TE.fasta to SEQUENCE_INDEL_as_TE.fasta ✘" >> {log}.err;

        #FOR DB SEQUENCE TO ANALYSIS REF
        ( test -s {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/ID.txt && \
            grep -f {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/ID.txt {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL.bed \
                > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE.bed ) || \
                    echo "ERROR : CONVERT BED SEQUENCE_INDEL.bed to SEQUENCE_INDEL_as_TE.bed ✘" >> {log}.err;

        #BED TO FORMAT bed for script vr_to_genome
        ( ( test -s {input.all_te} || test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv ) && \
            while read l; do 
                to_find=`echo $l | cut -d " " -f 1`; 
                chrom=`echo $l | cut -d ":" -f 1`;
                start=`echo $l | cut -d " " -f 2`; 
                end=`echo $l | cut -d " " -f 3`; 
                ID=`echo $l | cut -f 1 | cut -d":" -f 5`;

                TE=`( grep -w "$to_find" {input.all_te} || grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv ) | cut -f 1 || echo "NONE"` ;

                if [ "$TE" != "NONE" ]; then
                    echo "$chrom $start $end $TE:$ID"; 
                fi;

            done < {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE.bed | tr " " "\t" > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_TE.bed ) || \
                echo "ERROR : CONVERT BED SEQUENCE_INDEL.bed to SEQUENCE_INDEL_as_TE.bed ✘" >> {log}.err;
        

        echo "CHECK POSITION..."
        NB_POS_BAD=`awk '$3<=$2' {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_TE.bed | wc -l`
        if [ $NB_POS_BAD -eq 0 ]; then
            echo "   CHECK POSITION  ✔";
        else
            echo "   ERROR : BAD POSITION FOUND ERROR ✘";
        fi;


        echo "INTEGRATE TE DB_ID TO GENOME..."

        SIZE_TO_ADD=`awk '/^[^>]/ {{size+=length($0)}} END{{print size}}' {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE.fasta`;
        echo "   SIZE TO ADD : $SIZE_TO_ADD";

        ## INTEGRATE TE TO GENOME
        python3 ${{path_to_pipline}}/lib/python/vr_to_genome.py \
            -ob {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE_PSEUDO.bed \
            -og {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/PSEUDO_GENOME_TE_DB_ID.fasta \
            {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_TE.bed \
            {params.work_directory}/tmp_genome_format.fasta \
            {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE.fasta 2>> {log}.err


        SIZE_GENOME_BEFOR=`awk '{{s+=$2}} END{{print s}}' {params.work_directory}/tmp_genome_format.fasta.fai`;
        samtools faidx {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/PSEUDO_GENOME_TE_DB_ID.fasta;
        SIZE_GENOME_AFTER=`awk '{{s+=$2}} END{{print s}}' {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/PSEUDO_GENOME_TE_DB_ID.fasta.fai`;

        echo "   SIZE GENOME BEFORE INTEGRATION : $SIZE_GENOME_BEFOR";
        echo "   SIZE GENOME AFTER INTEGRATION  : $SIZE_GENOME_AFTER";
        echo "   SIZE ADDED : $((SIZE_GENOME_AFTER-SIZE_GENOME_BEFOR))";



        ( test -s {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE_PSEUDO.bed && \
            cat {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE_PSEUDO.bed | tr ":" "|" > {params.work_directory}/POSITION_TE_OUTSIDER_IN_PSEUDO_GENOME.bed ) || \
                fail_msg "ERROR : TRUE_POSITION_TE_PSEUDO FAIL ✘\\n" | tee -a {log}.err;

        
        #***********************************
        #FOR SEQUENCE IN READS PSEUDO GENOME

        #NO CHOICE
        test -s {params.work_directory}/OUTSIDER/VARIANT_CALLING/SEQUENCE_INDEL.fasta && \
            cat {params.work_directory}/OUTSIDER/VARIANT_CALLING/SEQUENCE_INDEL.fasta > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/tmp_SEQ_INDEL_MERGE.fasta
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.fasta && \
            cat {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.fasta >> {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/tmp_SEQ_INDEL_MERGE.fasta
        
        test -s {input.all_te} && \
            cat {input.all_te} | cut -f 1,2 | sed 's/:[+-]//g' > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/tmp_ssqid_TE.txt
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv && \
            cat {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv | cut -f 1,2 | sed 's/:[+-]//g' >> {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/tmp_ssqid_TE.txt

        ! test -s {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/tmp_ssqid_TE.txt && fail_msg "ERROR : NO ssqid found ✘\\n" | tee -a {log}.err && exit 4;

        rm -f {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE_READS.fasta
        for ID in `cat {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/ID.txt`; do

            IS_CLIPPED=`echo $ID | grep -E -o "SOFT|HARD" || echo ""`

            if ! test -n "$IS_CLIPPED"; then
                tmp_info_var=`grep -w "$ID" {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/tmp_ssqid_TE.txt || echo ""`;
                
                if test -n "$tmp_info_var";
                then
                    TE=`grep -w "$ID" {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/tmp_ssqid_TE.txt | cut -f 1`
                    head=`grep -w "$ID" {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/tmp_ssqid_TE.txt | cut -f 2`
                    TSD_SEQ_EXIST=`test -s {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{TE}}_OK_SEQ.fasta && grep -w "$ID" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{TE}}_OK_SEQ.fasta || echo ""`;
                    start=`grep -w "$ID" {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/tmp_ssqid_TE.txt | cut -f 2 | cut -d ":" -f 3`

                    if [ -n "$TSD_SEQ_EXIST" ]; then
                        
                        #TSD NEW POS
                        NEW_POS=`(grep "OK:$ID]" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{TE}}.txt -A 5 | grep "TSD_POSITION" | cut -d ":" -f 2) || echo ""`
                        if [ ! -n "$NEW_POS" ] && test -s {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{TE}}_KO_corrected.txt; then
                            NEW_POS=`grep "KO->OK:$ID]" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{TE}}_KO_corrected.txt -A 5 | grep "NEW_POS=" | cut -d "=" -f 2 | cut -d ":" -f 1 || echo "$start"`                
                        elif [ ! -n "$NEW_POS" ]; then
                            NEW_POS="$start";
                        fi;

                        head=`echo "$head" | awk -v NEW_POS="$NEW_POS" -F ":" 'OFS=":" {{ if( $3 != NEW_POS ){{$3=NEW_POS; $4=NEW_POS+1; $7="PRECISE-TSD"; print $0}}else{{print $0}} }}'`
                        seq=`grep -w "$ID" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{TE}}_OK_SEQ.fasta -A 1 | grep -v ">"` 
                    else
                        seq=`grep -w "$head" {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/tmp_SEQ_INDEL_MERGE.fasta -A 1 | grep -v ">"`
                    fi;

                    #if [ -n "$head" ] && [ -n "$seq" ]; then
                        echo ">$head" >> {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE_READS.fasta
                        echo "$seq" >> {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE_READS.fasta
                    #fi;
                fi;
            fi;
        done;

        awk 'BEGIN{{start=0; header=0;}} OFS="\t"{{if(substr($0, 1, 1) == ">"){{split($0, sp, ":"); header=$0; start=sp[3];}}else{{print header, start, start+length($0)}} }}' \
            {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE_READS.fasta | sed 's/^>//g' > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_READS.bed

        grep -f {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/ID.txt {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_READS.bed \
            > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE_READS.bed

        #FASTA TO FORMAT bed for script vr_to_genome
        while read l; do 
            chrom=`echo $l | cut -d ":" -f 1`;  
            start=`echo $l | cut -d " " -f 2`; 
            end=`echo $l | cut -d " " -f 3`; 
            ID=`echo $l | cut -f 1 | cut -d":" -f 5`;
            TE=`(grep -w "$ID" {input.all_te} || grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv) | cut -f 1 || echo "NONE"` ;
            if [ "$TE" != "NONE" ]; then
                echo "$chrom $start $end $TE:$ID"; 
            fi;

        done < {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE_READS.bed | tr " " "\t" > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_TE_READS.bed
        echo  "INTEGRATE TE IN READS TO GENOME..."

        SIZE_TO_ADD=`awk '/^[^>]/ {{size+=length($0)}} END{{print size}}' {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE_READS.fasta`;
        echo "   SIZE TO ADD : $SIZE_TO_ADD";

        ## INTEGRATE TE TO GENOME
        python3 ${{path_to_pipline}}/lib/python/vr_to_genome.py \
            -ob {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE_NEO.bed \
            -og {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/NEO_GENOME.fasta \
            {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_TE_READS.bed \
            {params.work_directory}/tmp_genome_format.fasta \
            {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE_READS.fasta

        cat {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE_NEO.bed | tr ":" "|" > {params.work_directory}/POSITION_TE_OUTSIDER_IN_NEO_GENOME.bed

        samtools faidx {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/NEO_GENOME.fasta;
        SIZE_GENOME_AFTER=`awk '{{s+=$2}} END{{print s}}' {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/NEO_GENOME.fasta.fai`;

        echo "   SIZE GENOME BEFORE INTEGRATION : $SIZE_GENOME_BEFOR";
        echo "   SIZE GENOME AFTER INTEGRATION  : $SIZE_GENOME_AFTER";
        echo "   SIZE ADDED : $((SIZE_GENOME_AFTER-SIZE_GENOME_BEFOR))";

        ## CHECKING TE INTEGRATED ##
        echo  "CHECKING TE INTEGRATED..."

        cat {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/PSEUDO_GENOME_TE_DB_ID.fasta > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/tmp_PSEUDO_GENOME_TE_DB_ID.fasta


        bedtools getfasta -fi {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/PSEUDO_GENOME_TE_DB_ID.fasta \
            -bed {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE_PSEUDO.bed \
            -name+ > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE.fasta

        TOTAL_TE=`grep -w -v -E "SOFT.[0-9]+|HARD.[0-9]+" {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed -c`

        ! test -s {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE.fasta || ! test -s  {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE.fasta && fail_msg "ERROR : MISSING FASTA PSEUDO FOUND ✘\\n" | tee -a {log}.err;
        
        NB_SEQ_FOUND=`grep -w -f {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE.fasta {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE.fasta -c || echo 0`
        
        echo "TOTAL TE: $TOTAL_TE ; TE INTEGRATE ON GENOME TE_DB_ID : $NB_SEQ_FOUND ;"

        ###READS
        bedtools getfasta -fi {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/NEO_GENOME.fasta \
            -bed {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE_NEO.bed \
            -name+ > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE_READS.fasta

        ! test -s {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE_READS.fasta || ! test -s  {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE_READS.fasta && fail_msg "ERROR : MISSING FASTA NEO FOUND ✘\\n" | tee -a {log}.err;

        NB_SEQ_FOUND=`grep -w -f {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE_READS.fasta {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE_READS.fasta -c || echo 0`
        
        echo "TOTAL TE: $TOTAL_TE ; TE INTEGRATE ON NEO GENOME: $NB_SEQ_FOUND ;"
        
        rm -f {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/PSEUDO_GENOME_TE_DB_ID.fasta.fai #important to delet this
        rm -f {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/ID.txt;
        rm -f {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_TE*
        rm -f `find {params.work_directory} -name "*.fai"`
        rm -f {params.work_directory}/tmp_geno*
        """

#END TE_TOWARD_GENOME


rule TSD_OUTSIDER :
    input:
        FK_SEQ    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/FK/ALL_FK_REPORT_FT.bed",
        
    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TSD/TSD_TE.tsv",
        output_link=[],

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement
        threads        = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,

        #TSD
        SIZE_FLANK       = config["PARAMS"]["OUTSIDER_VARIANT"]["TSD"]["SIZE_FLANK"],

        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/TSD_OUTSIDER",

    shell:
        """
        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] <<< TSD OUTSIDER >>> {params.cend}"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        rm -f {log}.*
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        mkdir -p {params.work_directory}/OUTSIDER/TSD;

        echo "GET TSD IN READS..."
        python3 ${{path_to_pipline}}/lib/python/TSD/getTSDreads.py -t {params.threads} \
            {params.work_directory}/OUTSIDER/FK/ALL_FK_REPORT_FT.bed \
            {params.work_directory}/OUTSIDER/TSD/TSD_TE.tsv \
                1>> {log}.out 2>> {log}.err | tee -a {log}.out \
                || warn_msg "WARNING : FAIL GET TSD OUTSIDER ✘\\n" | tee -a {log}.err ; 
        
        echo "TSD OUTSIDER DONE !";

        """


#END TSD_OUTSIDER


#Get just sequence potentiel candidate of TE
rule GET_SEQ_TE :
    input:
        genome            = config["DATA"]["GENOME"],
        all_te            = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        snif_seqs         = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/VARIANT_CALLING/SEQUENCE_INDEL.fasta",
        depth_te          = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/FREQUENCY/FREQUENCY_TE_INS.tsv",
    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/FK/ALL_FK_REPORT_FT.bed",
        directory(config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/ET_FIND_FA/"),
        output_link=[],

    params:
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        SIZE_FLANK     = config["PARAMS"]["OUTSIDER_VARIANT"]["TSD"]["SIZE_FLANK"],

        env            = env, #source environnement

        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/GET_SEQ_TE"

    shell:
        """
        
        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] GET SEQUENCE OF TE [^-^] {params.cend}"

        {params.env}
        rm -f {log}*

        echo "[`date`] LOG TASK {log}.out, {log}.err"

        rm -fr {params.work_directory}/OUTSIDER/ET_FIND_FA {params.work_directory}/OUTSIDER/FK 
        mkdir -p {params.work_directory}/OUTSIDER/ET_FIND_FA ;
        mkdir -p {params.work_directory}/OUTSIDER/FK/READS ;
        mkdir -p {params.work_directory}/OUTSIDER/FK/GENOME ;

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt
        
        rep="{params.work_directory}/OUTSIDER/ET_FIND_FA" 
        prefix="TE_REPORT"

        ##GET ID sniffles
        rm -f {params.work_directory}/.tmp_id.txt
        ( test -s {input.all_te} && \
            awk 'NR>1{{print $2}}' {input.all_te} > {params.work_directory}/.tmp_id.txt && \
                echo "GET ID sniffles ✔" | tee -a {log}.out ) || warn_msg "WARNING : FAIL GET ID sniffles ✘\\n" | tee -a {log}.err ; 

        ##GET ID TrEMOLO
        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed && \
            cut -f 4 {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed | cut -d "|" -f 2 > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/ID_TrEMOLO.txt

        ( test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/ID_TrEMOLO.txt && \
            awk '{{print "TrEMOLO.INS."$0}}' {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/ID_TrEMOLO.txt > {params.work_directory}/.tmp_id_TrEMOLO.txt ) || \
                warn_msg "WARNING : GET ID TE OUTSIDER TrEMOLO 1 ✘\\n" | tee -a {log}.err ;

        ( test -s {params.work_directory}/.tmp_id_TrEMOLO.txt && \
            grep -w -f {params.work_directory}/.tmp_id_TrEMOLO.txt {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv | awk 'NR>1{{print $2}}' >> {params.work_directory}/.tmp_id.txt && \
                echo "GET ID TrEMOLO ✔" | tee -a {log}.out ) || warn_msg "WARNING : GET ID TE OUTSIDER TrEMOLO 2 ✘\\n" | tee -a {log}.err
        
        
        ##GET ID COMBINE sniffles
        ( test -s {params.work_directory}/.tmp_id.txt && \
            grep -w -f {params.work_directory}/.tmp_id.txt {params.work_directory}/OUTSIDER/TE_DETECTION/COMBINE_TE.csv > {params.work_directory}/.tmp_combine.csv && \
                echo "GET ID COMBINE sniffles ✔" | tee -a {log}.out ) || warn_msg "WARNING : GET ID COMBINE sniffles ✘\\n" | tee -a {log}.err
        

        ##GET ID COMBINE TrEMOLO
        ( test -s {params.work_directory}/.tmp_id.txt && \
            grep -w -f {params.work_directory}/.tmp_id.txt {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/COMBINE_INS_TREMOLO.csv >> {params.work_directory}/.tmp_combine.csv && \
                echo "GET ID COMBINE TrEMOLO ✔" | tee -a {log}.out ) || warn_msg "WARNING : GET ID COMBINE TrEMOLO ✘\\n" | tee -a {log}.err
        
        echo "sseqid", "qseqid", "pident", "size_per", "size_el", "mismatch", "gapopen", "qstart", "qend", "sstart", "send", "evalue", "bitscore" | tr -d " " | tr "," "\t" > {params.work_directory}/test.csv
        
        ( test -s {params.work_directory}/.tmp_combine.csv && \
            awk 'NR>1 && OFS="\t"{{print $1, $2, $3, $4, $5, "mismatch", "gapopen", $6, $7, $8, $9, "evalue", "bitscore"}}' {params.work_directory}/.tmp_combine.csv > {params.work_directory}/tmp.csv ) || \
                warn_msg "NO TE COMBINE FOUND HEAD...\\n" | tee -a {log}.err

        rm -f {params.work_directory}/tmp_TE_all.csv;
        test -s {params.work_directory}/tmp.csv && \
            ( [[ `cat {params.work_directory}/tmp.csv | wc -l` -gt 1 ]] && cat {params.work_directory}/tmp.csv | sed -e 's/:[-+]//g' > {params.work_directory}/tmp_TE_all.csv ) || \
                warn_msg "NO TE COMBINE FOUND ✘\\n" | tee -a {log}.err

        samtools faidx {input.genome}

        cut -f -2 {input.genome}.fai > {params.work_directory}/OUTSIDER/SIZE_SEQ.tsv
        cat {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_SIZE.tsv >> {params.work_directory}/OUTSIDER/SIZE_SEQ.tsv
        
        test -s {params.work_directory}/tmp_TE_all.csv && \
            awk -v dir="$rep" -v prefix="$prefix" -v sizeFlank="{params.SIZE_FLANK}" '

                function min(a, b) {{
                    return a < b ? a : b;
                }}

                function max(a, b) {{
                    return a > b ? a : b;
                }}

                BEGIN{{OFS="\t";}}

                NR == FNR {{ 
                    dic[$1]=$2;
                    next;
                }}
                
                {{
                    split($2, infos, ":");
                    founded=0;
                    if($8<$9){{
                        print $2, $8-1, $9  >> dir"/"prefix"_find_"$1".bed"
                        if(dic[$2] != "" && $9<int(dic[$2]) && int(dic[$2])-$9>=4 && $8-1>=4){{
                            print $2, 0, $8-1, $5":"$1":FKL" >> dir"/../FK/READS/"prefix"_flanking_"$1".bed"
                            print $2, $9, dic[$2], $5":"$1":FKR" >> dir"/../FK/READS/"prefix"_flanking_"$1".bed"
                            founded=1;
                        }}
                        #else{{
                        #    print $9, dic[$2], ($9<int(dic[$2])), (int(dic[$2])-$9>=4);
                        #}}
                        
                    }} 
                    else{{
                        print $2, $9-1, $8  >> dir"/"prefix"_find_"$1".bed"
                        if(dic[$2] != "" && $8<int(dic[$2]) && int(dic[$2])-$8>=4 && $9-1>=4){{
                            
                            print $2, 0, $9-1, $5":"$1":FKL" >> dir"/../FK/READS/"prefix"_flanking_"$1".bed"
                            print $2, $8, dic[$2], $5":"$1":FKR" >> dir"/../FK/READS/"prefix"_flanking_"$1".bed"
                            founded=1;
                        }}
                        #else{{
                        #    print $8, dic[$2], ($8<int(dic[$2])), (int(dic[$2])-$8>=4);
                        #}}
                    }}

                    ##SVI GENOME
                    if(founded==1){{
                        print infos[1], max(0, infos[3]-sizeFlank-1), infos[3]-1, $2, $1":FKL" >> dir"/../FK/GENOME/"prefix"_SVI_"$1".bed"
                        print infos[1], infos[3]-1, min(infos[3]+sizeFlank-1, dic[infos[1]]), $2, $1":FKR" >> dir"/../FK/GENOME/"prefix"_SVI_"$1".bed"
                    }}

                }}' {params.work_directory}/OUTSIDER/SIZE_SEQ.tsv {params.work_directory}/tmp_TE_all.csv || \
                    warn_msg "NO TE FOUND FOR BED ✘\\n" | tee -a {log}.err;

        ##TrEMOLO INS and sniffles/svim MERGE
        cat {input.snif_seqs} {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.fasta > {params.work_directory}/tmp_SEQ_TE_ALL.fasta

        #cp {params.work_directory}/tmp_TE_all.csv {params.work_directory}/Keep_TE_all.csv

        echo "GET SEQ TE..."
        for i in `ls {params.work_directory}/OUTSIDER/ET_FIND_FA | grep ".bed$"`; 
        do
            nameTE=`echo $i | grep -o "find_[^.]*\." | sed 's/\.$//g' | sed 's/find_//g'`;
            bedtools getfasta -fi {params.work_directory}/tmp_SEQ_TE_ALL.fasta \
               -bed {params.work_directory}/OUTSIDER/ET_FIND_FA/$i > {params.work_directory}/OUTSIDER/ET_FIND_FA/TE_REPORT_FOUND_${{nameTE}}.fasta;
        done ;

        echo "GET SEQ INS FLANKING..."
        for i in `ls {params.work_directory}/OUTSIDER/FK/READS | grep ".*_flanking_.*.bed$"`; 
        do
            nameTE=`echo $i | grep -o "flanking_[^.]*\." | sed 's/\.$//g' | sed 's/flanking_//g'`
            bedtools getfasta -tab -fi {params.work_directory}/tmp_SEQ_TE_ALL.fasta \
               -bed {params.work_directory}/OUTSIDER/FK/READS/$i -name+ > {params.work_directory}/OUTSIDER/FK/READS/FK_REPORT_FOUND_${{nameTE}}.bed;
        done ;

        echo "GET SEQ FLANKING GENOME..."
        for i in `ls {params.work_directory}/OUTSIDER/FK/GENOME | grep ".*_SVI_.*.bed$"`; 
        do
            nameTE=`echo $i | grep -o "SVI_[^.]*\." | sed 's/\.$//g' | sed 's/flanking_//g'`
            bedtools getfasta -tab -fi {input.genome} \
               -bed {params.work_directory}/OUTSIDER/FK/GENOME/$i -name+ > {params.work_directory}/OUTSIDER/FK/GENOME/FK_REPORT_FOUND_${{nameTE}}.bed;
        done ;

        ## FORMAT FLANK READ
        cat {params.work_directory}/OUTSIDER/FK/READS/FK_REPORT_FOUND_*.bed | awk -v size_flank="{params.SIZE_FLANK}" '
                BEGIN{{OFS="\t"}}
                
                #FK_L
                NR%2==1 {{
                    split($1, sp, ":"); 
                    ID=sp[9]; 
                    TE=sp[2]; 
                    seqL=$2; 
                    infos=""; 
                    for(i=5; i<=12; i++){{
                        if(i==5)
                            infos=sp[1]":"sp[i]
                        else
                            infos=infos":"sp[i]
                    }}
                }}
                
                #FK_R
                NR%2==0 && OFS="\t" {{
                    print infos, TE, ID, substr(seqL, length(seqL)-size_flank, length(seqL)), substr($2, 1, size_flank);
                }} 
            ' > {params.work_directory}/OUTSIDER/FK/ALL_FK_REPORT_FT_READS.bed;

        ###FORMAT FLANK GENOME
        cat {params.work_directory}/OUTSIDER/FK/GENOME/FK_REPORT_FOUND_*.bed | awk -v size_flank="{params.SIZE_FLANK}" '
                BEGIN{{OFS="\t"}}
                
                #FK_L
                NR%2==1 {{
                    split($1, sp, ":"); 
                    ID=sp[5]; 
                    TE=sp[1]; 
                    seqL=$2; 
                    infos=""; 
                    for(i=1; i<=11; i++){{
                        infos=infos":"sp[i]
                    }}
                }}
                
                #FK_R
                NR%2==0 && OFS="\t" {{
                    print infos, TE, ID, substr(seqL, length(seqL)-size_flank, length(seqL)), substr($2, 1, size_flank);
                }} 
            ' > {params.work_directory}/OUTSIDER/FK/ALL_FK_REPORT_FT_GENOME.bed;


        ###CONCAT FK SVI
        awk -v size_flank="{params.SIZE_FLANK}" '
                BEGIN{{OFS="\t"}}
                
                NR == FNR {{ 
                    dic[$3, 1]=$4;
                    dic[$3, 2]=$5;
                    next;
                }}
                
                OFS="\t" {{
                    if(dic[$3, 1] != "" && dic[$3, 2] != ""){{
                        print $0, dic[$3, 1], dic[$3, 2];
                    }}
                }}
            ' {params.work_directory}/OUTSIDER/FK/ALL_FK_REPORT_FT_GENOME.bed {params.work_directory}/OUTSIDER/FK/ALL_FK_REPORT_FT_READS.bed \
                > {params.work_directory}/OUTSIDER/FK/ALL_FK_REPORT_FT.bed;


        echo "NB TE FLANKING OK : "`cat {params.work_directory}/OUTSIDER/FK/ALL_FK_REPORT_FT.bed | wc -l`;

        echo "IN {params.work_directory}/OUTSIDER/ET_FIND_FA NUMBER OF FAMILY : `ls {params.work_directory}/OUTSIDER/ET_FIND_FA | grep ".fasta" | wc -l`"

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] GETTING DONE ! [^-^] {params.cend}"

        rm -f {params.work_directory}/.tmp*
        rm -f {params.work_directory}/OUTSIDER/ET_FIND_FA/*_find_*.bed ;
        rm -f {params.work_directory}/tmp*.*
        rm -f `find {params.work_directory} -name "*.fai"`
        rm -f {params.work_directory}/test.csv
        """


#END GET_SEQ_TE


rule FREQUENCEv2 :
    input:
        vcf           = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/VARIANT_CALLING/SV.vcf",
        fasta_TE      = config["DATA"]["TE_DB"],
        bam           = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/MAPPING/SAMPLE_mapping_GENOME_MD.sorted.bam",
        all_te        = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        genome        = config["DATA"]["GENOME"],
        bed_INS       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.bed",
        merge_TE_bed  = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed",
        outsider_bed  = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/POSITION_TE_OUTSIDER.bed",
        te_size       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/1-UTILS/TE_SIZE.tsv",
        input_link=[],

    output:
        depth_te  = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/FREQUENCY/FREQUENCY_TE_INS.tsv",
        
    params:
        path_snk        = path_snk,
        work_directory  = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        threads        = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,

        preset_view    = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_VIEW"]["PRESET_OPTION"]) + " --threads " + str(config["PARAMS"]["THREADS"]),
        preset_sort    = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_SORT"]["PRESET_OPTION"]) + " --threads " + str(config["PARAMS"]["THREADS"]),
        preset_callmd  = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_CALLMD"]["PRESET_OPTION"]) + " --threads " + str(config["PARAMS"]["THREADS"]),

        pars_bln_option = config["PARAMS"]["OUTSIDER_VARIANT"]["PARS_BLN_OPTION"],

        env             = env, #source environnement

        call_sv         = config["CHOICE"]["OUTSIDER_VARIANT"]["CALL_SV"],

        CHROM_KEEP             = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["CHROM_KEEP"],
        GET_SEQ_REPORT_OPTION  = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["GET_SEQ_REPORT_OPTION"],


        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/FREQUENCEv2"

    shell:
        """
        {params.env}

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] OPTIMIZE FREQUENCE [^-^] {params.cend}"

        path_to_pipline=`dirname {params.path_snk}`

        mkdir -p {params.work_directory}/OUTSIDER/FREQUENCY

        rm -f {log}.out {log}.err
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        ##FILTER_BLAST
        ###no header
        ###sniffles
        awk 'NR>1' {params.work_directory}/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv > {params.work_directory}/OUTSIDER/FREQUENCY/tmp_FILTER_BLAST_sniffles.csv 
        
        ###SOFT
        touch {params.work_directory}/OUTSIDER/FREQUENCY/tmp_FILTER_BLAST_SOFT.csv;
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.csv && \
            awk 'NR>1' {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.csv > {params.work_directory}/OUTSIDER/FREQUENCY/tmp_FILTER_BLAST_SOFT.csv

        ###HARD
        touch {params.work_directory}/OUTSIDER/FREQUENCY/tmp_FILTER_BLAST_HARD.csv;
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.csv && \
            awk 'NR>1' {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.csv > {params.work_directory}/OUTSIDER/FREQUENCY/tmp_FILTER_BLAST_HARD.csv

        cat {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv \
            {params.work_directory}/OUTSIDER/FREQUENCY/tmp_FILTER_BLAST_sniffles.csv \
            {params.work_directory}/OUTSIDER/FREQUENCY/tmp_FILTER_BLAST_SOFT.csv \
            {params.work_directory}/OUTSIDER/FREQUENCY/tmp_FILTER_BLAST_HARD.csv > {params.work_directory}/OUTSIDER/FREQUENCY/FILTER_BLAST_INS.csv

        ##SORT
        awk 'NR>1 && OFS="\t" {{split($2, sp, ":"); print sp[1], sp[3], sp[4]+1, $0}}' \
            {params.work_directory}/OUTSIDER/FREQUENCY/FILTER_BLAST_INS.csv | bedtools sort | cut -f 4- \
                > {params.work_directory}/OUTSIDER/FREQUENCY/tmp_FILTER_BLAST_INS.sorted.csv

        head -n 1 {params.work_directory}/OUTSIDER/FREQUENCY/FILTER_BLAST_INS.csv > {params.work_directory}/OUTSIDER/FREQUENCY/tmp_head.csv
        cat {params.work_directory}/OUTSIDER/FREQUENCY/tmp_head.csv \
            {params.work_directory}/OUTSIDER/FREQUENCY/tmp_FILTER_BLAST_INS.sorted.csv \
                > {params.work_directory}/OUTSIDER/FREQUENCY/FILTER_BLAST_INS.sorted.csv

        ####
        ##GET SV SIZE
        echo "  GET SV SIZE..." | tee -a {log}.out
        
        ###SV SEQ sniffles
        test -s {params.work_directory}/OUTSIDER/VARIANT_CALLING/SEQUENCE_INDEL.fasta && \
            awk ' /^>/ {{ head=substr($0, 2, length($0)); }} 
                /^[^>]/ && OFS="\t"{{ print head, length($0) }}' \
                {params.work_directory}/OUTSIDER/VARIANT_CALLING/SEQUENCE_INDEL.fasta \
                    > {params.work_directory}/OUTSIDER/FREQUENCY/SV_SIZE.tsv
        
        ###SV SEQ TrEMOLO
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.fasta && \
            awk ' /^>/ {{ head=substr($0, 2, length($0)); }} 
                /^[^>]/ && OFS="\t"{{ print head, length($0) }}' \
                {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.fasta \
                    >> {params.work_directory}/OUTSIDER/FREQUENCY/SV_SIZE.tsv

        ###SV SEQ SOFT
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.fasta && \
            awk ' /^>/ {{ head=substr($0, 2, length($0)); }} 
                /^[^>]/ && OFS="\t"{{ print head, length($0) }}' \
                {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.fasta \
                    >> {params.work_directory}/OUTSIDER/FREQUENCY/SV_SIZE.tsv

        ###SV SEQ HARD
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD.fasta && \
            awk ' /^>/ {{ head=substr($0, 2, length($0)); }} 
                /^[^>]/ && OFS="\t"{{ print head, length($0) }}' \
                {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD.fasta \
                    >> {params.work_directory}/OUTSIDER/FREQUENCY/SV_SIZE.tsv

        echo "  GET SV SIZE ✔" | tee -a {log}.out


        touch {params.work_directory}/OUTSIDER/FREQUENCY/tmp_POSITION_START_TE.bed
        awk -v window="50" 'NR>1 && OFS="\t" {{ split($2, sp, ":"); print sp[1], (sp[3]-window > 0 ? sp[3]-window : 1), sp[4]+window }}' {params.work_directory}/OUTSIDER/FREQUENCY/FILTER_BLAST_INS.sorted.csv \
            | bedtools merge -d 1 \
            > {params.work_directory}/OUTSIDER/FREQUENCY/tmp_POSITION_START_TE.bed

        samtools view {params.preset_view} -q 10 -F 4 -h -b {input.bam} -L {params.work_directory}/OUTSIDER/FREQUENCY/tmp_POSITION_START_TE.bed > {params.work_directory}/OUTSIDER/FREQUENCY/MAPPING_POSTION_TE.bam
        samtools index {params.work_directory}/OUTSIDER/FREQUENCY/MAPPING_POSTION_TE.bam
        
        echo "GET BAM TE OUTSIDER ✔" | tee -a {log}.out 

        ##COUNT READS
        echo "  COUNT READS..." | tee -a {log}.out

        sizePercent=`echo "{params.pars_bln_option}" | grep -E 'min-size-percent [0-9]+' -o | awk '$2-10>5{{ print $2-10; }} $2-10<5{{ print 5; }}'`;
        
        
        echo "  BUILD CHUNKS..." | tee -a {log}.out
        python3 ${{path_to_pipline}}/lib/python/format_files/divideToChunks.py \
            {params.work_directory}/OUTSIDER/FREQUENCY/FILTER_BLAST_INS.sorted.csv \
            {params.threads} \
            {params.work_directory}/OUTSIDER/FREQUENCY/CHUNKS
        
        coutReadsFreq () {{
            echo "    CHUNK N=$1 -->" | tee -a {log}.out
            python3 ${{path_to_pipline}}/lib/python/parsing/getFrequency.py -p ${{sizePercent}} \
                {params.work_directory}/OUTSIDER/FREQUENCY/MAPPING_POSTION_TE.bam \
                {params.work_directory}/OUTSIDER/FREQUENCY/CHUNKS/tmp_chunk_${{1}}.csv \
                {params.work_directory}/1-UTILS/TE_SIZE.tsv \
                {params.work_directory}/OUTSIDER/FREQUENCY/SV_SIZE.tsv \
                {params.work_directory}/OUTSIDER/FREQUENCY/COUNT_READS_${{1}}.txt 2>> {log}.err \
                    || (fail_msg "...COUNT READS ✘" | tee -a {log}.out && exit 1)
            echo "    CHUNK N=$1 DONE ✔";
        }}

        

        ###RUN PARLELIZE
        NB_FILE=`ls {params.work_directory}/OUTSIDER/FREQUENCY/CHUNKS/ | wc -l` ;
        i=0 ;

        #PARLELIZE
        count_task_running=0;
        pids=();
        for chunk in `ls {params.work_directory}/OUTSIDER/FREQUENCY/CHUNKS/`; do
            echo "  CHUNK : $chunk"
            
            coutReadsFreq $(($count_task_running+1)) &
            pids[${{count_task_running}}]=$!;
            count_task_running=$(($count_task_running+1));

            if [ $count_task_running -ge {params.threads} ]; then
                c=1;
                for pid in ${{pids[*]}}; do
                    wait $pid || echo > /dev/null;
                    c=$(($c+1));
                done;
                pids=();
                count_task_running=0;
            fi;

            i=$(($i + 1)) ;
            printf "%s\\n" "{params.cmess} [SNK]--[`date`] [CHUNK:snk] : $i/$NB_FILE {params.cend}"
        done;

        #WAIT LAST TASKS
        if [ $count_task_running -lt {params.threads} ]; then
            pids[${{count_task_running}}]=$!
            task=1;
            for pid in ${{pids[*]}}; do
                wait $pid || echo > /dev/null;
                task=$(($task+1));
            done;
        fi;

        ##MERGE COUNT_READS
        echo "  MERGE CHUNKS COUNT READS..." | tee -a {log}.out
        cat {params.work_directory}/OUTSIDER/FREQUENCY/COUNT_READS_*.txt | sort -k 3 \
            > {params.work_directory}/OUTSIDER/FREQUENCY/COUNT_READS.txt;

        echo "  COUNT READS ✔" | tee -a {log}.out


        ##GET FREQUENCY
        echo "  GET FREQUENCY..." | tee -a {log}.out
        awk '{{ print $3":"$2":"$1, $0 }}' {params.work_directory}/OUTSIDER/FREQUENCY/COUNT_READS.txt | \
            sort | cut -d " " -f 2- | \
            awk '
                ID!=$3 && NR>1 && OFS="\t" {{ 
                    if(svType=="INS"){{
                        if(I<_RS) I=_RS; 
                        if(substr(ID, 1, 8) == "sniffles" && I_Only<_RS){{ 
                            I_Only=_RS;
                        }}
                        if(I_Only==0) I_Only=_RS;
                        if(total<I || total==0) total=I;
                        if(total-I_clipped < I_Only || total-I_clipped==0) total_no_clipped=total; else total_no_clipped=(total-I_clipped);
                        print position, ID, TE, I_Only, I_clipped, total_no_clipped, I, total, (I_Only/total_no_clipped)*100, (I/total)*100, svType;
                    }}
                    else if(svType=="DEL") {{
                        if(D<_RS) D=_RS;
                        if(total<D || total==0) total=D;
                        print position, ID, TE, D, ".", total, (total-D), total, ((total-D)/total)*100, ((total-D)/total)*100, svType;
                    }}
                }}

                ID!=$3 {{ total=0; D=0; I=0; I_Only=0; I_clipped=0; svType=$17; _RS=$5; ID=$3; TE=$4; position=$10; current_read=""; }}  
                
                $1!="E" && current_read!=$2 {{ 
                    if(svType=="INS")
                        I+=1;

                    if(svType=="DEL")
                        D+=1;

                    current_read=$2;
                    total+=1; 

                    if($1=="S" || $1=="H"){{
                        I_clipped+=1;
                    }}
                    else if($1=="I"){{
                        I_Only+=1;
                    }}
                }}

                ($1=="E" && current_read!=$2) {{ total+=1; current_read=$2;}}
                
                END {{ 
                    if(svType=="INS"){{
                        if(I<_RS) I=_RS;
                        if(substr(ID, 1, 8) == "sniffles" && I_Only<_RS){{ 
                            I_Only=_RS;
                        }}
                        if(I_Only==0) I_Only=_RS;
                        if(total<I || total==0) total=I;
                        if(total-I_clipped < I_Only || total-I_clipped==0) total_no_clipped=total; else total_no_clipped=(total-I_clipped);
                        print position, ID, TE, I_Only, I_clipped, total_no_clipped, I, total, (I_Only/total_no_clipped)*100, (I/total)*100, svType;
                    }}
                    else if(svType=="DEL") {{
                        if(D<_RS) D=_RS;
                        if(total<D || total==0) total=D;
                        print position, ID, TE, D, ".", total, (total-D), total, ((total-D)/total)*100, ((total-D)/total)*100, svType;
                    }}
                }}' \
                    > {params.work_directory}/OUTSIDER/FREQUENCY/FREQUENCY_TE_INS.tsv \
                        || (fail_msg "...GET FREQUENCY ✘" | tee -a {log}.out && exit 1)

        echo "  GET FREQUENCY ✔" | tee -a {log}.out

        ##FREQ OPTIMIZED
        echo "FREQ OPTIMIZ...";

        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/COUNT_TE_IN_RS.txt && \
            cat {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/COUNT_TE_IN_RS.txt {params.work_directory}/OUTSIDER/TE_DETECTION/COUNT_TE_IN_RS.txt \
                > {params.work_directory}/OUTSIDER/FREQUENCY/COUNT_TE_IN_RS.txt 2>> {log}.err || \
                fail_msg "ERROR GET FILE TE IN RS\\n";
        
        test -s {params.work_directory}/OUTSIDER/FREQUENCY/COUNT_TE_IN_RS.txt && \
            test -s {params.work_directory}/OUTSIDER/FREQUENCY/FREQUENCY_TE_INS.tsv && \
            awk '
                NR==FNR {{ 
                    dic[$1]=$2; 
                    next;
                }} 
                
                dic[$2":"$3]>0 && OFS="\t" {{ 
                    rsi=dic[$2":"$3];
                    if(rsi==$6+1) #+1 cause:0: sniffles RS
                        print $1, $2, $3, rsi, $5, $6+1, (rsi+$5), $8+1, ((rsi/($6+1))*100), (((rsi+$5)/($8+1))*100), "INS"; 
                    else
                        print $1, $2, $3, rsi, $5, $6, (rsi+$5), $8, ((rsi/$6)*100), (((rsi+$5)/$8)*100), "INS"; 
                }}' {params.work_directory}/OUTSIDER/FREQUENCY/COUNT_TE_IN_RS.txt {params.work_directory}/OUTSIDER/FREQUENCY/FREQUENCY_TE_INS.tsv \
                    > {params.work_directory}/OUTSIDER/FREQUENCY/FREQUENCY_TE_INS_PRECISE.tsv 2>> {log}.err ||
                    fail_msg "ERROR FREQUENCY OPTIMIZED\\n"


        echo "FREQUENCY DONE ! ✔" | tee -a {log}.out

        ##
        rm -f {params.work_directory}/OUTSIDER/FREQUENCY/tmp*
        rm -f `find {params.work_directory} -name "*.fai"`
        """



#END FREQUENCEv2


rule FREQ_INSIDERv2:
    input:
        merge_TE_bed = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed",
        TE_INS       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/TE_DETECTION/INSERTION.csv",
        bam          = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/MAPPING/SAMPLE_mapping_GENOME_MD.sorted.bam",

    output:
        DEPTH = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/FREQ_INSIDER/DEPTH_TE_INSIDER.csv",
        tmp   = output_link=[],

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env,

        preset_view    = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_VIEW"]["PRESET_OPTION"]) + " --threads " + str(config["PARAMS"]["THREADS"]),
        preset_sort    = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_SORT"]["PRESET_OPTION"]) + " --threads " + str(config["PARAMS"]["THREADS"]),
        preset_callmd  = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_CALLMD"]["PRESET_OPTION"]) + " --threads " + str(config["PARAMS"]["THREADS"]),

        
        #COLOR 
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/FREQ_INSIDER",

    shell:
        """

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] INSIDER FREQUENCY {params.cend}"

        {params.env}
        path_to_pipline=`dirname {params.path_snk}`
        
        mkdir -p {params.work_directory}/OUTSIDER/MAPPING_TO_REF/

        rm -f {log}.out {log}.err
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        ###TEST DEBUG
        #####test INSIDER EMPTY
        ###printf "" > {input.TE_INS}

        test -s {input.TE_INS} || warn_msg "WARNING : NO TE INSIDER\\n" | tee -a {log}.err;

        touch {params.work_directory}/OUTSIDER/MAPPING_TO_REF/FLANK_TE.bed
        test -s {input.TE_INS} && \
            cat {input.TE_INS} | cut -f 2 | \
                awk -v margin_flank="100" -F ":" 'OFS="\t"{{split($6, a, "-"); print $5, a[1]-margin_flank, a[1]-margin_flank+1; print $5, a[2]+margin_flank, a[2]+margin_flank+1}}' > {params.work_directory}/OUTSIDER/MAPPING_TO_REF/FLANK_TE.bed

        echo "GET FLANK TE ✔" | tee -a {log}.out

        #DROP CLIPPED
        touch {params.work_directory}/OUTSIDER/MAPPING_TO_REF/FLANK_TE_IN.bed
        test -s {input.TE_INS} && \
            cat {input.TE_INS} | cut -f 2 | \
                awk -v margin_flank="5" -F ":" 'OFS="\t"{{split($6, a, "-"); print $5, a[1]+margin_flank, a[1]+margin_flank+1; print $5, a[2]-margin_flank, a[2]-margin_flank+1}}' > {params.work_directory}/OUTSIDER/MAPPING_TO_REF/FLANK_TE_IN.bed

        echo "DROP CLIPPED ✔" | tee -a {log}.out

        FLAG_EXLUDE=`(echo {params.preset_view} | grep -E "\-F [0-9]+" > /dev/null && echo "") || echo "-F 2048"`

        samtools view {params.preset_view} -h -b {input.bam} $FLAG_EXLUDE -L {params.work_directory}/OUTSIDER/MAPPING_TO_REF/FLANK_TE.bed > {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp_flank_TE_OUT.bam
        samtools index {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp_flank_TE_OUT.bam

        echo "BAM GET FLANK TE ✔" | tee -a {log}.out

        #BAM DROP CLIPPED
        samtools view {params.preset_view} -h -b {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp_flank_TE_OUT.bam \
            $FLAG_EXLUDE -L {params.work_directory}/OUTSIDER/MAPPING_TO_REF/FLANK_TE_IN.bed > {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp2_flank_TE_OUT.bam

        echo "BAM DROP CLIPPED ✔" | tee -a {log}.out
        
        mv {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp2_flank_TE_OUT.bam {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp_flank_TE_OUT.bam
        rm -f {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp_flank_TE_OUT.bam.bai
        samtools index {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp_flank_TE_OUT.bam

        touch {params.work_directory}/OUTSIDER/MAPPING_TO_REF/INSERTION_TE.bed
        test -s {input.TE_INS} && \
            awk 'NR>1 && OFS="\t"{{split($2, a, ":"); split(a[6], b, "-"); print a[5], b[1], b[2], $1"|"a[1]}}' \
                {input.TE_INS} > {params.work_directory}/OUTSIDER/MAPPING_TO_REF/INSERTION_TE.bed

        echo "CSV to BED ✔" >> {log}.out

        echo "GET DELETION...";
        test -s {params.work_directory}/OUTSIDER/MAPPING_TO_REF/INSERTION_TE.bed && \
            python3 ${{path_to_pipline}}/lib/python/parsing/find_deletions.py -m 30 \
                {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp_flank_TE_OUT.bam \
                {params.work_directory}/OUTSIDER/MAPPING_TO_REF/INSERTION_TE.bed \
                    > {params.work_directory}/OUTSIDER/MAPPING_TO_REF/DEL_NB.bed

        echo "BUILD BED FK...";
        awk -v size="30" 'OFS="\t"{{
            print $1, $2-size, $2-size+1; 
            print $1, $3+size-1, $3+size;
        }}' {params.work_directory}/OUTSIDER/MAPPING_TO_REF/INSERTION_TE.bed \
            > {params.work_directory}/OUTSIDER/MAPPING_TO_REF/DEPTH_FK.bed

        echo "GET FLANKING DEPTH...";
        samtools depth {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp_flank_TE_OUT.bam \
            -b {params.work_directory}/OUTSIDER/MAPPING_TO_REF/DEPTH_FK.bed | \
                awk 'OFS="\t" {{print $1":"$2, $3}}' > {params.work_directory}/OUTSIDER/MAPPING_TO_REF/DEPTH_FK.txt

        printf "chrom\tposition\ttotal_depth\tdepth_empty_site\tread_support\tread_support_percent\tTE\tinfo_TE\\n" > {output.DEPTH}
        
        number_lines=`cat {params.work_directory}/OUTSIDER/MAPPING_TO_REF/INSERTION_TE.bed | wc -l`
        i=0;

        echo "GET FREQUENCY...";
        show_step="$i/$number_lines TE"
        number_of_char=`echo "$show_step" | wc -c`
        number_of_char=$(($number_of_char-1));
        printf "\b%.0s" `seq 1 $number_of_char`
        printf "$show_step";

        
        while read line; do
            read -r chrom start end info TE <<< $(echo $line | awk 'OFS="\t"{{split($4, TE, "|"); print $1, $2, $3, $4, TE[1]}}')

            size_TE=$(($end-$start))

            if test -s {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp_flank_TE_OUT.bam; then

                NB_DEL=`grep -w "$info" {params.work_directory}/OUTSIDER/MAPPING_TO_REF/DEL_NB.bed | cut -f 5 || echo "0"`;

                depth_fk_left=`grep -w "$chrom:$(($start-30+1))" {params.work_directory}/OUTSIDER/MAPPING_TO_REF/DEPTH_FK.txt | cut -f 2 || echo 0`;
                depth_fk_right=`grep -w "$chrom:$(($end+30))" {params.work_directory}/OUTSIDER/MAPPING_TO_REF/DEPTH_FK.txt | cut -f 2 || echo 0`;

                if [ -n "$depth_fk_left" ] && [ -n "$depth_fk_right" ] ; then

                    depth_total_mean=$((($depth_fk_left+$depth_fk_right)/2));

                    if [ $depth_total_mean -ne 0 ]; then
                        NB_TE=$(($depth_total_mean-$NB_DEL))

                        if [ -n "$depth_total_mean" ]; then
                            printf "$chrom\t$start\t$depth_total_mean\t$NB_DEL\t$NB_TE\t%.4f\t$TE\t$info\\n" "$(((10**6 * $NB_TE/$depth_total_mean) * 100))e-6" | tr "," "." >> {output.DEPTH}
                        else
                            printf "$chrom\t$start\t-1\t$NB_DEL\t-1\t%.4f\t$TE\tinfo|ERROR\\n" "0" | tr "," "." >> {output.DEPTH}
                            fail_msg "ERROR FOR ${{info}} \\n ERROR GETTING DEPTH YOU NEED TO RECONSTRUCT YOUR BAM FILE\\n";
                        fi;
                    else
                        printf "$chrom\t$start\t0\t0\t0\t%.4f\t$TE\t$info\\n" "0" | tr "," "." >> {output.DEPTH}
                    fi;
                else
                    printf "$chrom\t$start\t0\t0\t0\t%.4f\t$TE\t$info\\n" "0" | tr "," "." >> {output.DEPTH}
                fi;
            else
                 printf "$chrom\t$start\t0\t0\t0\t%.4f\t$TE\t$info\\n" "0" | tr "," "." >> {output.DEPTH}
            fi;
            i=$(($i+1));

            show_step="$i/$number_lines TE"
            number_of_char=`echo "$show_step" | wc -c`
            number_of_char=$(($number_of_char-1));
            printf "\b%.0s" `seq 1 $number_of_char`
            printf "$show_step";

        done < {params.work_directory}/OUTSIDER/MAPPING_TO_REF/INSERTION_TE.bed;
        echo

        rm -f {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp*
        rm -f {params.work_directory}/OUTSIDER/MAPPING_TO_REF/FLANK_TE*
        rm -f `find {params.work_directory} -name "*.fai"`
        """


#END FREQ_INSIDERv2


rule MERGE_TE :
    input:
        all_te           = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        soft_te          = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.bed",
        hard_te          = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.bed",
        TrEMOLO_TE_bed   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.bed",
        sniffles_TE_bed  = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/POSITION_START_TE.bed",

    output:
        merge_TE_bed = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed",
        outsider_bed = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/POSITION_TE_OUTSIDER.bed",
        tmp = output_link=[],

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        call_sv                = config["CHOICE"]["OUTSIDER_VARIANT"]["CALL_SV"],
        CHROM_KEEP             = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["CHROM_KEEP"],
        GET_SEQ_REPORT_OPTION  = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["GET_SEQ_REPORT_OPTION"],
        threads                = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,


        #COLORS
        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

        step=0,

    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/MERGE_TE"


    shell:
        """
        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] MERGE TE [^-^] {params.cend}"

        mkdir -p {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE

        rm -f {log}.out {log}.err
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt


        chrom_keep=`echo "{params.CHROM_KEEP}" | tr "," "|"`

        echo "CHROM KEEP : $chrom_keep;" | tee {log}.out;


        ###TEST DEBUG
        #####test sniffles EMPTY
        ##printf "" > {input.sniffles_TE_bed}
        #####test TrEMOLO EMPTY
        ##printf "" > {input.TrEMOLO_TE_bed}
        #####test SOFT EMPTY
        ##printf "" > {input.soft_te}
        #####test HARD EMPTY
        ##printf "" > {input.hard_te}

        
        test -s {input.sniffles_TE_bed} && \
            echo {input.sniffles_TE_bed} | tee  -a {log}.out || warn_msg "WARNING : NO TE sniffles\\n" | tee -a {log}.err;
        test -s {input.TrEMOLO_TE_bed} && \
            echo {input.TrEMOLO_TE_bed} | tee  -a {log}.out || warn_msg "WARNING : NO TE TrEMOLO\\n" | tee -a {log}.err;
        test -s {input.soft_te} && \
            echo {input.soft_te} | tee  -a {log}.out || warn_msg "WARNING : NO TE SOFT\\n" | tee -a {log}.err;
        test -s {input.hard_te} && \
            echo {input.hard_te} | tee  -a {log}.out || warn_msg "WARNING : NO TE HARD\\n" | tee -a {log}.err;

        ## MERGE TE sniffles and TrEMOLO window 100pb
        ##clusterise window 100nt
        touch {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_POSITION_TE_OUTSIDER_CLUSTER_100.bed;
        test -s {input.sniffles_TE_bed} && \
            bedtools sort -i {input.sniffles_TE_bed} | grep -E "$chrom_keep" | bedtools cluster -d 100 | awk 'BEGIN{{TE=""; num=""}} {{split($4, sp, "|"); if(num==$7 && sp[1]==TE){{TE=sp[1]; num=$7;}}else{{print $0; TE=sp[1]; num=$7;}} }}' | cut -f 1-6 \
                > {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_POSITION_TE_OUTSIDER_CLUSTER_100.bed
        
        echo "CLUSTERING sniffles passing ✔" >> {log}.out

        touch {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TrEMOLO_TE_OUTSIDER_CLUSTER_100.bed;
        test -s {input.TrEMOLO_TE_bed} && \
            bedtools sort -i {input.TrEMOLO_TE_bed} | grep -E "$chrom_keep" | bedtools cluster -d 100 | awk 'BEGIN{{TE=""; num=""}} {{split($4, sp, "|"); if(num==$7 && sp[1]==TE){{TE=sp[1]; num=$7;}}else{{print $0; TE=sp[1]; num=$7;}} }}' | cut -f 1-6 \
                > {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TrEMOLO_TE_OUTSIDER_CLUSTER_100.bed

        
        echo "CLUSTERING TrEMOLO passing ✔" >> {log}.out

        #Get ID Tr/sniffles intersect
        echo "MERGE Tr and svim/sniffles..." | tee -a {log}.out;
        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TrEMOLO_TE_OUTSIDER_CLUSTER_100.bed && \
            test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_POSITION_TE_OUTSIDER_CLUSTER_100.bed && \
            bedtools window -a {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TrEMOLO_TE_OUTSIDER_CLUSTER_100.bed -b {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_POSITION_TE_OUTSIDER_CLUSTER_100.bed -w 100 | \
                awk '{{split($4, sp1, "|");  split($10, sp2, "|"); if(sp1[1] == sp2[1]){{ print $4 }} }}' | sort -u > {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_ID_TrEMOLO.txt

        ###if no intersect get all ID Tr
        touch {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_ID_TrEMOLO.txt;

        echo "INTERSECT TrEMOLO vs sniffles passing ✔" >> {log}.out

        #show NB
        echo -e "BEFORE CLUSTERING" | tee -a {log}.out
        NB_TE_sn=`test -s {params.work_directory}/OUTSIDER/TE_DETECTION/POSITION_START_TE.bed && grep -E "$chrom_keep" {params.work_directory}/OUTSIDER/TE_DETECTION/POSITION_START_TE.bed -c || echo 0`        
        NB_TE_Tr=`test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.bed && grep -E "$chrom_keep" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.bed -c || echo 0`

        echo "      NB sniffles : $NB_TE_sn" | tee -a {log}.out;
        echo "      NB TrEMOLO  : $NB_TE_Tr" | tee -a {log}.out;

        echo -e "\\nAFTER CLUSTERING WINDOW 100" | tee -a {log}.out
        NB_TE_Tr=`test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TrEMOLO_TE_OUTSIDER_CLUSTER_100.bed && grep -E "$chrom_keep" {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TrEMOLO_TE_OUTSIDER_CLUSTER_100.bed -c || echo 0`        
        NB_TE_sn=`test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_POSITION_TE_OUTSIDER_CLUSTER_100.bed && grep -E "$chrom_keep" {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_POSITION_TE_OUTSIDER_CLUSTER_100.bed -c || echo 0`
        NB_intersect=`cat {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_ID_TrEMOLO.txt | wc -l`

        echo "      NB sniffles : $NB_TE_sn" | tee -a {log}.out;
        echo "      NB TrEMOLO  : $NB_TE_Tr" | tee -a {log}.out;
        echo "      NB TrEMOLO IN sniffles : $NB_intersect" | tee -a {log}.out;

        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TrEMOLO_TE_OUTSIDER_CLUSTER_100.bed && \
            grep -w -v -f {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_ID_TrEMOLO.txt {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TrEMOLO_TE_OUTSIDER_CLUSTER_100.bed > {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TE_TrEMOLO_NOT_FOUND_IN_sniffles.bed || \
                touch {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TE_TrEMOLO_NOT_FOUND_IN_sniffles.bed

        echo "TrEMOLO NOT FOUND IN sniffles passing ✔" >> {log}.out

        #SOFT
        echo "   SOFT..." | tee -a {log}.out;
        touch {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_SOFT_CLUSTER_100.bed
        test -s {input.soft_te} && \
            bedtools sort -i {input.soft_te} | grep -E "$chrom_keep" | bedtools cluster -d 100 | awk 'BEGIN{{TE=""; num=""}} {{split($4, sp, "|"); if(num==$7 && sp[1]==TE){{TE=sp[1]; num=$7;}}else{{print $0; TE=sp[1]; num=$7;}} }}' | cut -f 1-6 > {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_SOFT_CLUSTER_100.bed

        echo "      NB TE SOFT : `grep -E "$chrom_keep" {input.soft_te} | wc -l`" | tee -a {log}.out;
        echo "      NB TE SOFT CLUSTERED (-w 100) : `cat {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_SOFT_CLUSTER_100.bed | wc -l`" | tee {log}.out;

        ##Commun SOFT vs sniffles
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.bed && \
            test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_POSITION_TE_OUTSIDER_CLUSTER_100.bed && \
            bedtools window -a {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_SOFT_CLUSTER_100.bed -b {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_POSITION_TE_OUTSIDER_CLUSTER_100.bed -w 100 | awk '{{split($4, sp1, "|");  split($10, sp2, "|"); if(sp1[1] == sp2[1]){{ print $0 }} }}' | cut -f 4 | sort -u > {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_ID_SOFT_commun.txt
        
        echo "Commun SOFT vs sniffles passing ✔" >> {log}.out

        ##Commun SOFT vs TrEMOLO
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.bed && \
            test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TrEMOLO_TE_OUTSIDER_CLUSTER_100.bed && \
            bedtools window -a {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_SOFT_CLUSTER_100.bed -b {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TrEMOLO_TE_OUTSIDER_CLUSTER_100.bed -w 100 | awk '{{split($4, sp1, "|");  split($10, sp2, "|"); if(sp1[1] == sp2[1]){{ print $0 }} }}' | cut -f 4 | sort -u >> {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_ID_SOFT_commun.txt

        echo "Commun SOFT vs TrEMOLO passing ✔" >> {log}.out

        ##Get SOFT not found in sniffles and TrEMOLO
        touch {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TE_SOFT_NOT_FOUND_IN_sniffles_and_TrEMOLO.bed
        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_SOFT_CLUSTER_100.bed && \
            grep -w -v -f {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_ID_SOFT_commun.txt {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_SOFT_CLUSTER_100.bed > {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TE_SOFT_NOT_FOUND_IN_sniffles_and_TrEMOLO.bed

        echo "SOFT NOT in sniffles and TrEMOLO passing ✔" >> {log}.out

        ##HARD
        ###CLUSTERING
        touch {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_HARD_CLUSTER_100.bed
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.bed && \
            bedtools sort -i {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.bed | grep -E "$chrom_keep" | bedtools cluster -d 100 | awk 'BEGIN{{TE=""; num=""}} {{split($4, sp, "|"); if(num==$7 && sp[1]==TE){{TE=sp[1]; num=$7;}}else{{print $0; TE=sp[1]; num=$7;}} }}' | cut -f 1-6 > {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_HARD_CLUSTER_100.bed

        echo "   HARD..." | tee -a {log}.out;
        echo "      NB TE HARD ; `grep -E "$chrom_keep" {input.hard_te} -c`" | tee -a {log}.out
        echo "      NB TE HARD CLUSTERED (-w 100) ; `grep -E "$chrom_keep" {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_HARD_CLUSTER_100.bed -c`" | tee -a {log}.out

        ##COMMUN
        ##HARD vs sniffles
        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_HARD_CLUSTER_100.bed && \
            test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_POSITION_TE_OUTSIDER_CLUSTER_100.bed && \
            bedtools window -a {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_HARD_CLUSTER_100.bed -b {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_POSITION_TE_OUTSIDER_CLUSTER_100.bed -w 100 | awk '{{split($4, sp1, "|");  split($10, sp2, "|"); if(sp1[1] == sp2[1]){{ print $0 }} }}' | cut -f 4 | sort -u > {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_ID_HARD_commun.txt
        
        echo "Commun HARD vs sniffles passing ✔" >> {log}.out

        ##HARD vs TrEMOLO
        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_HARD_CLUSTER_100.bed && \
            test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TrEMOLO_TE_OUTSIDER_CLUSTER_100.bed && \
            bedtools window -a {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_HARD_CLUSTER_100.bed -b {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TrEMOLO_TE_OUTSIDER_CLUSTER_100.bed -w 100 | awk '{{split($4, sp1, "|");  split($10, sp2, "|"); if(sp1[1] == sp2[1]){{ print $0 }} }}' | cut -f 4 | sort -u >> {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_ID_HARD_commun.txt
        
        echo "Commun HARD vs TrEMOLO passing ✔" >> {log}.out

        ##HARD vs SOFT
        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_HARD_CLUSTER_100.bed && \
            test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_SOFT_CLUSTER_100.bed && \
            bedtools window -a {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_HARD_CLUSTER_100.bed -b {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_SOFT_CLUSTER_100.bed -w 100 | awk '{{split($4, sp1, "|");  split($10, sp2, "|"); if(sp1[1] == sp2[1]){{ print $0 }} }}' | cut -f 4 | sort -u >> {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_ID_HARD_commun.txt

        echo "Commun HARD vs SOFT passing ✔" >> {log}.out

        ##GET HARD not found in SOFT, sniffles, TrEMOLO
        touch {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_ID_HARD_commun.txt #if not exist
        touch {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TE_HARD_NOT_FOUND_IN_SOFT_sniffles_and_TrEMOLO.bed
        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_HARD_CLUSTER_100.bed && \
            grep -w -v -f {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_ID_HARD_commun.txt {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_HARD_CLUSTER_100.bed | grep -E "$chrom_keep" > {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TE_HARD_NOT_FOUND_IN_SOFT_sniffles_and_TrEMOLO.bed

        echo "   MERGE..." | tee -a {log}.out;

        rm -f {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed
        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_POSITION_TE_OUTSIDER_CLUSTER_100.bed && cat {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_POSITION_TE_OUTSIDER_CLUSTER_100.bed | grep -E "$chrom_keep" >> {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed
        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TE_TrEMOLO_NOT_FOUND_IN_sniffles.bed && cat {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TE_TrEMOLO_NOT_FOUND_IN_sniffles.bed | grep -E "$chrom_keep" >> {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed
        
        # test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_MERGE_TE_ALL.bed \
        #     && bedtools sort -i {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_MERGE_TE_ALL.bed \
        #     | bedtools cluster -d 100 | \
        #     awk '{{ split($4, sp, "|"); split(sp[2], sp_id, "."); print $0":"sp[1]":"sp_id[2]}}' | bedtools groupby -g 7 -c 1,2,3,4,5,6 -o first,first,first,first,first,first | cut -f 2- \
        #         > {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed
        
        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TE_SOFT_NOT_FOUND_IN_sniffles_and_TrEMOLO.bed && cat {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TE_SOFT_NOT_FOUND_IN_sniffles_and_TrEMOLO.bed | grep -E "$chrom_keep" >> {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed
        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TE_HARD_NOT_FOUND_IN_SOFT_sniffles_and_TrEMOLO.bed && cat {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TE_HARD_NOT_FOUND_IN_SOFT_sniffles_and_TrEMOLO.bed | grep -E "$chrom_keep" >> {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed

        
        echo "      NB TE sniffles    : `grep "sniffles" {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed -c`" | tee -a {log}.out
        echo "      NB TE TrEMOLO INS : `grep "TrEMOLO.INS" {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed -c`" | tee -a {log}.out
        echo "      NB TE SOFT        : `grep "SOFT" {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed -c`" | tee -a {log}.out
        echo "      NB TE HARD        : `grep "HARD" {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed -c`" | tee -a {log}.out
        echo "   NB TE MERGED : "`cat {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed | wc -l` | tee -a {log}.out;
        cp {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL2.bed
        cut -f 4 {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed | cut -d "|" -f 1 | sort | uniq -c | awk 'OFS="\t"{{print $1, $2}}' | sort -k 1 -n | awk 'BEGIN{{print "x\ty\tz"}} OFS="\t"{{print "", $2, $1}}' > {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL_COUNT.csv


        rm -f {params.work_directory}/POSITION_TE_OUTSIDER.bed
        ln -srf {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed {params.work_directory}/POSITION_TE_OUTSIDER.bed

        """


#END MERGE_TE




#
rule HARD_TE :
    input:
        read           = config["DATA"]["SAMPLE"],
        all_te         = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        fasta_TE       = config["DATA"]["TE_DB"],
        bam            = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/MAPPING/SAMPLE_mapping_GENOME_MD.sorted.bam",
        SOFT_all_te    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.csv",
        tr_vcf         = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/HARD/SV_HARD.tr_vcf",
    output:
        all_te    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.csv",
        bln       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD.bln",
        seqs      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD.fasta",
        
        bed       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.bed",

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        pars_bln_option        = config["PARAMS"]["OUTSIDER_VARIANT"]["PARS_BLN_OPTION"],
        call_sv                = config["CHOICE"]["OUTSIDER_VARIANT"]["CALL_SV"],
        CHROM_KEEP             = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["CHROM_KEEP"],
        GET_SEQ_REPORT_OPTION  = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["GET_SEQ_REPORT_OPTION"],
        threads                = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,


        #COLORS
        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

        step=0,

    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/HARD"


    shell:
        """
        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] DETECTION TE IN HARD READS [^-^] {params.cend}"

        mkdir -p {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD

        rm -f {log}.out {log}.err
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        ## CREATE VCF HARD
        echo "CREATE VCF HARD..."
        awk 'NR>1 {{print $5}}' {input.tr_vcf} | sort -u > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/ID.txt

        ## GET SEQUENCE HARD
        echo "GET SEQUENCE HARD...";

        #if [ ! -n "$TrEMOLO_SIZE_MAX_TE" ]; then
            TrEMOLO_SIZE_MAX_TE=`awk '{{ if(substr($0, 1, 1) != ">"){{ if( length($0)>max ){{ max=length($0) }} }} }} END{{print max}}' {input.fasta_TE}`
            TrEMOLO_SIZE_MAX_TE=$((TrEMOLO_SIZE_MAX_TE + 100));
        #fi;

        PATH=`echo $PATH | sed "s|${{SAMTOOLS_1_9}}|${{SAMTOOLS_1_15_1}}|g"`
        
        FT_GZ=`ls {input.read} | grep ".gz$" >/dev/null && echo 1 || echo 0`;

        if [ $FT_GZ -eq 0 ]; then 
            test -s {input.read}.fai || samtools fqidx {input.read} 2>> {log}.err
            samtools fqidx {input.read} --fai-idx {input.read}.fai -r {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/ID.txt > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/RS_HARD.fastq 2>> {log}.err
        else
            gunzip -c {input.read} > {params.work_directory}/INPUT/READS_UNCOMPRESS.fastq;
            samtools fqidx {params.work_directory}/INPUT/READS_UNCOMPRESS.fastq 2>> {log}.err
            samtools fqidx {params.work_directory}/INPUT/READS_UNCOMPRESS.fastq --fai-idx {params.work_directory}/INPUT/READS_UNCOMPRESS.fastq.fai -r {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/ID.txt > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/RS_HARD.fastq 2>> {log}.err
        
        fi;

        python3 ${{path_to_pipline}}/lib/python/format_files/fastq_to_fasta.py {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/RS_HARD.fastq {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/RS_HARD.fasta

        grep -n ">" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/RS_HARD.fasta | tr -d ">" > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/RS_HARD.fasta.fa_trml_idx

        python3 ${{path_to_pipline}}/lib/python/parsing/get_seq_hard.py -s "$TrEMOLO_SIZE_MAX_TE" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/RS_HARD.fasta.fa_trml_idx {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/RS_HARD.fasta {input.tr_vcf} > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD.bed

        ## Warning : WINDOW cluster fixed 100
        ## Warning : tab_head[1] for take start end first detected
        bedtools sort -i {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD.bed | bedtools cluster -d 100 | awk 'BEGIN{{count=0; id="";}}  OFS=":"{{if(id != $8){{ if(NR>1){{ for(i=1; i<count+1; i++){{print tab_head[1], count, "IMPRECISE", (i-1); print tab_seq[i]}} }}; id=$8; count=0; delete tab_head; delete tab_seq;}}else{{tab_head[count+1] = ">"$1":<HARD>:"$2":"$3":HARD."id"."$6; tab_seq[count+1] = $5; count+=1}} }}' > {output.seqs}

        ## BLAST TE
        echo "BLAST TE HARD..."
        makeblastdb -in {input.fasta_TE} -dbtype nucl 2> {log}.err;
        test -s {output.seqs} && \
            blastn -num_threads {params.threads} -db {input.fasta_TE} -query {output.seqs} -outfmt 6 -out {output.bln} 2>> {log}.err;

        ## PARSING
        test -s {output.bln} && \
            python3 ${{path_to_pipline}}/lib/python/parsing/parse_blast_main.py \
                {output.bln} \
                {input.fasta_TE} \
                {output.all_te} \
                {params.pars_bln_option} --combine_name {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/COMBINE_SV_HARD.csv -c -k "HARD"

        test -s {output.all_te} && \
            awk 'NR>1 {{print $2":"$1":"$5}}' {output.all_te} | awk -F ":" 'OFS="\t"{{print $1, $3, $4, $10"|"$5, $11, $9}}' > {output.bed}

        ###TEST NO HARD
        ##rm -f {output.all_te} {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/*.bed

        ## NO TE HARD FOUND
        if ! test -s {input.tr_vcf} || ! test -s {output.all_te} || ! test -s {output.bln} || ! test -s {output.seqs}; then
            warn_msg "[SNK--WARNING] NO TE HARD FOUND";
            touch {input.tr_vcf}
            touch {output.all_te}
            touch {output.bln}
            touch {output.seqs}
        fi;

        ##PATH=`echo $PATH | sed "s|${{SAMTOOLS_1_15_1}}|${{SAMTOOLS_1_9}}|g"`

        #** REMOVE **#
        #rm -f {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/ID*;
        #rm -f {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/SV_SOFT_TE_KEEP*;
        rm -f `find {params.work_directory} -name "*.fai"`
        rm -f {params.work_directory}/INPUT/READS_UNCOMPRESS.fastq*
        """


#END HARD_TE



#
rule SOFT_TE :
    input:
        all_te   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        fasta_TE = config["DATA"]["TE_DB"],
        bam      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/MAPPING/SAMPLE_mapping_GENOME_MD.sorted.bam",
        vcf       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.vcf",
    output:
        all_te    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.csv",
        bln       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.bln",
        seqs      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.fasta",
        
        bed       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.bed",
        sv_bed    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.bed",

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        pars_bln_option        = config["PARAMS"]["OUTSIDER_VARIANT"]["PARS_BLN_OPTION"],
        call_sv                = config["CHOICE"]["OUTSIDER_VARIANT"]["CALL_SV"],
        CHROM_KEEP             = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["CHROM_KEEP"],
        GET_SEQ_REPORT_OPTION  = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["GET_SEQ_REPORT_OPTION"],
        threads                = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,


        #COLORS
        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

        step=0,

    log:
        soft = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/SOFT"


    shell:
        """
        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] DETECTION TE IN SOFT READS [^-^] {params.cend}"

        mkdir -p {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT

        rm -f {log}.out {log}.err
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        ## CREATE VCF SOFT
        echo "CREATE VCF SOFT..."
        ###python3 ${{path_to_pipline}}/lib/python/parsing/find_soft.py {input.bam} > {input.vcf};

        ## GET SEQUENCE SOFT
        echo "GET SEQUENCE SOFT..."

        TrEMOLO_SIZE_MAX_TE=`awk '{{ if(substr($0, 1, 1) != ">"){{ if( length($0)>max ){{ max=length($0) }} }} }} END{{print max}}' {input.fasta_TE}`
        export TrEMOLO_SIZE_MAX_TE=$((TrEMOLO_SIZE_MAX_TE + 100));
        echo $TrEMOLO_SIZE_MAX_TE;

        ### GET SOFT SEQUENCE AND CUT SIZE
        ##cut size for less false (+)
        rm -f {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.bed
        awk -v max_size="$TrEMOLO_SIZE_MAX_TE" -v out_bed="{params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.bed" '{{
            split($4, spL, ";"); 
            split($5, spR, ";"); 
            split(spL[3], spLSEQ, "=");
            split(spR[3], spRSEQ, "=");
            

            split($6, spL_RS, "=");
            split($7, spR_RS, "=");

            NB_RS_LEFT  = split(spL_RS[2], spL_RS_READ, ",");
            NB_RS_RIGHT = split(spR_RS[2], spR_RS_READ, ",");

            if(spLSEQ[2] != "NONE"){{ 
                if(length(spLSEQ[2]) <= max_size){{
                    print ">"$1":<SOFT>:"$2":"$2+1":"$3".L:"NB_RS_LEFT":PRECISE:0\\n"spLSEQ[2];
                }}
                else{{
                    print ">"$1":<SOFT>:"$2":"$2+1":"$3".L:"NB_RS_LEFT":PRECISE:0\\n"substr(spLSEQ[2], length(spLSEQ[2])-max_size+1, max_size);
                }}
            }} 

            if(spRSEQ[2] != "NONE"){{
                if(length(spRSEQ[2]) <= max_size){{
                    print ">"$1":<SOFT>:"$2":"$2+1":"$3".R:"NB_RS_RIGHT":PRECISE:0\\n"spRSEQ[2];
                }}
                else {{
                    print ">"$1":<SOFT>:"$2":"$2+1":"$3".R:"NB_RS_RIGHT":PRECISE:0\\n"substr(spRSEQ[2], 1, max_size);
                }}
            }}

            print $1"\\t"$2"\\t"$2+1"\\t"$3":"(NB_RS_LEFT + NB_RS_RIGHT) >> out_bed

        }}' {input.vcf} | grep -v "^--" > {output.seqs};

        ## BLAST TE
        echo "BLAST TE SOFT BEST..."
        makeblastdb -in {input.fasta_TE} -dbtype nucl 2> {log.soft}.err;
        test -s {output.seqs} && \
            blastn -num_threads {params.threads} -db {input.fasta_TE} -query {output.seqs} -outfmt 6 -out {output.bln} 2>> {log.soft}.err || (echo "FAILDED" && exit 1);


        ## BIS FOR FREQUENCY
        echo "BLAST TE SOFT ALL..."
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.vcf.bis && \
            awk 'BEGIN{{ID=""; count=1;}} NR>1 && OFS=":"{{
                if ( $4 != ID ) {{
                    ID=$4; 
                    count=1;
                }} 
                print ">"$1, $2"-"$3, $4, $5, count, $6, $8, $9"\\n"$10; 
                count += 1;
            }}' {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.vcf.bis > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.fasta.bis


        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.fasta.bis && \
            blastn -num_threads {params.threads} -db {input.fasta_TE} \
            -query {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.fasta.bis \
            -outfmt 6 \
            -out {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.bln.bis 2>> {log.soft}.err;


        ## GET CANDIDATE TE
        echo "GET CANDIDATE TE SOFT..."
        number_lines_bln=`cat {output.bln} | wc -l`

        test -s {output.bln} && \
            python3 ${{path_to_pipline}}/lib/python/parsing/parse_blast_main.py \
                {output.bln} \
                {input.fasta_TE} \
                {output.all_te} \
                {params.pars_bln_option} --combine_name {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/COMBINE_SV_SOFT.csv -c -k "SOFT"

        test -s {output.all_te} && \
            awk 'NR>1 {{print $2":"$1}}' {output.all_te} | awk -F ":" 'OFS="\t"{{print $1, $3, $4, $10"|"$5}}' > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/TE_SOFT.bed

        test -s {output.all_te} && \
            awk 'NR>1 && OFS="\t"{{split($2, sp, ":"); print sp[1], sp[3], sp[4], $1"|"sp[5], $5, sp[9]}}' {output.all_te} > {output.bed}
        
        ###TEST NO SOFT
        ##rm -f {output.all_te} {output.bed} {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/TE_SOFT.bed

        ## NO TE SOFT FOUND
        if ! test -s {input.vcf} || ! test -s {output.all_te} || ! test -s {output.bln} || ! test -s {output.seqs}; then
            warn_msg "[SNK--WARNING] NO TE SOFT FOUND";
            touch {input.vcf}
            touch {output.all_te}
            touch {output.bln}
            touch {output.seqs}
        fi;

        #** REMOVE **#
        #rm -f {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/ID*;
        #rm -f {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT_TE_KEEP*;
        rm -f `find {params.work_directory} -name "*.fai"`
        """


#END SOFT_TE


#BLAST database of TE against SV (Structural variant)
rule DETECTION_TE :
    input:
        bed      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.bed",
        vcf      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/VARIANT_CALLING/SV.vcf",
        fasta_TE = config["DATA"]["TE_DB"],
        bam      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/MAPPING/SAMPLE_mapping_GENOME_MD.sorted.bam",

    output:
        sniffles_TE_bed  = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/POSITION_START_TE.bed",
        snif_seqs = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/VARIANT_CALLING/SEQUENCE_INDEL.fasta",
        bln       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/BLAST_SEQUENCE_INDEL_vs_DBTE.bln",
        all_te    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        preset_view    = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_VIEW"]["PRESET_OPTION"]) + " --threads " + str(config["PARAMS"]["THREADS"]),
        preset_sort    = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_SORT"]["PRESET_OPTION"]) + " --threads " + str(config["PARAMS"]["THREADS"]),
        preset_callmd  = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_CALLMD"]["PRESET_OPTION"]) + " --threads " + str(config["PARAMS"]["THREADS"]),

        call_sv                = config["CHOICE"]["OUTSIDER_VARIANT"]["CALL_SV"],
        CHROM_KEEP             = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["CHROM_KEEP"],
        pars_bln_option        = config["PARAMS"]["OUTSIDER_VARIANT"]["PARS_BLN_OPTION"],
        GET_SEQ_REPORT_OPTION  = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["GET_SEQ_REPORT_OPTION"],
        threads                = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,


        #COLORS
        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

        step=0,

    log:
        DETECTION = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/DETECTION_TE"


    shell:
        """
        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] DETECTION TE [^-^] {params.cend}"

        mkdir -p {params.work_directory}/OUTSIDER/TE_DETECTION/

        rm -f {log}.out {log}.err
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt


        #** GET SEQUENCE REPORT **#
        echo "   GET SEQUENCE REPORT..." | tee {log}.err {log}.log
        printf "%s\\n" "{params.cmess} [SNK]--[`date`] GET SEQUENCE VARIANT [^-^] {params.cend}"
        python3 ${{path_to_pipline}}/lib/python/parsing/get_seq_vcf.py {params.GET_SEQ_REPORT_OPTION} -c '{params.CHROM_KEEP}' {input.vcf} {output.snif_seqs} 2>> {log.DETECTION}.err ;
        test -s {output.snif_seqs} || (fail_msg "ERROR NO SEQUENCE SV FOUND" && exit 1)
        echo "   GET SEQUENCE REPORT ✔"
        version_vcf=`grep fileformat {input.vcf} | cut -d "=" -f 2`

        #TODO: GET RS VIA TrEMOLO INS
        #GET ALL SEQUENCE OF READ SUPPORT FOR SNIFFLES
        echo "GET ALL SEQUENCE OF READ SUPPORT FOR SNIFFLES..."
        if [ "$version_vcf" = "VCFv4.1" ] || [ "$version_vcf" = "VCFv4.2" ] || [ "$version_vcf" = "VCFv4.3" ]; then
            #echo "SNIFFLES"
            awk 'OFS="\t"{{ if(substr($0, 1, 1) == ">"){{ split($0, sp, ":"); header=""substr(sp[1], 2, 500)"\t"sp[3]"\t"sp[4]"\t"substr($0, 2, 500); }}else{{ header=header"\t"length($0)"\t"$0; print header}} }}' \
                {output.snif_seqs} | grep -w -E "INS|DEL" > {params.work_directory}/OUTSIDER/TE_DETECTION/TE_VR.bed

            python3 ${{path_to_pipline}}/lib/python/parsing/parse_bam_found_ins.py -r {params.work_directory}/OUTSIDER/TE_DETECTION/RD_NUMBER.txt {input.bam} \
                {params.work_directory}/OUTSIDER/TE_DETECTION/TE_VR.bed > {output.snif_seqs} 2>> {log.DETECTION}.err

            ##SIZE OF EACH SV sniffles
            awk ' 
                /^>/ {{ head=substr($0, 2, length($0)); }} 
                /^[^>]/ && OFS="\t" {{ print head, length($0); }}' \
                    {output.snif_seqs} >> {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_SIZE.tsv
        else
            fail_msg "Vesrion of VCF must be 'VCFv4.1', 'VCFv4.2' or 'VCFv4.3' " && exit 2
        fi;
        

        printf "%s\\n" "{params.cmess} [SNK]--[`date`] BLAST SV TO TE [^-^] {params.cend}" | tee {log}.err {log}.log
        
        #** BLAST SEQUENCE VCF on DATABASE TE **#
        echo "   BLAST SEQUENCE SV on DATABASE TE..." | tee {log}.err {log}.log
        makeblastdb -in {input.fasta_TE} -dbtype nucl 2> {log.DETECTION}.err;
        blastn -num_threads {params.threads} -db {input.fasta_TE} -query {output.snif_seqs} -outfmt 6 -out {output.bln} 2>> {log.DETECTION}.err;
        
        printf "%s\\n" "{params.cmess} [SNK]--[`date`] BLAST DONE CHECK logfile => {log.DETECTION} {params.cend}" | tee {log}.err {log}.log

        printf "%s\\n" "{params.cmess} [SNK]--[`date`] FILTER TE BLAST [^-^] {params.cend}" | tee {log}.err {log}.log
        
        #** FILTER TE BLAST **#
        echo "   FILTER TE BLAST..." | tee {log}.err {log}.log

        python3 ${{path_to_pipline}}/lib/python/parsing/parse_blast_main.py {output.bln} \
            {input.fasta_TE} \
            {output.all_te} -c \
            --combine_name {params.work_directory}/OUTSIDER/TE_DETECTION/COMBINE_TE.csv {params.pars_bln_option} 2>> {log.DETECTION}.err;
        
        awk 'NR>1 {{print $2":"$1":"$5}}' {output.all_te} | awk -F ":" 'OFS="\t"{{print $1, $3, ($3>=$4 ? $3+1 : $4), $10"|"$5, $11, $9}}' | bedtools sort > {params.work_directory}/OUTSIDER/TE_DETECTION/POSITION_START_TE.bed

        if [ `cat {output.all_te} | wc -l` -eq 1 ]; then
            fail_msg "ERROR EXIT PIPELINE BECAUSE NO TE FOUND\\n";
            exit 3;
        fi;

        echo "COUNT TE IN RS..."
        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/COMBINE_TE.csv && \
            awk 'NR>1 {{ split($2, sp, ":"); if(sp[2] == "<INS>"){{ print sp[5]; }} }}' {params.work_directory}/OUTSIDER/TE_DETECTION/COMBINE_TE.csv \
                > {params.work_directory}/OUTSIDER/TE_DETECTION/ID.txt || fail_msg "COMBINE TE FILE ERROR\\n";

        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/ID.txt && \
            test -s {output.bln} && \
            grep -w -f {params.work_directory}/OUTSIDER/TE_DETECTION/ID.txt {output.bln} \
                | awk '{{print $1":"$2}}'  | sort -u | \
                awk -F ":" '{{ print $5":"$9}}' | sort | uniq -c | awk 'OFS="\t"{{print $2, $1}}' \
                > {params.work_directory}/OUTSIDER/TE_DETECTION/COUNT_TE_IN_RS.txt || \
                fail_msg "ERROR COUNT TE IN READ SUPPORT\\n";

        #** REMOVE **#
        rm -f `find {params.work_directory} -name "*.fai"`
        """

#END DETECTION_TE



rule TrEMOLO_SV_TE :
    input:
        sv       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/VARIANT_CALLING/SV.vcf",
        bam      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/MAPPING/SAMPLE_mapping_GENOME_MD.sorted.bam",
        fasta_TE = config["DATA"]["TE_DB"],
        
    output:
        SV_CLUST_seq     = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.fasta",
        SV_INS_CLUST_bln = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.bln",
        INS_TREMOLO_csv  = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv",
        INS_TREMOLO_bed  = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.bed",
        hard_vcf         = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/HARD/SV_HARD.tr_vcf",
        soft_vcf         = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.vcf",
        soft_te          = [config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.bed", config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.bed"] if not config["CHOICE"]["OUTSIDER_VARIANT"]["CLIPPED_READS"] else [],
    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        CLIPPED_READS   = config["CHOICE"]["OUTSIDER_VARIANT"]["CLIPPED_READS"],
        SIZE_FLANK      = config["PARAMS"]["OUTSIDER_VARIANT"]["TSD"]["SIZE_FLANK"],

        pars_bln_option = config["PARAMS"]["OUTSIDER_VARIANT"]["PARS_BLN_OPTION"],
        threads         = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,

        env            = env, #source environnement

        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

        step=0,

    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/TrEMOLO_SV_TE",

    shell:
        """
        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        mkdir -p {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/
        mkdir -p {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/
        mkdir -p {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] GET INSERTION TrEMOLO [^-^] {params.cend}"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        rm -f {log}.out {log}.err
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        samtools index {input.bam} 2> {log}.err

        echo "GET INSERTION..."
        ###python3 ${{path_to_pipline}}/lib/python/parsing/find_all_ins.py {input.bam} > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS.bed 2>> {log}.err
        python3 ${{path_to_pipline}}/lib/python/parsing/find_all_type_ins.py {input.bam} \
            --output-seq-tsd {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_FOR_TSD.txt \
            -f {params.SIZE_FLANK} \
            --output-soft {output.soft_vcf} \
            --output-hard {output.hard_vcf} \
            --output-ins {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS.bed 2>> {log}.err

        ! test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS.bed && fail_msg "[{rule}] ERROR : NO INSERTION FOUND\\n" && exit 5;

        bedtools sort -i {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS.bed | bedtools cluster -d 50 > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.bed 2>> {log}.err;

        echo "   NB INSERTION FOUND : `tail -n 1 {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.bed | cut -f 6`"

        rm -f {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/RD_NUMBER.txt;
        touch {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/RD_NUMBER.txt;
        awk -v FILE_RD_NUM="{params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/RD_NUMBER.txt" '
            BEGIN{{
                clust = 0;
            }}

            {{
                if(clust == 0){{
                    chrom=$1; 
                    start=$2; 
                    end=$3;
                    clust=$NF;
                    
                    dic_clust[clust][1]["header"]  = ">"chrom":<INS>:"start":"end":TrEMOLO.INS."clust;
                    dic_clust[clust][1]["seq"]     = $5;
                    dic_clust[clust][1]["RS"]      = 1;
                    dic_clust[clust][1]["READ"]    = $4;
                }}
                else if(clust != 0 && clust != $NF){{
                    chrom=$1; 
                    start=$2; 
                    end=$3;
                    
                    for(i=1; i <= dic_clust[clust][1]["RS"]; i++){{
                        print dic_clust[clust][i]["header"]":"dic_clust[clust][1]["RS"]":IMPRECISE:"i;
                        print dic_clust[clust][i]["seq"];
                    }}

                    clust=$NF;

                    dic_clust[clust][1]["header"]  = ">"chrom":<INS>:"start":"end":TrEMOLO.INS."clust;
                    dic_clust[clust][1]["seq"]     = $5;
                    dic_clust[clust][1]["RS"]      = 1;
                    dic_clust[clust][1]["READ"]    = $4;

                    ##$7=pos in read; $8=size seq;
                    print chrom":<INS>:"start":"end":TrEMOLO.INS."clust":1:"dic_clust[clust][1]["READ"]":"$7":"$8":"($7+$8) >> FILE_RD_NUM;

                }}
                else{{
                    #CHECK READ EXIST
                    IN = 0;
                    for(i=1; i <= dic_clust[clust][1]["RS"]; i++){{
                        if(dic_clust[clust][i]["READ"] == $4){{
                            IN = 1;
                            i = dic_clust[clust][1]["RS"] + 1;
                        }}
                    }}

                    if(IN == 0){{
                        
                        dic_clust[clust][1]["RS"] += 1;
                        dic_clust[clust][dic_clust[clust][1]["RS"]]["READ"]    = $4;
                        dic_clust[clust][dic_clust[clust][1]["RS"]]["header"]  = ">"chrom":<INS>:"start":"end":TrEMOLO.INS."clust;
                        dic_clust[clust][dic_clust[clust][1]["RS"]]["seq"]     = $5;
                        ##$8=pos in read; $9=size seq;
                        print chrom":<INS>:"start":"end":TrEMOLO.INS."clust":"dic_clust[clust][1]["RS"]":"dic_clust[clust][dic_clust[clust][1]["RS"]]["READ"]":"$7":"$8":"($7+$8) >> FILE_RD_NUM;
                    }}
                    
                }} 
            }}' {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.bed > {output.SV_CLUST_seq}

        ##SIZE OF EACH SV
        awk ' 
            /^>/ {{ head=substr($0, 2, length($0)); }} 
            /^[^>]/ && OFS="\t" {{ print head, length($0); }}' \
                {output.SV_CLUST_seq} > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_SIZE.tsv

        echo "BLAST TE INSERTION..."
        makeblastdb -in {input.fasta_TE} -dbtype nucl
        echo
        blastn -num_threads {params.threads} -db {input.fasta_TE} -query {output.SV_CLUST_seq} -outfmt 6 -out {output.SV_INS_CLUST_bln}
         
        echo "GETTING TRUE TE INTO INSERTION..."
        python3 ${{path_to_pipline}}/lib/python/parsing/parse_blast_main.py \
              {output.SV_INS_CLUST_bln} \
              {input.fasta_TE} \
              {output.INS_TREMOLO_csv} \
              --combine_name {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/COMBINE_INS_TREMOLO.csv -c {params.pars_bln_option} 2>> {log}.err 

        awk 'NR>1 && OFS="\t" {{ split($2, sp, ":"); print sp[1], sp[3], sp[3]+1, $1"|"sp[5], $5, sp[9] }}' {output.INS_TREMOLO_csv} > {output.INS_TREMOLO_bed}

        ###COUNT TE IN RS
        echo "COUNT TE IN RS..."
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/COMBINE_INS_TREMOLO.csv && \
            awk 'NR>1 {{ split($2, sp, ":"); if(sp[2] == "<INS>"){{ print sp[5]; }} }}' {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/COMBINE_INS_TREMOLO.csv \
                > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/ID.txt || fail_msg "COMBINE TE FILE ERROR\\n";

        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/ID.txt && \
            test -s {output.SV_INS_CLUST_bln} && \
            grep -w -f {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/ID.txt {output.SV_INS_CLUST_bln} \
                | awk '{{print $1":"$2}}'  | sort -u | \
                awk -F ":" '{{ print $5":"$9}}' | sort | uniq -c | awk 'OFS="\t"{{print $2, $1}}' \
                > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/COUNT_TE_IN_RS.txt || \
                fail_msg "ERROR COUNT TE IN READ SUPPORT\\n";

        ####CLIPPED
        if [ {params.CLIPPED_READS} = "False" ]; then
            touch {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.bed
            touch {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.csv
            touch {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.bed
        fi;
            

        """

#END TrEMOLO_SV_TE




#Get Strucural Variant (vcf file)
rule svim :
    input:
        genome = config["DATA"]["GENOME"],
        bam    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/MAPPING/SAMPLE_mapping_GENOME_MD.sorted.bam",

    output:
        svim   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/VARIANT_CALLING/SVIM_RESULT/variants.vcf", 
        sv     = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/VARIANT_CALLING/SV.vcf",
        
    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        #COLORS
        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

        step=0,

    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/svim"


    shell:
        """
        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] SVIM DETECTION VARIANT [^-^] {params.cend}"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        rm -f {log}.out {log}.err
        echo "[`date`] LOG TASK {log}.out, {log}.err"


        samtools index {input.bam} 2> {log}.err

        # svim alignment --read_names \
        #      --insertion_sequences \
        #      --minimum_depth 1 {params.work_directory}/OUTSIDER/VARIANT_CALLING/SVIM_RESULT {input.bam} {input.genome} 2> {log}.err

        ##printf "%s\\n" "{params.cmess} [SNK]--[`date`] SVIM DONE CHECK log file : {log}.err, {log}.out {params.cend}"

        begin_load `cat {params.work_directory}/.pid`
        #kill -10 `cat {params.work_directory}/.pid` || echo
        run_cmd "svim alignment --read_names --insertion_sequences --minimum_depth 1 {params.work_directory}/OUTSIDER/VARIANT_CALLING/SVIM_RESULT {input.bam} {input.genome}" "{log}" "SVIM" "False";
        end_load
        sleep 1

        cp {output.svim} {output.sv}

        """

#END svim



#Get Strucural Variant (vcf file)
rule sniffles :
    input:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/MAPPING/SAMPLE_mapping_GENOME_MD.sorted.bam",

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/VARIANT_CALLING/SV.vcf", 
        
    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

        step=0,

    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/sniffles",

    shell:
        """

        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        mkdir -p {params.work_directory}/OUTSIDER/VARIANT_CALLING/

        rm -f {log}*
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] SNIFFLES [^-^] {params.cend}"

        samtools index {input} 2> {log}.err

        #sniffles --report-seq -s 1 -m {input} -v {output} -n -1 2> {log}.err;
        
        version=`sniffles -h 2>&1 | grep Version | cut -d " " -f 2`

        ## version work
        if [ "$version" = "1.0.10" ]; then

            begin_load `cat {params.work_directory}/.pid`
            #kill -10 `cat {params.work_directory}/.pid` || echo
            run_cmd "sniffles --report_seq -s 1 -m {input} -v {output} -n -1" "{log}" "SNIFFLES 1.0.10" "False";
            end_load
            sleep 1

        elif [ "$version" = "1.0.12" ] || [ "$version" = "1.0.11" ]; then

            begin_load `cat {params.work_directory}/.pid`
            #kill -10 `cat {params.work_directory}/.pid` || echo
            run_cmd "sniffles --report-seq -s 1 -m {input} -v {output} -n -1" "{log}" "SNIFFLES $version" "False";
            end_load
            sleep 1

        else
            fail_msg "[SNK] -- [`date`] -- [ERROR] version $version YOU HAVE NOT THE GOOD VERSION OF SNIFFLES, PLEASE GET VERSION 1.0.10, 1.0.11 or 1.0.12"
            exit 2
        fi;


        """

#END sniffles


#Sort and callmd
rule samtools :
    input:
        sam    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/MAPPING/SAMPLE_mapping_GENOME.sam",
        genome = config["DATA"]["GENOME"],

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/MAPPING/SAMPLE_mapping_GENOME_MD.sorted.bam",
        
    params:
        #DATA
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),
        
        env            = env, #source environnement
        path_snk       = path_snk,
        threads        = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,
        
        #PARAMS
        preset_view    = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_VIEW"]["PRESET_OPTION"])   + " --threads " + str(config["PARAMS"]["THREADS"]),
        preset_sort    = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_SORT"]["PRESET_OPTION"])   + " --threads " + str(config["PARAMS"]["THREADS"]),
        preset_callmd  = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_CALLMD"]["PRESET_OPTION"]) + " --threads " + str(config["PARAMS"]["THREADS"]),
        
        #COLORS
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/samtools",

    shell:
        """
        {params.env}
        path_to_pipline=`dirname {params.path_snk}`
                
        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] SAMTOOLS [^-^] {params.cend}"

        mkdir -p {params.work_directory}/OUTSIDER/MAPPING/

        echo "[`date`] LOG TASK {log}.err"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        FLAG_EXLUDE=`(echo {params.preset_view} | grep -E "\-F [0-9]+" > /dev/null && echo "") || echo "-F 4"`
        echo "FLAG_EXLUDE : $FLAG_EXLUDE";

        echo "---view---" | tee {log}.out
        #samtools view -h {params.preset_view} -F 4 -b {input.sam} > {input.sam}.bam 2>> {log}.err;
        run_cmd "samtools view -h {params.preset_view} $FLAG_EXLUDE -b {input.sam} -o {input.sam}.bam" "{log}" "SAMTOOLS_VIEW" "False";

        rm -f {log}.out

        echo "---sort---" | tee -a {log}.out
        #samtools sort {params.preset_sort} {input.sam}.bam -o {input.sam}.sorted.bam 2>> {log}.err;
        run_cmd "samtools sort {params.preset_sort} {input.sam}.bam -o {input.sam}.sorted.bam" "{log}" "SAMTOOLS_SORT" "False";

        echo "---calmd---" | tee -a {log}.out
        #samtools calmd {params.preset_callmd} -b {input.sam}.sorted.bam {input.genome} > {output} 2>> {log}.err; #CALL MD for sniffles
        run_cmd "samtools calmd {params.preset_callmd} -b {input.sam}.sorted.bam {input.genome} | tee {output}" "{log}" "SAMTOOLS_CALLMD" "False";#CALL MD for sniffles

        echo "---stats---" | tee -a {log}.out
        #samtools stats {input.sam}.sorted.bam | grep "^SN" > {params.work_directory}/OUTSIDER/MAPPING/stats.txt 2>> {log}.err; #CALL MD for sniffles
        run_cmd "samtools stats -@ {params.threads} {input.sam} | grep "^SN" | cut -f 2-6 | tee {params.work_directory}/OUTSIDER/MAPPING/stats.txt" "{log}" "SAMTOOLS_STATS" "False";#STATS MAPPING

        # rm -f {input.sam} \
        #     {input.sam}.bam \
        #     {input.sam}.sorted.bam*;
        rm -f {log}.out;

        """


#END samtools




#Map reads on assembly genome
rule mapping :
    input:  
        read   = config["DATA"]["SAMPLE"],
        genome = config["DATA"]["GENOME"],

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/MAPPING/SAMPLE_mapping_GENOME.sam",
    
    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),
        config         = json.dumps(config),

        preset         = config["PARAMS"]["OUTSIDER_VARIANT"]["MINIMAP2"]["PRESET_OPTION"] if config["PARAMS"]["OUTSIDER_VARIANT"]["MINIMAP2"]["PRESET_OPTION"] != "" else "map-ont",
        option         = re.sub("-t [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["MINIMAP2"]["OPTION"]) + " -t " + str(config["PARAMS"]["THREADS"]),

        env            = env, #source environnement


        #COLOR 
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/minimap2"

    shell:
        """
        {params.env};
        path_to_pipline=`dirname {params.path_snk}`

        rm -f `find {params.work_directory} -name "*.fa*.fai"`

        mkdir -p {params.work_directory}/OUTSIDER/MAPPING/

        rm -f {log}*

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] MINIMAP2 MAPPING {params.cend}"
        
        #INDEX
        #minimap2 -x  {params.preset} -d {input.genome}.mmi {input.genome} 2> {log}.err;
        run_cmd "minimap2 -x {params.preset} -d {input.genome}.mmi {input.genome}" "{log}" "MINIMAP2_INDEX" "False" ;

        #MAPPING
        #minimap2 -ax {params.preset} {params.option} {input.genome} {input.read} > {output} 2>> {log}.err;
        
        begin_load `cat {params.work_directory}/.pid`
            #kill -10 `cat {params.work_directory}/.pid` || echo
            run_cmd "minimap2 -ax {params.preset} {params.option} {input.genome} {input.read} | tee {output}" "{log}" "MINIMAP2" "False"; 
        end_load
        sleep 1

        test -s {output} || ( fail_msg "ERROR : MAPPING FAILED\\n" && exit 2 )

        rm -f {log}.out
        """


#END mapping



####
####
############# INSIDER VARIANT
####
####




rule TE_ALL_IN_ASSEMBLY:
    input:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/TSD/TSD_TE.tsv",
        csv      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/TE_DETECTION/INSERTION.csv",
        query    = config["DATA"]["GENOME"],
        fasta_TE = config["DATA"]["TE_DB"],

    output:
        csv = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/TE_DETECTION/ALL_TE.csv",
        bed = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/TE_DETECTION/POSITION_ALL_TE.bed",
        tmp = output_link=[],

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env,

        pars_bln_option_insider = config["PARAMS"]["INSIDER_VARIANT"]["PARS_BLN_OPTION"],

        CHROM_KEEP     = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["CHROM_KEEP"],
        threads        = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,


        
        #COLOR 
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/TE_ALL_IN_ASSEMBLY",

    shell:
        """
        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] GET ALL TE IN ASSEMBLY {params.cend}"

        {params.env}
        path_to_pipline=`dirname {params.path_snk}`
        
        mkdir -p {params.work_directory}/INSIDER/TE_DETECTION/

        rm -f {log}.out {log}.err

        echo "[`date`] LOG TASK {log}.out, {log}.err"

        echo "[`date`] STEP {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        ## SEARCH ALL REGION TE WITH BLAST
        echo "  SEARCH ALL REGION TE ON GENOME..."
        makeblastdb -in {input.fasta_TE} -dbtype nucl  2> {log}.err 1> {log}.out;
        blastn -num_threads {params.threads} -db {input.fasta_TE} \
            -query {input.query} \
            -outfmt 6 \
            -out {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_1.bln 2>> {log}.err 1>> {log}.out;

        chrom_keep=`echo "{params.CHROM_KEEP}" | tr "," "|"`

        ## BUILD SEQUENCE CANDIDATE TE
        echo "  BUILD SEQUENCE CANDIDATE TE..."
        cut -f 1,7,8 {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_1.bln | grep -E "$chrom_keep" > {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_1.bed
        bedtools sort -i {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_1.bed | bedtools merge -d 100 | bedtools cluster > {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_1_merge_cluster.bed 
        bedtools getfasta -fi {input.query} -bed {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_1_merge_cluster.bed -name+ > {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_1_merge_cluster.fasta
        
        ## BLAST ALL REGION CANDIDATE OF TE
        echo "  BLAST ALL REGION CANDIDATE OF TE..."
        blastn -num_threads {params.threads} -db {input.fasta_TE} \
            -query {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_1_merge_cluster.fasta \
            -outfmt 6 \
            -out {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_2.bln 2>> {log}.err 1>> {log}.out;

        ## GETTING TE
        echo "  GETTING TE..."

        number_lines_bln=`cat {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_2.bln | wc -l`
        if [ "$number_lines_bln" -gt 100000  ]; then
            awk 'BEGIN{{qseqid=""; sseqid=""}}{{if(qseqid!=$1){{qseqid=$1; sseqid=$2; print $0;}}else if(sseqid==$2){{print $0}}}}' {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_2.bln \
                > {params.work_directory}/INSIDER/TE_DETECTION/tmp_pre_filtre.bln

            test -s {params.work_directory}/INSIDER/TE_DETECTION/tmp_pre_filtre.bln  && \
              python3 ${{path_to_pipline}}/lib/python/parsing/global_sv.py {params.pars_bln_option_insider} \
                --combine_name {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_COMBINE_TE.csv \
                {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_2.bln  \
                {input.fasta_TE} \
                {output.csv}

        else
            test -s {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_2.bln  && \
              python3 ${{path_to_pipline}}/lib/python/parsing/global_sv.py {params.pars_bln_option_insider} \
                --combine_name {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_COMBINE_TE.csv \
                {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_2.bln  \
                {input.fasta_TE} \
                {output.csv}
        fi;

        awk 'NR>1 && OFS="\t"{{ split($2, sp1, ":"); split(sp1[4], sp2, "-"); print sp1[3], sp2[1], sp2[2], $1"|"sp1[1] }}' {output.csv} > {output.bed}
        ln -s -r -f {output.bed} {params.work_directory}/`basename {output.bed}`

        rm -f {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_1*
        rm -f {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_2*
        """


#END TE_ALL_IN_ASSEMBLY

rule TSD_INSIDER :
    input:
        query   = config["DATA"]["GENOME"],
        bed     = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/TE_DETECTION/INSERTION_TE.bed",

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/TSD/TSD_TE.tsv",
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/TSD/FK_INS_FT.bed",
        tmp = output_link=[],

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement
        threads        = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,

        #TSD
        SIZE_FLANK       = config["PARAMS"]["OUTSIDER_VARIANT"]["TSD"]["SIZE_FLANK"],

        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/TSD_INSIDER",

    shell:
        """
        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] <<< TSD INSIDER >>> {params.cend}"

        echo "[`date`] STEP TSD_INSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        rm -f {log}.*
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        mkdir -p {params.work_directory}/INSIDER/TSD ;

        echo "GET FK SEQ TE..."
        awk -v sizeFlank="{params.SIZE_FLANK}" '
            OFS="\t" {{
                print $1, $2-sizeFlank, $2, ($3-$2)":"$4":FK_L"; 
                print $1, $3, $3+sizeFlank, ($3-$2)":"$4":FK_R";
            }}' {input.bed} > {params.work_directory}/INSIDER/TSD/FK_INS.bed

        echo "FORMAT FK SEQ TE.."
        bedtools getfasta -tab -fi {input.query} -bed {params.work_directory}/INSIDER/TSD/FK_INS.bed -name+ | \
            awk -v size_flank="{params.SIZE_FLANK}" '
                NR%2==1 {{
                    split($1, sp, ":"); 
                    info=sp[2];

                    split(info, sp2, "|"); 
                    TE=sp2[1];
                    ID=sp2[2];

                    seqL=$2;
                    infos=sp[1]":"sp[5]":"sp[6]":"sp[2];
                }}
                        
                #FK_R
                NR%2==0 && OFS="\t" {{
                    print infos, TE, ID, substr(seqL, length(seqL)-size_flank, length(seqL)), substr($2, 1, size_flank), ".", ".";
                }}

                ' > {params.work_directory}/INSIDER/TSD/FK_INS_FT.bed;

        echo "GET TSD INSIDER..."
        python3 ${{path_to_pipline}}/lib/python/TSD/getTSDgenome.py -t {params.threads} \
            {params.work_directory}/INSIDER/TSD/FK_INS_FT.bed \
            {params.work_directory}/INSIDER/TSD/TSD_TE.tsv \
                1>> {log}.out 2>> {log}.err | tee -a {log}.out \
                || warn_msg "WARNING : FAIL GET TSD OUTSIDER ✘\\n" | tee -a {log}.err ; 

        echo "TSD INSIDER DONE !"
        """

#END TSD_INSIDER

rule TE_INSIDER:
    input:  
        ref      = config["DATA"]["REFERENCE"],
        query    = config["DATA"]["GENOME"],
        sam      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/VARIANT_CALLING/pm_against_ref.sam",
        delta    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/VARIANT_CALLING/pm_against_ref.sam.delta",
        bed      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/VARIANT_CALLING/assemblytics_out.Assemblytics_structural_variants.bed",
        stats    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/VARIANT_CALLING/assemblytics_out.Assemblytics_assembly_stats.txt",

        fasta_TE = config["DATA"]["TE_DB"],


    output:
        csv = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/TE_DETECTION/INSERTION.csv",
        bed = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/TE_DETECTION/INSERTION_TE.bed",

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env,

        pars_bln_option_insider = config["PARAMS"]["INSIDER_VARIANT"]["PARS_BLN_OPTION"],
        threads                 = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,
        
        #COLOR 
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,


        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/TE_INSIDER",

    shell:
        """

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] GET TE INSIDER {params.cend}"

        echo "[`date`] STEP INSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        {params.env}
        path_to_pipline=`dirname {params.path_snk}`
        
        mkdir -p {params.work_directory}/INSIDER/TE_DETECTION/

        rm -f {log}.log {log}.err

        echo "[`date`] LOG TASK {log}.out, {log}.err"

        #echo "GET SEQUENCE SV"
        #GET SEQUENCE SV
        ## GET SEQUENCE SV INSERTION
        rm -f {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_SEQ_ALL.fasta
        array_type=( "INSERTION" "Repeat_expansion" "Tandem_expansion" );
        for type in "${{array_type[@]}}"
        do
            grep -i $type {input.bed} | awk '{{print $10":"$4}}' | awk -v type="$type" -F ":" 'OFS="\t"{{split($2, a, "-"); print $1 , a[1], a[2], $4":"$3":"type}}' > {params.work_directory}/INSIDER/TE_DETECTION/${{type}}.bed || echo "$type NOT FOUND"
            
            test -s {params.work_directory}/INSIDER/TE_DETECTION/${{type}}.bed && \
                ( bedtools getfasta -fi {input.query} -bed {params.work_directory}/INSIDER/TE_DETECTION/${{type}}.bed -name+ > {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_SEQ.fasta && \
                cat {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_SEQ.fasta >> {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_SEQ_ALL.fasta ) || ( echo "$type is EMPTY" && touch {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_SEQ.fasta && touch {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_SEQ_ALL.fasta )
        done;

        #cat {params.work_directory}/INSIDER/TE_DETECTION/Tandem_expansion_SEQ.fasta {params.work_directory}/INSIDER/TE_DETECTION/Repeat_expansion_SEQ.fasta {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_SEQ.fasta > {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_SEQ_ALL.fasta
        cat {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_SEQ_ALL.fasta > {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_SEQ.fasta

        #echo "GET SEQUENCE SV DELETION"
        ## GET SEQUENCE SV DELETION
        rm -f {params.work_directory}/INSIDER/TE_DETECTION/DELETION_SEQ_ALL.fasta
        array_type_deletion=( "DELETION" "Repeat_contraction" "Tandem_contraction" );
        for type in "${{array_type_deletion[@]}}"
        do

            grep -i ${{type}}  {input.bed} | awk  -v type="$type" 'OFS="\t"{{print $1, $2, $3, $4":"$6":"type}}' > {params.work_directory}/INSIDER/TE_DETECTION/${{type}}.bed || echo "$type NOT FOUND"

            #Warning : touch SEQ
            test -s {params.work_directory}/INSIDER/TE_DETECTION/${{type}}.bed && \
                ( bedtools getfasta -fi {input.ref}  -bed {params.work_directory}/INSIDER/TE_DETECTION/${{type}}.bed -name+ > {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_SEQ.fasta && \
                cat {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_SEQ.fasta >> {params.work_directory}/INSIDER/TE_DETECTION/DELETION_SEQ_ALL.fasta ) || ( echo "$type is EMPTY" && touch {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_SEQ.fasta && touch {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_SEQ_ALL.fasta )

        done;

        #cat {params.work_directory}/INSIDER/TE_DETECTION/Tandem_contraction_SEQ.fasta {params.work_directory}/INSIDER/TE_DETECTION/Repeat_contraction_SEQ.fasta {params.work_directory}/INSIDER/TE_DETECTION/DELETION_SEQ.fasta > {params.work_directory}/INSIDER/TE_DETECTION/DELETION_SEQ_ALL.fasta
        cat {params.work_directory}/INSIDER/TE_DETECTION/DELETION_SEQ_ALL.fasta > {params.work_directory}/INSIDER/TE_DETECTION/DELETION_SEQ.fasta


        #echo "GET TE IN SV"
        # GET TE IN SV
        array_type=( "INSERTION" "Repeat_expansion" "Tandem_expansion" "DELETION" "Repeat_contraction" "Tandem_contraction" )
        for type in "${{array_type[@]}}"
        do
            echo "TYPE : $type";

            if test -s {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_SEQ.fasta ; then

                echo "   Checking TE candidate..."
                makeblastdb -in {input.fasta_TE} -dbtype nucl  2> {log}.err 1> {log}.out;
                blastn -num_threads {params.threads} -db {input.fasta_TE} \
                    -query {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_SEQ.fasta \
                    -outfmt 6 \
                    -out {params.work_directory}/INSIDER/TE_DETECTION/${{type}}.bln 2> {log}.err 1> {log}.out;
                

                echo "   Getting TE..."
                test -s {params.work_directory}/INSIDER/TE_DETECTION/${{type}}.bln && \
                    python3 ${{path_to_pipline}}/lib/python/parsing/global_sv.py {params.pars_bln_option_insider} \
                        --combine_name {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_COMBINE_TE.csv \
                        {params.work_directory}/INSIDER/TE_DETECTION/${{type}}.bln \
                        {input.fasta_TE} \
                        {params.work_directory}/INSIDER/TE_DETECTION/${{type}}.csv 2>> {log}.err 1>> {log}.out;                

                echo "   Count TE..."
                test -s {params.work_directory}/INSIDER/TE_DETECTION/${{type}}.csv && \
                awk 'NR>1{{print $1}}' {params.work_directory}/INSIDER/TE_DETECTION/${{type}}.csv | sort | uniq -c | sort -k 1 -n | \
                    awk 'BEGIN{{print "x\ty\tz"}} OFS="\t"{{print "", $2, $1}}' > {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_COUNT_TE.csv

                echo
                #test -s {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_COUNT_TE.csv && \
                #tail {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_COUNT_TE.csv | awk -F "\t" 'OFS="\t"{{if(NR!=1){{print $2, $3}}else{{print "TE\tNUMBER"}}}}'
                test -s {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_COUNT_TE.csv && \
                    awk -F "\t" 'BEGIN{{ NB_FAMILY=0; Count_TE=0; }} OFS="\t"{{ if(NR!=1){{ NB_FAMILY += 1; Count_TE+=$3;}}  }} END{{print "NUMBER OF FAMILY := "NB_FAMILY"\\nNUMBER OF TE := "Count_TE;}}' {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_COUNT_TE.csv
                echo -e "\n"
            fi;
        done;

        #INSERTION ON QUERY
        # test -s {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv && \
        #     awk 'NR>1 && OFS="\t"{{ split($2, a, ":"); split(a[6], b, "-"); print a[5], b[1], b[2], $1"|"a[1], a[7]}}' {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv > {output.bed} #{params.work_directory}/INSIDER/TE_DETECTION/INSERTION_TE.bed 

        ##can be false sometime [b[1]+$6, b[2]-( (b[2]-b[1]) - $7 )] 
        test -s {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_COMBINE_TE.csv && \
            awk 'NR>1 && OFS="\t"{{ split($2, a, ":"); split(a[6], b, "-"); print a[5], b[1]+$6, b[2]-((b[2]-b[1])-$7), $1"|"a[1], a[7]}}' {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_COMBINE_TE.csv > {output.bed} #{params.work_directory}/INSIDER/TE_DETECTION/INSERTION_TE.bed 


        ##INSERTION ON REF
        echo "CALCUL POSITION TE ON REF"
        test -s {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv && \
            awk 'NR>1{{ split($2, sp, ":"); print sp[1] }}' {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv > {params.work_directory}/tmp_ID.txt
        
        rm -f {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_TE_ON_REF.bed

        test -s {params.work_directory}/tmp_ID.txt && \
            for id in `cat {params.work_directory}/tmp_ID.txt`; do 
                read -r chrom start end _ <<< $(grep -w "$id" {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out.Assemblytics_structural_variants.bed | awk 'OFS="\t"{{print $1, $2, $3}}')
                TE=`grep -w "$id" {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv | cut -f 1`;

                echo -e "$chrom\t$start\t$end\t$TE|$id" >> {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_TE_ON_REF.bed
            done;
        rm -f {params.work_directory}/tmp_ID.txt

        test -s {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_TE_ON_REF.bed && \
            ln -s -r -f {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_TE_ON_REF.bed {params.work_directory}/POS_TE_INSIDER_ON_REF.bed


        #DELETION ON REF
        test -s {params.work_directory}/INSIDER/TE_DETECTION/DELETION.csv && \
            awk 'NR>1{{print $1":"$2}}' {params.work_directory}/INSIDER/TE_DETECTION/DELETION.csv | awk -F ":" 'OFS="\t"{{split($7, sp, "-"); print $6, sp[1], sp[2], $1"|"$2}}' > {params.work_directory}/INSIDER/TE_DETECTION/DELETION_TE_ON_REF.bed && \
            ln -s -f -r {params.work_directory}/INSIDER/TE_DETECTION/DELETION_TE_ON_REF.bed {params.work_directory}/


        #DELETION ON QUERY
        test -s {params.work_directory}/INSIDER/TE_DETECTION/DELETION.csv && \
            awk 'NR>1{{ split($2, sp, ":"); print sp[1] }}' {params.work_directory}/INSIDER/TE_DETECTION/DELETION.csv > {params.work_directory}/tmp_ID.txt
        

        rm -f {params.work_directory}/INSIDER/TE_DETECTION/DELETION_TE.bed
        test -s {params.work_directory}/tmp_ID.txt && \
            for id in `cat {params.work_directory}/tmp_ID.txt`; do 
                read -r chrom start end <<< $(grep -w "$id" {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out.Assemblytics_structural_variants.bed | cut -f 10 | awk -F ":" 'OFS="\t"{{split($2, pos, "-"); print $1, pos[1], pos[2]}}')
                TE=`grep -w "$id" {params.work_directory}/INSIDER/TE_DETECTION/DELETION.csv | cut -f 1`;
                echo -e "$chrom\t$start\t$end\t$TE|$id" >> {params.work_directory}/INSIDER/TE_DETECTION/DELETION_TE.bed
            done;
        rm -f {params.work_directory}/tmp_ID.txt

        test -s {params.work_directory}/INSIDER/TE_DETECTION/DELETION_TE.bed && \
            ln -s -f -r {params.work_directory}/INSIDER/TE_DETECTION/DELETION_TE.bed {params.work_directory}/

        test -s {output.bed} && \
            cat {output.bed}| bedtools sort | awk 'OFS="\t"{{ print $1, $2, $3, $4, $3-$2, $5 }}' > {params.work_directory}/POSITION_TE_INSIDER.bed

        test -s {output.bed} || fail_msg "  WARNING NO TE INSERTION FOUND\\n";
        test -s {params.work_directory}/INSIDER/TE_DETECTION/DELETION_TE.bed || fail_msg "  WARNING NO TE DELETION FOUND\\n";

        #
        rm -f {params.work_directory}/INSIDER/TE_DETECTION/Repeat*
        rm -f {params.work_directory}/INSIDER/TE_DETECTION/Tandem*
        rm -f {params.work_directory}/INSIDER/TE_DETECTION/*SEQ_ALL.fasta

        """


#END TE_INSIDER


rule TE_INSIDERv2:
    input:  
        ref      = config["DATA"]["REFERENCE"],
        query    = config["DATA"]["GENOME"],
        sam      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/VARIANT_CALLING/pm_against_ref.sam",
        delta    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/VARIANT_CALLING/pm_against_ref.sam.delta",
        bed      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/VARIANT_CALLING/assemblytics_out.Assemblytics_structural_variants.bed",
        stats    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/VARIANT_CALLING/assemblytics_out.Assemblytics_assembly_stats.txt",

        fasta_TE = config["DATA"]["TE_DB"],


    output:
        csv = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/TE_DETECTION/INSERTION.csv",
        bed = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/TE_DETECTION/INSERTION_TE.bed",
        tmp = output_link=[],

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env,

        pars_bln_option_insider = config["PARAMS"]["INSIDER_VARIANT"]["PARS_BLN_OPTION"],
        threads                 = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,
        
        #COLOR 
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,


        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/TE_INSIDER",

    shell:
        """

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] GET TE INSIDER {params.cend}"

        echo "[`date`] STEP INSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        {params.env}
        path_to_pipline=`dirname {params.path_snk}`
        
        mkdir -p {params.work_directory}/INSIDER/TE_DETECTION/

        rm -f {log}.log {log}.err

        echo "[`date`] LOG TASK {log}.out, {log}.err"

        #echo "GET SEQUENCE SV"
        #GET SEQUENCE SV
        ## GET SEQUENCE SV INSERTION
        rm -f {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_SEQ_ALL.fasta
        bedtools getfasta -fi {input.query} -bed {input.bed} -name+ > {params.work_directory}/INSIDER/TE_DETECTION/VC_SEQ.fasta

        echo "   Checking TE candidate..."
        makeblastdb -in {input.fasta_TE} -dbtype nucl  2> {log}.err 1> {log}.out;
        blastn -num_threads {params.threads} -db {input.fasta_TE} \
            -query {params.work_directory}/INSIDER/TE_DETECTION/VC_SEQ.fasta \
            -outfmt 6 \
            -out {params.work_directory}/INSIDER/TE_DETECTION/VC_TO_TE.bln 2> {log}.err 1> {log}.out;

        echo "   Getting TE..."
        test -s {params.work_directory}/INSIDER/TE_DETECTION/VC_TO_TE.bln && \
            python3 ${{path_to_pipline}}/lib/python/parsing/global_sv.py {params.pars_bln_option_insider} \
                --combine_name {params.work_directory}/INSIDER/TE_DETECTION/COMBINE_TE.csv \
                {params.work_directory}/INSIDER/TE_DETECTION/VC_TO_TE.bln \
                {input.fasta_TE} \
                {params.work_directory}/INSIDER/TE_DETECTION/TE.csv 2>> {log}.err 1>> {log}.out;      
        

        echo "   Count TE..."
        # test -s {params.work_directory}/INSIDER/TE_DETECTION/TE.csv && \
        #     awk 'NR>1{{print $1}}' {params.work_directory}/INSIDER/TE_DETECTION/TE.csv | sort | uniq -c | sort -k 1 -n | \
        #         awk 'BEGIN{{print "x\ty\tz"}} OFS="\t"{{print "", $2, $1}}' > {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_COUNT_TE.csv

        # echo

        ##SHOW NUMBER BY TYPE
        awk 'NR>1{{split($2, sp, ":"); print $0"\t"sp[3]}}' {params.work_directory}/INSIDER/TE_DETECTION/TE.csv | sort -k 14 | \
            awk '
                function isInArray(value, array, i) {{
                    for (i in array) {{
                        if (array[i] == value) {{
                            return 1;
                        }}
                    }}
                    return 0;
                }}

                {{
                    if( type != $NF ){{
                        if(NR > 1){{
                            print "TYPE: "type
                            print "  NUMBER OF FAMILY := "NB_FAMILY;
                            print "  NUMBER OF TE := "NB_TE;
                            print "";
                        }}
                        split("", tabTE); 
                        tabTE[1]=$1;
                        indexTab=2;
                        type=$NF;
                        NB_TE=1;
                        NB_FAMILY=1;
                    }}
                    else{{
                        NB_TE+=1;
                        if( isInArray($1, tabTE) == 0 ){{
                            tabTE[indexTab]=$1;
                            indexTab+=1;
                            NB_FAMILY+=1;
                        }}
                    }}
                }}

                END{{ 
                    print "TYPE: "type
                    print "  NUMBER OF FAMILY := "NB_FAMILY;
                    print "  NUMBER OF TE := "NB_TE;
                }}
            '

        #INSERTION ON QUERY (GENOME)
        ##can be false sometime [b[1]+$6, b[2]-( (b[2]-b[1]) - $7 )] 
        test -s {params.work_directory}/INSIDER/TE_DETECTION/COMBINE_TE.csv && \
            awk '
                NR>1 && OFS="\t"{{ 
                    split($2, a, ":"); 
                    split(a[6], b, "-"); 
                    print a[5], b[1]+$6, b[2]-((b[2]-b[1])-$7), $1"|"a[1], a[7]
                }}
                ' {params.work_directory}/INSIDER/TE_DETECTION/COMBINE_TE.csv > {output.bed} #{params.work_directory}/INSIDER/TE_DETECTION/INSERTION_TE.bed 


        ##INSERTION ON REF
        echo "CALCUL POSITION TE ON REF"
        test -s {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv && \
            awk 'NR>1{{ split($2, sp, ":"); print sp[1] }}' {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv > {params.work_directory}/tmp_ID.txt
        
        rm -f {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_TE_ON_REF.bed

        test -s {params.work_directory}/tmp_ID.txt && \
            for id in `cat {params.work_directory}/tmp_ID.txt`; do 
                read -r chrom start end _ <<< $(grep -w "$id" {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out.Assemblytics_structural_variants.bed | awk 'OFS="\t"{{print $1, $2, $3}}')
                TE=`grep -w "$id" {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv | cut -f 1`;

                echo -e "$chrom\t$start\t$end\t$TE|$id" >> {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_TE_ON_REF.bed
            done;
        rm -f {params.work_directory}/tmp_ID.txt

        test -s {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_TE_ON_REF.bed && \
            ln -s -r -f {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_TE_ON_REF.bed {params.work_directory}/POS_TE_INSIDER_ON_REF.bed


        #DELETION ON REF
        test -s {params.work_directory}/INSIDER/TE_DETECTION/DELETION.csv && \
            awk 'NR>1{{print $1":"$2}}' {params.work_directory}/INSIDER/TE_DETECTION/DELETION.csv | awk -F ":" '
            OFS="\t"{{
                split($7, sp, "-"); 
                print $6, sp[1], sp[2], $1"|"$2
            }}' > {params.work_directory}/INSIDER/TE_DETECTION/DELETION_TE_ON_REF.bed && \
            ln -s -f -r {params.work_directory}/INSIDER/TE_DETECTION/DELETION_TE_ON_REF.bed {params.work_directory}/


        #DELETION ON QUERY
        test -s {params.work_directory}/INSIDER/TE_DETECTION/DELETION.csv && \
            awk 'NR>1{{ split($2, sp, ":"); print sp[1] }}' {params.work_directory}/INSIDER/TE_DETECTION/DELETION.csv > {params.work_directory}/tmp_ID.txt
        

        rm -f {params.work_directory}/INSIDER/TE_DETECTION/DELETION_TE.bed
        test -s {params.work_directory}/tmp_ID.txt && \
            for id in `cat {params.work_directory}/tmp_ID.txt`; do 
                read -r chrom start end <<< $(grep -w "$id" {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out.Assemblytics_structural_variants.bed | cut -f 10 | awk -F ":" 'OFS="\t"{{split($2, pos, "-"); print $1, pos[1], pos[2]}}')
                TE=`grep -w "$id" {params.work_directory}/INSIDER/TE_DETECTION/DELETION.csv | cut -f 1`;
                echo -e "$chrom\t$start\t$end\t$TE|$id" >> {params.work_directory}/INSIDER/TE_DETECTION/DELETION_TE.bed
            done;
        rm -f {params.work_directory}/tmp_ID.txt

        test -s {params.work_directory}/INSIDER/TE_DETECTION/DELETION_TE.bed && \
            ln -s -f -r {params.work_directory}/INSIDER/TE_DETECTION/DELETION_TE.bed {params.work_directory}/

        test -s {output.bed} && \
            cat {output.bed}| bedtools sort | awk 'OFS="\t"{{ print $1, $2, $3, $4, $3-$2, $5 }}' > {params.work_directory}/POSITION_TE_INSIDER.bed

        test -s {output.bed} || fail_msg "  WARNING NO TE INSERTION FOUND\\n";
        test -s {params.work_directory}/INSIDER/TE_DETECTION/DELETION_TE.bed || fail_msg "  WARNING NO TE DELETION FOUND\\n";

        #
        rm -f {params.work_directory}/INSIDER/TE_DETECTION/Repeat*
        rm -f {params.work_directory}/INSIDER/TE_DETECTION/Tandem*
        rm -f {params.work_directory}/INSIDER/TE_DETECTION/*SEQ_ALL.fasta

        """


#END TE_INSIDERv2

rule SV_INSIDER:
    input:  
        ref         = config["DATA"]["REFERENCE"],
        genome      = config["DATA"]["GENOME"],

    output:
        sam   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/VARIANT_CALLING/pm_against_ref.sam",
        delta = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/VARIANT_CALLING/pm_against_ref.sam.delta",
        bed   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/VARIANT_CALLING/assemblytics_out.Assemblytics_structural_variants.bed",
        stats = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/VARIANT_CALLING/assemblytics_out.Assemblytics_assembly_stats.txt",


    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env,
        threads        = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,

        preset         = config["PARAMS"]["INSIDER_VARIANT"]["MINIMAP2"]["PRESET_OPTION"] if config["PARAMS"]["INSIDER_VARIANT"]["MINIMAP2"]["PRESET_OPTION"] != "" else "asm5",
        option         = re.sub("-t [0-9]+", "", config["PARAMS"]["INSIDER_VARIANT"]["MINIMAP2"]["OPTION"]) + " -t " + str(config["PARAMS"]["THREADS"]),

        #COLOR 
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,

        step=0,

    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/SV_INSIDER"

    shell:
        """

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] GET SV INSIDER {params.cend}"

        echo "[`date`] STEP INSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        mkdir -p {params.work_directory}/INSIDER/VARIANT_CALLING/
        mkdir -p {params.work_directory}/log/

        path_to_pipline=`dirname {params.path_snk}`

        rm -f `find {params.work_directory} -name "*.fa*.fai"`
        rm -f {log}.err {log}.log

        echo "[`date`] LOG TASK {log}.log, {log}.err"

        echo "MAPPING GENOME ON REFERENCE..."
        #COMPARE GENOME
        minimap2 -ax {params.preset} {params.option} -t {params.threads} {input.ref} {input.genome} > {output.sam} 2> {params.work_directory}/log/pm_contigs_against_ref.sam.log
        
        #CHECK MAPPING
        test -s {output.sam} || ( fail_msg "ERROR : MAPPING FAILED\\n" && exit 2 )
        python3 ${{path_to_pipline}}/lib/python/assemblitics/sam2delta.py {output.sam} 2>> {log}.err;
        
        echo "GET SV WITH Assemblytics with alignment..."
        #GET SV
        ## GET SV 1 Assemblytics with alignment sam to delta
        python3 ${{path_to_pipline}}/lib/python/assemblitics/Assemblytics_uniq_anchor.py \
            --delta {output.delta} \
            --unique-length 20000 \
            --out {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out \
            --keep-small-uniques 2>> {log}.err;

        echo "GET SV WITH Assemblytics between alignment..."
        ## GET SV 2 Assemblytics between alignment
        perl ${{path_to_pipline}}/lib/perl/Assemblytics_between_alignments.pl \
            {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out.coords.tab \
            50 \
            20000 \
            all-chromosomes \
            exclude-longrange \
            bed > {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out.variants_between_alignments.bed \
            2>> {log}.err;

        echo "GET SV WITH Assemblytics within alignment..."
        ## GET SV 3 Assemblytics within alignment
        python3 ${{path_to_pipline}}/lib/python/assemblitics/Assemblytics_within_alignment.py \
            --delta {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out.Assemblytics.unique_length_filtered_l20000.delta \
            --min 50 > {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out.variants_within_alignments.bed \
            2>> {log}.err;

        (test -s {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out.variants_between_alignments.bed || \
        test -s {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out.variants_within_alignments.bed) && \
            cat {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out.variants_between_alignments.bed \
                {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out.variants_within_alignments.bed \
                > {output.bed}
        
        test -s {output.bed} || (fail_msg "[SNK ERROR `date`] NO SV FOUND" && exit 1)

        path_ref=`readlink -f {input.ref}`
        path_genome=`readlink -f {input.genome}`
        old_path=`pwd`
        old_log=`realpath {log}.err`
        
        cd {params.work_directory}/INSIDER/VARIANT_CALLING/
        python3 ${{path_to_pipline}}/lib/python/assemblitics/filter_gap_SVs.py ${{path_ref}} ${{path_genome}} 2>> $old_log
        cd ${{old_path}}


        ##
        name_ref=`basename {input.ref}`
        name_query=`basename {input.genome}`

        echo "NUMBER OF SV DETECTED :"`cat {output.bed} | wc -l`

        printf "%s\\n" "{params.cmess} [SNK]--[`date`]--[INFO] REFERENCE : $name_ref {params.cend}"
        printf "%s\\n\\n" "{params.cmess} [SNK]--[`date`]--[INFO] GENOME : $name_query {params.cend}"

        sed -i "s/file1/${{name_ref}}/g" {output.stats}
        sed -i "s/file2/${{name_query}}/g" {output.stats}

        """


#END SV_INSIDER

