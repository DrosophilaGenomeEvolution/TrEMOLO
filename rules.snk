
####
####
############# OUTSIDER VARIANT
####
####


#TODO TSD file to work_directory
rule RENAME_PSEUDO_TE:
    input:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/LIST_HEADER_DB_TE.csv",
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/REPORT/report.html",
    output:
        
    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        choice_outsider_sv  = config["CHOICE"]["PIPELINE"]["OUTSIDER_VARIANT"],
        choice_insider_sv   = config["CHOICE"]["PIPELINE"]["INSIDER_VARIANT"],

        INTERMEDIATE_FILE   = config["CHOICE"]["INTERMEDIATE_FILE"],

        CHROM_KEEP       = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["CHROM_KEEP"],
        
        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/RENAME",


    shell:
        """
        {params.env}

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] RENAME PSEUDO TE [^-^] {params.cend}"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        rm -f {log}.*
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        
        path_to_pipline=`dirname {params.path_snk}`

        ## TODO DELETE THIS
        sed -i 's/original=>//g' {params.work_directory}/LIST_HEADER_DB_TE.csv
        sed -i 's/pseudo=>//g' {params.work_directory}/LIST_HEADER_DB_TE.csv

        ## CHANGE DIRECTORY
        old_path=`pwd`
        _realpath=`realpath {params.work_directory}`
        basename=`basename {params.work_directory}`
        cd {params.work_directory}/REPORT/mini_report/web/js/

        awk  'NR>1 {{ split($4, sp, "|"); print sp[1] }}' ${{_realpath}}/TE_INFOS.bed | sort -u > ${{_realpath}}/tmp_LIST_TE_TO_CHANGE.txt

        ## RENAME TE IN REPORT JS
        echo "RENAME TE IN REPORT JS...";
        
        for file in `ls | grep ".js$" | grep -e  "SIDER" | grep -v "TRUE_NAME_" | grep -v "TE_INSIDER_DEL"`; do
            echo "FILE : $file";
            #rm -f TRUE_NAME_$file && cat $file > TRUE_NAME_$file;
            for ID in `cat ${{_realpath}}/tmp_LIST_TE_TO_CHANGE.txt`; do 
                new=`grep -w $ID ../../../../LIST_HEADER_DB_TE.csv | cut -f 1 || echo ""`
                #echo "ID: $ID; new : $new;"
                #sed -i "s/$ID\\"/$new\\"/g" TRUE_NAME_$file;
                if [ -n "$new" ] && [ "$ID" != "$new" ]; then
                    #sed -i "s/$ID\\"/$new\\"/g" $file;
                    python3 ${{path_to_pipline}}/lib/python/others/replace.py "$ID" "$new" $file
                fi;
            done;
            #template_file=`grep -rnw "$file" ../lib/ | cut -d ":" -f 1`
            #echo "change data on template_file : $template_file --"
            # if [ -n "$template_file" ]; then
            #     echo "REPLACE";
            #     sed -i "s/${{file}}/TRUE_NAME_${{file}}/g" ${{template_file}};
            # fi;
        done;
        #rm -f ${{_realpath}}/tmp_LIST_TE_TO_CHANGE.txt

        #rm -f TRUE_NAME_COUNT_TE_INSIDER_DEL.js && cat COUNT_TE_INSIDER_DEL.js > TRUE_NAME_COUNT_TE_INSIDER_DEL.js;
        for ID in `grep -w "TrEMOLOTE[0-9]*" COUNT_TE_INSIDER_DEL.js -o | sort -u`; do 
            new=`grep -w $ID ../../../../LIST_HEADER_DB_TE.csv | cut -f 1 || echo ""`
            
            if [ -n "$new" ] && [ "$ID" != "$new" ]; then
                #sed -i "s/$ID\\"/$new\\"/g" COUNT_TE_INSIDER_DEL.js;
                python3 ${{path_to_pipline}}/lib/python/others/replace.py "$ID" "$new" COUNT_TE_INSIDER_DEL.js
            fi;
        done;
        sed -i "s/COUNT_TE_INSIDER_DEL.js/TRUE_NAME_COUNT_TE_INSIDER_DEL.js/g" ../lib/template_COUNT_TE_INSIDER_DEL.html;

        cd ${{old_path}};

        #RENAME BED
        echo "RENAME TE BED..."

        NB_TE=`ls {params.work_directory} | grep ".bed$" -c`;

        i=0;
        show_step="$i/$NB_TE FILE"
        number_of_char=`echo "$show_step" | wc -c`
        number_of_char=$(($number_of_char-1));
        printf "\b%.0s" `seq 1 $number_of_char`
        printf "$show_step";

        for file in `ls {params.work_directory} | grep ".bed$"`; do
            for ID in `awk  '{{ split($4, sp, "|"); print sp[1] }}' {params.work_directory}/$file | sort -u`; do 
                new=`grep -w "$ID" {params.work_directory}/LIST_HEADER_DB_TE.csv | cut -f 1 || echo ""`

                if [ -n "$new" ] && [ "$ID" != "$new" ]; then
                    #sed -i "s/${{ID}}/${{new}}/g" {params.work_directory}/$file;
                    python3 ${{path_to_pipline}}/lib/python/others/replace.py "$ID" "$new" {params.work_directory}/$file;
                fi;
            done;

            i=$(($i+1));
            show_step="$i/$NB_TE FILE"
            number_of_char=`echo "$show_step" | wc -c`
            number_of_char=$(($number_of_char-1));
            printf "\b%.0s" `seq 1 $number_of_char`
            printf "$show_step";
        done;

        ## RENAME CSV
        echo -e "\\nRENAME TE CSV..."
        for file in `ls {params.work_directory} | grep ".csv$" | grep -v "LIST_HEADER_DB_TE.csv"`; do
            for ID in `cat {params.work_directory}/tmp_LIST_TE_TO_CHANGE.txt`; do
                new=`grep -w $ID {params.work_directory}/LIST_HEADER_DB_TE.csv | cut -f 1`

                #sed -i "s/$ID/$new/g" {params.work_directory}/$file
                python3 ${{path_to_pipline}}/lib/python/others/replace.py "$ID" "$new" {params.work_directory}/$file;
            done;
        done;


        #OUTSIDER sniffles
        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv && \
            for file in `ls {params.work_directory}/OUTSIDER/TE_DETECTION | grep ".csv$" `; do
                for ID in `cat {params.work_directory}/tmp_LIST_TE_TO_CHANGE.txt`; do
                    new=`grep -w $ID {params.work_directory}/LIST_HEADER_DB_TE.csv | cut -f 1`
                    # echo "new : $new; ID : $ID";
                    #sed -i "s/$ID/$new/g" {params.work_directory}/OUTSIDER/TE_DETECTION/$file;
                    python3 ${{path_to_pipline}}/lib/python/others/replace.py "$ID" "$new" {params.work_directory}/OUTSIDER/TE_DETECTION/$file;
                done;
            done;


        #OUTSIDER TrEMOLO
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.bed && \
            for file in `ls {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/ | grep ".csv$" `; do
                for ID in `cat {params.work_directory}/tmp_LIST_TE_TO_CHANGE.txt`; do
                    new=`grep -w $ID {params.work_directory}/LIST_HEADER_DB_TE.csv | cut -f 1`

                    #sed -i "s/$ID/$new/g" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/$file;
                    python3 ${{path_to_pipline}}/lib/python/others/replace.py "$ID" "$new" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/$file;
                done;
            done;


        #OUTSIDER SOFT
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.csv && \
            for file in `ls {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/ | grep -E ".csv$" `; do
                for ID in `cat {params.work_directory}/tmp_LIST_TE_TO_CHANGE.txt`; do
                    new=`grep -w $ID {params.work_directory}/LIST_HEADER_DB_TE.csv | cut -f 1`

                    #sed -i "s/$ID/$new/g" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/$file;
                    python3 ${{path_to_pipline}}/lib/python/others/replace.py "$ID" "$new" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/$file;
                done;
            done;


        #OUTSIDER HARD
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.csv && \
            for file in `ls {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/ | grep -E ".csv$" `; do
                for ID in `cat {params.work_directory}/tmp_LIST_TE_TO_CHANGE.txt`; do
                    new=`grep -w $ID {params.work_directory}/LIST_HEADER_DB_TE.csv | cut -f 1`

                    #sed -i "s/$ID/$new/g" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/$file;
                    python3 ${{path_to_pipline}}/lib/python/others/replace.py "$ID" "$new" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/$file;
                done;
            done;


        #INSIDER
        test -s {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv && \
            for file in ` ls {params.work_directory}/INSIDER/TE_DETECTION | grep ".csv$" `; do
                for ID in `cat {params.work_directory}/tmp_LIST_TE_TO_CHANGE.txt`; do
                    new=`grep -w $ID {params.work_directory}/LIST_HEADER_DB_TE.csv | cut -f 1`

                    #sed -i "s/$ID/$new/g" {params.work_directory}/INSIDER/TE_DETECTION/$file;
                    python3 ${{path_to_pipline}}/lib/python/others/replace.py "$ID" "$new" {params.work_directory}/INSIDER/TE_DETECTION/$file;
                done;
            done;


        test -s {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.bln && \
            python3 ${{path_to_pipline}}/lib/python/others/replace_2.py {params.work_directory}/LIST_HEADER_DB_TE.csv \
                {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.bln \
                2 > {params.work_directory}/tmp.bln && \
                    cat {params.work_directory}/tmp.bln > {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.bln && \
                    rm -f {params.work_directory}/tmp.bln


        test -s {params.work_directory}/INSIDER/TE_DETECTION/DELETION.bln && \
            python3 ${{path_to_pipline}}/lib/python/others/replace_2.py {params.work_directory}/LIST_HEADER_DB_TE.csv \
                {params.work_directory}/INSIDER/TE_DETECTION/DELETION.bln \
                2 > {params.work_directory}/tmp.bln && \
                    cat {params.work_directory}/tmp.bln > {params.work_directory}/INSIDER/TE_DETECTION/DELETION.bln && \
                    rm -f {params.work_directory}/tmp.bln

        ## REMAKE FOR TRUE NAME REPORT
        cd {params.work_directory}/REPORT/mini_report/

        make

        cd ${{old_path}};

        #rm -f {params.work_directory}/tmp*;

        """

#END RENAME_PSEUDO_TE


rule REPORT :
    input:
        genome = config["DATA"]["GENOME"],
        input_link=[],

    output:
        #config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/TE_INFOS.bed",
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/REPORT/report.html",
        #output_link=[],
        
    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        choice_outsider_sv  = config["CHOICE"]["PIPELINE"]["OUTSIDER_VARIANT"],
        choice_insider_sv   = config["CHOICE"]["PIPELINE"]["INSIDER_VARIANT"],

        REPORT              = config["CHOICE"]["PIPELINE"]["REPORT"],
        INTERMEDIATE_FILE   = config["CHOICE"]["INTERMEDIATE_FILE"],

        CHROM_KEEP       = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["CHROM_KEEP"],
        
        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/REPORT",


    shell:
        #TODO broullion
        """

        {params.env}

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] BUILD REPORT [^-^] {params.cend}"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        rm -fr {params.work_directory}/REPORT/
        mkdir -p {params.work_directory}/REPORT/
        rm -f {log}.*
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        
        path_to_pipline=`dirname {params.path_snk}`

        
        ###BUILD BED ALL INFOS
        echo "BUILD BED ALL INFOS..."

        ##TODO remove commandes doublons
        test -s {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_TE.bed && \
            cat {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_TE.bed | bedtools sort | awk 'OFS="\t"{{ print $1, $2, $3, $4, $3-$2, $5 }}' > {params.work_directory}/POSITION_TE_INSIDER.bed

        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed && \
            ln -sfr {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed {params.work_directory}/POSITION_TE_OUTSIDER.bed
        
        #OUTSIDER
        NB_TE_OUT=`(test -s {params.work_directory}/POSITION_TE_OUTSIDER.bed && cat {params.work_directory}/POSITION_TE_OUTSIDER.bed | wc -l) || echo 0`
        NB_TE_IN=`(test -s {params.work_directory}/POSITION_TE_INSIDER.bed && cat {params.work_directory}/POSITION_TE_INSIDER.bed | wc -l) || echo 0`

        NB_TE=$(($NB_TE_OUT + $NB_TE_IN));

        ## CHECK INTERSECT TO DELETION
        echo "CHECK INTERSECT TO DELETION INSIDER...";
        test -s {params.work_directory}/POSITION_TE_OUTSIDER.bed && test -s {params.work_directory}/DELETION_TE.bed && bedtools window -a {params.work_directory}/POSITION_TE_OUTSIDER.bed -b {params.work_directory}/DELETION_TE.bed -w 30 | \
            awk '{{ split($4, sp1, "|"); split($10, sp2, "|"); if(sp1[1] == sp2[1]){{ print sp1[2] }} }}' > {params.work_directory}/ID_OUTSIDER_INTERSECT_TO_DEL.txt

        #BUILD TE_INFO OUTSIDER
        echo "BUILD TE_INFO OUTSIDER...";

        i=0;
        show_step="$i/$NB_TE TE"
        number_of_char=`echo "$show_step" | wc -c`
        number_of_char=$(($number_of_char-1));
        printf "\b%.0s" `seq 1 $number_of_char`
        printf "$show_step";
        rm -f {params.work_directory}/TE_INFOS.bed
        echo -e "#chrom\tstart\tend\tTE|ID\tstrand\tTSD\tpident\tpsize_TE\tSIZE_TE\tNEW_POS\tFREQ\tFREQ_OPTIMIZED\tSV_SIZE\tID_TrEMOLO\tTYPE" > {params.work_directory}/TE_INFOS.bed
        test -s {params.work_directory}/POSITION_TE_OUTSIDER.bed && \
            while read line;
        do
            read -r chrom start end TE ID strand <<< $(echo $line | awk 'OFS="\t"{{split($4, TE, "|"); print $1, $2, $3, TE[1], TE[2], $6}}')
            pident=`(grep -w "$ID" {params.work_directory}/OUTSIDER/TE_DETECTION/COMBINE_TE.csv || grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/COMBINE_INS_TREMOLO.csv || grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.csv || grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.csv) | cut -f 3 || echo "NONE"`;
            size_per=`(grep -w "$ID" {params.work_directory}/OUTSIDER/TE_DETECTION/COMBINE_TE.csv || grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/COMBINE_INS_TREMOLO.csv || grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.csv || grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.csv) | cut -f 4 || echo "NONE"`

            test -s {params.work_directory}/ID_OUTSIDER_INTERSECT_TO_DEL.txt && \
                intersect_to_del=`grep -w "$ID" {params.work_directory}/ID_OUTSIDER_INTERSECT_TO_DEL.txt || echo ""` || intersect_to_del="";

            TYPE_TrEMOLO=`echo "$ID" | grep -E -o "SOFT|HARD|DEL|INS" || echo "UNDEFINED"`;
            if [ -n "$intersect_to_del" ]; then
                TYPE_TrEMOLO="${{TYPE_TrEMOLO}}_DEL";
            fi;

            test -s {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{TE}}.txt && \
                cat {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{TE}}.txt > {params.work_directory}/tmp.txt

            test -s {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{TE}}_KO_corrected.txt && \
                cat {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{TE}}_KO_corrected.txt >> {params.work_directory}/tmp.txt

            test -s {params.work_directory}/tmp.txt || touch {params.work_directory}/tmp.txt

            #TSD
            #grep "OK:$ID]" {params.work_directory}/tmp.txt || echo "NONE : $ID";
            SIZE_TE="";
            TSD_OK=`grep "OK:$ID]" {params.work_directory}/tmp.txt -A 2 | grep "++:[A-Z]*:++--" -o | grep -o -E "[A-Z]+" || echo ""`
            if [ ! -n "$TSD_OK" ]; then
                TSD_OK="NONE"
                SIZE_TE=`grep ":$ID:[0-9]*:[IP]" {params.work_directory}/OUTSIDER/TE_DETECTION/COMBINE_TE.csv | cut -f 7 || echo "NONE"`
            else
                SIZE_TE=`grep "OK:$ID]" {params.work_directory}/tmp.txt -A 3 | grep -e "--|[A-Z]*|--" -o | grep "[A-Z]*" -o | awk '{{print length($0)}}' || echo "NONE"`
            fi;
            #echo "TSD_OK : $TSD_OK";

            if [ ! -n "$SIZE_TE" ]; then
                SIZE_TE="NONE"; 
            fi;

            #TSD NEW POS
            NEW_POS=`(test -s {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{TE}}.txt && grep "OK:$ID]" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{TE}}.txt -A 5 | grep "TSD_POSITION" | cut -d ":" -f 2) || echo ""`
            if [ ! -n "$NEW_POS" ] && test -s {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{TE}}_KO_corrected.txt; then
                NEW_POS=`(test -s {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{TE}}_KO_corrected.txt && grep "KO->OK:$ID]" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{TE}}_KO_corrected.txt -A 5 | grep "NEW_POS=" | cut -d "=" -f 2 | cut -d ":" -f 1) || echo "$start"`                
            fi;

            if [ ! -n "$NEW_POS" ]; then
                NEW_POS="$start";
            fi;
            #echo "NEW_POS : $NEW_POS";
            #echo


            ##FREQUENCE
            # FREQ_BEFOR=`grep ":$ID:[0-9]*:[IP]"  {params.work_directory}/OUTSIDER/TE_DETECTION/DEPTH_TE.csv | cut -f 6 || echo "NONE"`
            # if test -s {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/DEPTH_TE.csv;
            # then 
            #     ##Warning: choix flank 30nt
            #     FREQ_AFTER=`grep "$chrom"  {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/DEPTH_TE.csv | awk -v TE="$TE" '$7==TE' | awk -v start="$start" '$2>=start-30 && $2<=start+30' | head -n 1 | cut -f 6 || echo "NONE"`
            #     if [ ! -n "$FREQ_AFTER" ];
            #     then
            #         FREQ_AFTER="NONE";
            #     fi;
            # else
            #     FREQ_AFTER="NONE";
            # fi;
            # #echo "FREQ_AFTER : $FREQ_AFTER"

            FREQ_BEFOR="";
            FREQ_AFTER="";

            FREQ_BEFOR=`grep -w "$ID" {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/FREQUENCY_TE_INS.tsv | cut -f 9 || echo "NONE"`;
            FREQ_AFTER=`grep -w "$ID" {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/FREQUENCY_TE_INS.tsv | cut -f 10 || echo "NONE"`;

            ! test -n "$FREQ_BEFOR" && FREQ_BEFOR="NONE-FREQB" && echo "NONE-FREQB";
            ! test -n "$FREQ_AFTER" && FREQ_AFTER="NONE-FREQA" && echo "NONE-FREQA";

            ##SIZE SV
            SV_SIZE=`grep -w "$ID" {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/SV_SIZE.tsv | awk 'max<$2{{ max=$2; }} END{{ if(max!=""){{ print max }} }}' || echo "NONE"`;
            ! test -n "$SV_SIZE" && SV_SIZE="NONE";

            ##ID TrEMOLO
            IS_CLIPPED=`echo "$ID" | grep -E -o "SOFT|HARD" || echo ""`

            if ! test -n "$IS_CLIPPED"; then
                #GET ID_TrEMOLO
                ID_POS=`echo $line | awk '{{print $1":"$2}}' | ${{path_to_pipline}}/lib/C++/bin/chain_to_id`
                TYPE=`(grep -w "$ID" {params.work_directory}/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv || grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv ) | cut -f 2  | cut -d ":" -f 2 | sed 's/[<>]//g'`
                file_tmp=`ls {params.work_directory}/OUTSIDER/READ_FASTQ_TE/ | awk -v ID="$ID" -F ":" '$2==ID'`
                test -s {params.work_directory}/OUTSIDER/READ_FASTQ_TE/$file_tmp || warn_msg "ID=$ID : fastq file not found";
                RS=`(test -f {params.work_directory}/OUTSIDER/READ_FASTQ_TE/$file_tmp && grep "^[@]" {params.work_directory}/OUTSIDER/READ_FASTQ_TE/$file_tmp | ${{path_to_pipline}}/lib/C++/bin/chain_to_id) || echo "ERROR_RS_$ID" >{log}.err`
                ! test -n "$RS" && RS=0;
                ID_TrEMOLO="TE_ID_OUTSIDER.$ID_POS.$TYPE.$RS";
            else
                ID_TrEMOLO="TE_ID_OUTSIDER.$ID"
            fi;

            echo -e "$chrom\t$start\t$end\t$TE|$ID\t$strand\t$TSD_OK\t$pident\t$size_per\t$SIZE_TE\t$NEW_POS\t$FREQ_BEFOR\t$FREQ_AFTER\t$SV_SIZE\t$ID_TrEMOLO\t$TYPE_TrEMOLO" >> {params.work_directory}/TE_INFOS.bed

            i=$(($i + 1));
            show_step="$i/$NB_TE TE "
            number_of_char=`echo "$show_step" | wc -c`
            number_of_char=$(($number_of_char-1));
            printf "\b%.0s" `seq 1 $number_of_char`
            printf "$show_step";
        done < {params.work_directory}/POSITION_TE_OUTSIDER.bed 2>&2;
        rm -f {params.work_directory}/tmp.txt
        rm -f {params.work_directory}/ID_OUTSIDER_INTERSECT_TO_DEL.txt

        printf "\b%.0s" `seq 1 10`

        

        #BUILD TE_INFO INSIDER
        #INSIDER
        test -s {params.work_directory}/POSITION_TE_INSIDER.bed && \
        echo "BUILD TE_INFO INSIDER..."

        num_TE_INSIDER=0;
        test -s {params.work_directory}/POSITION_TE_INSIDER.bed && while read line;
        do
            ID=`echo "$line" | cut -f 4 | cut -d "|" -f 2`
            TE=`echo "$line" | cut -f 4 | cut -d "|" -f 1`
            chrom=`echo "$line" | cut -f 1`
            start=`echo "$line" | cut -f 2`
            end=`echo "$line" | cut -f 3`

            # size_ins=$((end-start));

            # #recalculate start with jonctionne TE position
            # start_more=`grep -w "$ID" {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_COMBINE_TE.csv | cut -f 6 || echo 0`            
            # start=$((start+start_more));

            # #recalculate end with jonctionne TE position
            # diff=$((size_ins-end));
            # end=$((end-diff));

            strand=`echo "$line" | cut -f 6`
            pident=`grep -w "$ID" {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_COMBINE_TE.csv | cut -f 3 || echo "NONE"`;
            size_per=`grep -w "$ID" {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_COMBINE_TE.csv | cut -f 4 || echo "NONE"`


            #echo "ID : $ID";
            #echo "TE : $TE";
            test -s {params.work_directory}/INSIDER/TE_DETECTION/TSD/TSD_${{TE}}.txt && \
                cat {params.work_directory}/INSIDER/TE_DETECTION/TSD/TSD_${{TE}}.txt > {params.work_directory}/tmp.txt

            test -s {params.work_directory}/INSIDER/TE_DETECTION/TSD/TSD_${{TE}}_KO_corrected.txt && \
                cat {params.work_directory}/INSIDER/TE_DETECTION/TSD/TSD_${{TE}}_KO_corrected.txt >> {params.work_directory}/tmp.txt

            test -s {params.work_directory}/tmp.txt || touch {params.work_directory}/tmp.txt

            #TSD
            #grep "OK:$ID]" {params.work_directory}/tmp.txt || echo "NONE";
            SIZE_TE="";
            TSD_OK=`grep "OK:$ID]" {params.work_directory}/tmp.txt -A 2 | grep "++:[A-Z]*:++--" -o | grep -o -E "[A-Z]+" || echo ""`
            if [ ! -n "$TSD_OK" ]; then
                TSD_OK="NONE"
                SIZE_TE=`grep "$ID:[+-]:" {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_COMBINE_TE.csv | cut -f 5 || echo "NONE"`
            else
                if [ -s {params.work_directory}/INSIDER/TE_DETECTION/TSD/TSD_${{TE}}.txt ]; then
                    SIZE_TE=`grep "OK:$ID]" {params.work_directory}/INSIDER/TE_DETECTION/TSD/TSD_${{TE}}.txt -A 2 | grep -e "--|[A-Z]*|--" -o | grep "[A-Z]*" -o | awk '{{print length($0)}}' || echo "NONE"`
                else
                    SIZE_TE="NONE";
                fi;
            fi;
            #echo "TSD_OK : $TSD_OK";

            if [ ! -n "$SIZE_TE" ]; then
                SIZE_TE="NONE"; 
            fi;

            #TSD NEW POS
            NEW_POS="INSIDER";
            #echo "NEW_POS : $NEW_POS";
            #echo

            #FREQUENCE
            FREQ_BEFOR=`grep -w "$TE|$ID" {params.work_directory}/INSIDER/FREQ_INSIDER/DEPTH_TE_INSIDER.csv | cut -f 6 || echo "NONE"`
            FREQ_AFTER="INSIDER";

            #GET ID_TrEMOLO
            ID_POS=`echo $line | awk '{{print $1":"$2}}' | ${{path_to_pipline}}/lib/C++/bin/chain_to_id`
            TYPE=`grep -w "$ID" {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_COMBINE_TE.csv | cut -f 2 | cut -d ":" -f 3 || echo "UNKNOWN"`

            SV_SIZE=`grep -w "$ID" {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out.Assemblytics_structural_variants.bed | awk '
                $7=="Deletion" || $7=="Repeat_contraction" || $7=="Tandem_contraction" {{ print $5 }} 
                $7=="Insertion" || $7=="Repeat_expansion" || $7=="Tandem_expansion" {{ print $9 }}
                ' || echo "NONE"`;
            ! test -n "$SV_SIZE" && SV_SIZE="NONE";

            ##ID_TrEMOLO="TE_ID_INSIDER.$ID_POS.$TYPE.$num_TE_INSIDER";
            ID_TrEMOLO="TE_ID_INSIDER.$ID_POS.$TYPE";

            echo -e "$chrom\t$start\t$end\t$TE|$ID\t$strand\t$TSD_OK\t$pident\t$size_per\t$SIZE_TE\t$NEW_POS\t$FREQ_BEFOR\t$FREQ_AFTER\t$SV_SIZE\t$ID_TrEMOLO\t$TYPE" >> {params.work_directory}/TE_INFOS.bed

            i=$(($i + 1));

            show_step="$i/$NB_TE TE"
            number_of_char=`echo "$show_step" | wc -c`
            number_of_char=$(($number_of_char-1));
            printf "\b%.0s" `seq 1 $number_of_char`
            printf "$show_step";

            num_TE_INSIDER=$(($num_TE_INSIDER+1));
        done < {params.work_directory}/POSITION_TE_INSIDER.bed;
        rm -f {params.work_directory}/ID_INSIDER_INTERSECT_TO_DEL.txt

        echo

        ######------------------------------
        #BUILD FILE to report.html
        echo "BUILD FILE report.html..."
        if [ {params.REPORT}  = "True" ]; then

            cp -r ${{path_to_pipline}}/report/* {params.work_directory}/REPORT/

            ## TSD
            echo "  BUILD TSD CHART..."
            echo "TSD OK" >  {params.work_directory}/.tmp_orderc.txt
            echo "TSD KO" >> {params.work_directory}/.tmp_orderc.txt

            test -s {params.work_directory}/VALUES_TSD_GROUP_OUTSIDER.csv && \
                python3 ${{path_to_pipline}}/lib/python/graphs/conv_js_histo_grouped_ggplot.py \
                {params.work_directory}/VALUES_TSD_GROUP_OUTSIDER.csv data -c {params.work_directory}/.tmp_orderc.txt > {params.work_directory}/REPORT/mini_report/js/TSD_OUTSIDER.js && \
                sed 's/%%VAR_JS%%/TSD_OUTSIDER.js/g' {params.work_directory}/REPORT/mini_report/lib/template_TSD_CHART.html \
                 > {params.work_directory}/REPORT/mini_report/lib/template_TSD_OUTSIDER_CHART.html

            test -s {params.work_directory}/VALUES_TSD_INSIDER_GROUP.csv && \
                python3 ${{path_to_pipline}}/lib/python/graphs/conv_js_histo_grouped_ggplot.py \
                {params.work_directory}/VALUES_TSD_INSIDER_GROUP.csv data -c {params.work_directory}/.tmp_orderc.txt > {params.work_directory}/REPORT/mini_report/js/TSD_INSIDER.js && \
                sed 's/%%VAR_JS%%/TSD_INSIDER.js/g' {params.work_directory}/REPORT/mini_report/lib/template_TSD_CHART.html \
                 > {params.work_directory}/REPORT/mini_report/lib/template_TSD_INSIDER_CHART.html \
                || sed -i '/TSD_INSIDER_histo/d' {params.work_directory}/REPORT/mini_report/insider.Rmd

            test -s {params.work_directory}/VALUES_TSD_ALL_GROUP.csv && \
                python3 ${{path_to_pipline}}/lib/python/graphs/conv_js_histo_grouped_ggplot.py \
                {params.work_directory}/VALUES_TSD_ALL_GROUP.csv data -c {params.work_directory}/.tmp_orderc.txt > {params.work_directory}/REPORT/mini_report/js/TSD_INOUTSIDER.js && \
                sed 's/%%VAR_JS%%/TSD_INOUTSIDER.js/g' {params.work_directory}/REPORT/mini_report/lib/template_TSD_CHART.html \
                 > {params.work_directory}/REPORT/mini_report/lib/template_TSD_INOUTSIDER_CHART.html\
                || sed -i '/TSD_ALL_histo/d' {params.work_directory}/REPORT/mini_report/inoutsider.Rmd

            rm -f {params.work_directory}/.tmp_orderc.txt

            samtools faidx {input.genome}
            mkdir -p {params.work_directory}/js

            echo "  BUILD chroms for scatter FREQUENCY js ..."
            cut -f 1 {params.work_directory}/TE_INFOS.bed | sort -u > {params.work_directory}/tmp_chrom_with_TE.txt
            grep -E `echo "{params.CHROM_KEEP}" | tr "," "|"` {input.genome}.fai | grep -w -f {params.work_directory}/tmp_chrom_with_TE.txt | awk 'BEGIN{{print "var chroms = {{"}} {{print "   \\""$1"\\" : "$2","}} END{{print "}}"}}'  > {params.work_directory}/js/chroms.js || fail_msg "ERROR : NO CHROM IN REPORT\\n"
            grep -E `echo "{params.CHROM_KEEP}" | tr "," "|"` {input.genome}.fai | grep -w -f {params.work_directory}/tmp_chrom_with_TE.txt | awk 'BEGIN{{print "const all_data = {{"}} {{print "   \\""$1"\\" : data"$1","}} END{{print "}}"}}'   > {params.work_directory}/js/data_ALL_FREQ_CHROM.js || fail_msg "ERROR : NO TE FOR FREQUENCY IN REPORT\\n"
            path_fai=`realpath {input.genome}.fai`;

            echo "  BUILD group for scatter FREQUENCY js ..."

            ###GET SV TYPE
            grep OUTSIDER {params.work_directory}/TE_INFOS.bed | awk ' {{print $15}}' | sort -u | awk 'BEGIN{{chain="var typesSV = [";}} {{ if(NR==1){{chain=chain"\\""$1"\\""}}else{{chain=chain", \\""$1"\\""}} }} END{{chain=chain"]"; print chain; }}' > {params.work_directory}/js/groups_OUTSIDER.js || warn_msg "Warning : NO OUTSIDER IN REPORT\\n"
            grep INSIDER {params.work_directory}/TE_INFOS.bed | awk ' {{print $15}}' | sort -u | awk 'BEGIN{{chain="var typesSV = [";}} {{ if(NR==1){{chain=chain"\\""$1"\\""}}else{{chain=chain", \\""$1"\\""}} }} END{{chain=chain"]"; print chain; }}' > {params.work_directory}/js/groups_INSIDER.js || warn_msg "Warning : NO INSIDER IN REPORT\\n"
            #####INOUTSIDER
            awk 'NR>1 {{print $15}}' {params.work_directory}/TE_INFOS.bed | sort -u | awk 'BEGIN{{chain="var typesSV = [";}} {{ if(NR==1){{chain=chain"\\""$1"\\""}}else{{chain=chain", \\""$1"\\""}} }} END{{chain=chain"]"; print chain; }}' > {params.work_directory}/js/groups_INOUTSIDER.js || warn_msg "Warning : NO TE IN REPORT\\n"
            
            echo "  STRAND OUTSIDER"
            ## forward reverse OUTSIDER
            test -s {params.work_directory}/TE_INFOS.bed && test -s {params.work_directory}/POSITION_TE_OUTSIDER.bed && \
                grep OUTSIDER {params.work_directory}/TE_INFOS.bed | awk '{{
                    split($4, sp, "|"); 
                    
                    if($5 == "-"){{
                        dico["-"][sp[1]]+=1;
                        if(! dico["+"][sp[1]]){{
                            dico["+"][sp[1]] = 0;
                        }}
                    }}
                    else{{
                        dico["+"][sp[1]] += 1; 
                        if(! dico["-"][sp[1]]){{
                            dico["-"][sp[1]] = 0;
                        }}
                    }}
                }}

                END{{
                    chain = "var data = ["
                    for(TE in dico["-"]){{
                        chain = chain"\\n{{TEname: \\""TE"\\", reverse: -"dico["-"][TE]", forward: "dico["+"][TE]"}},"
                    }}
                    print substr(chain, 1, length(chain)-1)"\\n]";
                }}' > {params.work_directory}/REPORT/mini_report/js/TE_COUNT_SENS_ANTISENS_OUTSIDER.js
            
            sed 's/%%VAR_JS%%/TE_COUNT_SENS_ANTISENS_OUTSIDER.js/g' {params.work_directory}/REPORT/mini_report/lib/template_COUNT_TE_SENS_ANTISENS.html \
                 > {params.work_directory}/REPORT/mini_report/lib/template_COUNT_TE_SENS_ANTISENS_OUTSIDER.html


            echo "  STRAND INSIDER"
            ## STRAND INSIDER
            test -s {params.work_directory}/TE_INFOS.bed && test -s {params.work_directory}/POSITION_TE_INSIDER.bed && \
                grep INSIDER {params.work_directory}/TE_INFOS.bed | awk '{{
                    split($4, sp, "|"); 
                    
                    if($5 == "-"){{
                        dico["-"][sp[1]]+=1;
                        if(! dico["+"][sp[1]]){{
                            dico["+"][sp[1]] = 0;
                        }}
                    }}
                    else{{
                        dico["+"][sp[1]] += 1; 
                        if(! dico["-"][sp[1]]){{
                            dico["-"][sp[1]] = 0;
                        }}
                    }}
                }}

                END{{
                    chain = "var data = ["
                    for(TE in dico["-"]){{
                        chain = chain"\\n{{TEname: \\""TE"\\", reverse: -"dico["-"][TE]", forward: "dico["+"][TE]"}},"
                    }}
                    print substr(chain, 1, length(chain)-1)"\\n]";
                }}' > {params.work_directory}/REPORT/mini_report/js/TE_COUNT_SENS_ANTISENS_INSIDER.js
                

            sed 's/%%VAR_JS%%/TE_COUNT_SENS_ANTISENS_INSIDER.js/g' {params.work_directory}/REPORT/mini_report/lib/template_COUNT_TE_SENS_ANTISENS.html \
                 > {params.work_directory}/REPORT/mini_report/lib/template_COUNT_TE_SENS_ANTISENS_INSIDER.html

            
            echo "  STRAND INOUTSIDER"
            ## STRAND INOUTSIDER
            test -s {params.work_directory}/TE_INFOS.bed && \
                awk '{{
                    split($4, sp, "|"); 
                    
                    if($5 == "-"){{
                        dico["-"][sp[1]]+=1;
                        if(! dico["+"][sp[1]]){{
                            dico["+"][sp[1]] = 0;
                        }}
                    }}
                    else{{
                        dico["+"][sp[1]] += 1; 
                        if(! dico["-"][sp[1]]){{
                            dico["-"][sp[1]] = 0;
                        }}
                    }}
                }}

                END{{
                    chain = "var data = ["
                    for(TE in dico["-"]){{
                        chain = chain"\\n{{TEname: \\""TE"\\", reverse: -"dico["-"][TE]", forward: "dico["+"][TE]"}},"
                    }}
                    print substr(chain, 1, length(chain)-1)"\\n]";
                }}' {params.work_directory}/TE_INFOS.bed \
                     > {params.work_directory}/REPORT/mini_report/js/TE_COUNT_SENS_ANTISENS_INOUTSIDER.js

            sed 's/%%VAR_JS%%/TE_COUNT_SENS_ANTISENS_INOUTSIDER.js/g' {params.work_directory}/REPORT/mini_report/lib/template_COUNT_TE_SENS_ANTISENS.html \
                 > {params.work_directory}/REPORT/mini_report/lib/template_COUNT_TE_SENS_ANTISENS_INOUTSIDER.html


            cp {params.work_directory}/js/* {params.work_directory}/REPORT/mini_report/js/
            
            rm -fr {params.work_directory}/js


            ## CHANGE PATH
            old_path=`pwd`
            cd {params.work_directory}/REPORT/mini_report/

            #INSIDER
            ## TODO GESTION DE SUPPRESSION
            if [ {params.choice_insider_sv} != "True" ]; then
                rm -f insider.Rmd
            else
                ! test -s ../../INSIDER/FREQ_INSIDER/DEPTH_TE_INSIDER.csv && \
                   sed -i 's/r FREQIN, eval=TRUE,/r FREQIN, eval=FALSE,/g' insider.Rmd  && \
                   sed -i '/FREQUENCE/d' insider.Rmd
                cat insider.Rmd >> index.Rmd
                mv insider.Rmd insider.Rmd.tmp
            fi;

            #OUTSIDER
            ## TODO GESTION DE SUPPRESSION
            if [ {params.choice_outsider_sv} != "True" ]; then
                rm -f outsider.Rmd
            else
                cat outsider.Rmd >> index.Rmd
                mv outsider.Rmd outsider.Rmd.tmp
            fi;


            #INOUTSIDER
            ## TODO GESTION DE SUPPRESSION
            if [ {params.choice_outsider_sv} != "True" ] || [ {params.choice_insider_sv} != "True" ]; then
                rm -f inoutsider.Rmd
            else
                ! test -s ../../INSIDER/FREQ_INSIDER/DEPTH_TE_INSIDER.csv && \
                   sed -i 's/r FREQ_INOUT, eval=TRUE,/r FREQ_INOUT, eval=FALSE,/g' inoutsider.Rmd  && \
                   sed -i '/FREQUENCE/d' inoutsider.Rmd
                cat inoutsider.Rmd >> index.Rmd
                mv inoutsider.Rmd inoutsider.Rmd.tmp
            fi;

            #REMOVE OR COUNT INSIDER
            ## TODO GESTION DE SUPPRESSION
            if ! test -s ../../INSIDER/TE_DETECTION/INSERTION.csv ; then
                sed -i 's/r COUNT_TE_INSIDER_INSERTION, eval=TRUE,/r, eval=FALSE,/g' index.Rmd

                #DELET LINE USELESS
                sed -i '/TE_INSIDER_INS/d' index.Rmd
                sed -i '/TE_INSIDER.[a-z]/d' index.Rmd
            else
                #COUNT

                awk -F "\t" 'BEGIN{{print "name,value"}}NR>1{{print $2","$3}}' ../../INSIDER/TE_DETECTION/INSERTION_COUNT_TE.csv  > tmp.csv
                python3 ${{path_to_pipline}}/lib/python/graphs/conv_js_histo_grouped.py tmp.csv data > js/COUNT_TE_INSIDER.js


                test -s js/COUNT_TE_INSIDER.js && \
                    sed 's/%%VAR_JS%%/COUNT_TE_INSIDER.js/g' lib/template_COUNT_TE.html > lib/template_COUNT_TE_INSIDER.html;

                #FREQUENCE INSIDER
                test -s ../../INSIDER/FREQ_INSIDER/DEPTH_TE_INSIDER.csv && \
                    awk 'BEGIN{{print "name,value"}} NR>1 {{print $7","$6}}' ../../INSIDER/FREQ_INSIDER/DEPTH_TE_INSIDER.csv > tmp_freq.csv
                
                test -s tmp_freq.csv && \
                    python3 ${{path_to_pipline}}/lib/python/graphs/conv_js_histo_grouped.py tmp_freq.csv data_freq > js/FREQ_TE_INSIDER.js
                test -s ../../INSIDER/TE_DETECTION/INSERTION_COUNT_TE.csv && \
                    awk -F "\t" 'BEGIN{{chain="var order = ["}} NR>1 {{ if(NR!=2){{ chain=chain", \\""$2"\\""}}else{{chain=chain"\\""$2"\\""}} }} END{{print chain"]"}}' ../../INSIDER/TE_DETECTION/INSERTION_COUNT_TE.csv >> js/FREQ_TE_INSIDER.js


                #HERE
                test -s js/FREQ_TE_INSIDER.js && \
                    sed 's/%%VAR_JS%%/FREQ_TE_INSIDER.js/g' lib/template_FREQ_TE.html > lib/template_FREQ_TE_INSIDER.html;

                #TODO calcul FREQ

                bedtools sort -i ../../TE_INFOS.bed | grep INSIDER | awk -v IN_OUT="INSIDER" '
                    BEGIN{{print "chrom\tx\ty\tgroup\tname\ttype\tIN_OUT\tID"}} 
                    OFS="\t" {{
                        if($11 != "NONE" && $11 != "INSIDER"){{FREQ=$11}}else{{FREQ="NONE"}};  
                        if(FREQ!="NONE"){{ split($4, sp, "|"); split(sp[2], group, "."); print $1, $2, FREQ/100, $15, $1":"$2":"sp[1], $5, IN_OUT, $4}} 
                    }}' | tr "," "." > tmp_scatter.csv || (echo "ERROR: NO INSIDER FOR FREQUENCY FOUND")
                
                awk '
                    BEGIN{{
                        gen="";
                        name="";
                        chrom="";
                        id="";
                        type="";
                        IN_OUT="";
                    }} 

                    NR>1 {{
                        if( chrom != $1 ){{
                            if( chrom != "" ){{
                                print "\\"type\\": \\""type"\\",";
                                print "\\"id\\": \\""id"\\",";
                                print "\\"name\\": \\""name"\\"\\n}}];\\n\\n";
                            }}

                            chrom=$1;

                            print "var data"chrom" = [{{";
                            print "\\""$4"x\\": "$2",";
                            print "\\""$4"y\\": "$3",";
                            print "\\""$4"io\\": \\""$7"\\",";
                            gen=$4;
                            id=$5;
                            type=$6;
                            IN_OUT=$7;
                            split($5, sp, ":");
                            name=sp[3];
                        }}
                        else if( id != $5 ){{
                            print "\\"type\\": \\""type"\\",";
                            print "\\"id\\": \\""id"\\",";
                            print "\\"name\\": \\""name"\\"";
                            print "}}, {{\\n""\\""$4"x\\": "$2",";
                            print "\\""$4"y\\": "$3",";
                            print "\\""$4"io\\": \\""$7"\\",";
                            gen=$4;
                            id=$5;
                            type=$6;
                            IN_OUT=$7;
                            split($5, sp, ":");
                            name=sp[3];
                        }}
                        else {{
                            print "\\""$4"x\\": "$2",";
                            print "\\""$4"y\\": "$3",";
                            print "\\""$4"io\\": \\""$7"\\",";
                        }}
                    }}

                    END{{
                        print "\\"name\\": \\""name"\\"\\n}}]";
                    }}' tmp_scatter.csv > js/FREQ_TE_INSIDER_CHROM.js

                #rest chrom
                awk 'NR>1 {{ print $1 }}' tmp_scatter.csv | sort -u > tmp_chrom.txt
                grep -v -f tmp_chrom.txt ${{path_fai}} | cut -f 1 | awk '{{print "var data"$1" = []"}}' >> js/FREQ_TE_INSIDER_CHROM.js || echo ""

                test -s js/FREQ_TE_INSIDER_CHROM.js && \
                    sed 's/%%VAR_JS%%/FREQ_TE_INSIDER_CHROM.js/g' lib/template_FREQ_CHROM.html > lib/template_FREQ_CHROM_INSIDER.html

                test -s js/groups_INSIDER.js && \
                    sed -i 's/%%VAR_GROUP%%/groups_INSIDER.js/g' lib/template_FREQ_CHROM_INSIDER.html

                rm -f tmp.csv tmp_freq.csv
            fi;


            #REMOVE OR COUNT INSIDER DELETION
            ## TODO GESTION DE SUPPRESSION
            if ! test -s ../../INSIDER/TE_DETECTION/DELETION.csv ; then
                sed -i 's/r COUNT_TE_INSIDER_DELETION, eval=TRUE,/r, eval=FALSE,/g' index.Rmd
                
                #DELET LINE INUTILE
                sed -i '/TE_INSIDER_DEL/d' index.Rmd
            else
                awk -F "\t" 'BEGIN{{print "name,value"}}NR>1{{print $2","$3}}' ../../INSIDER/TE_DETECTION/DELETION_COUNT_TE.csv  > tmp.csv
                python3 ${{path_to_pipline}}/lib/python/graphs/conv_js_histo_grouped.py tmp.csv data > js/COUNT_TE_INSIDER_DEL.js
                rm -f tmp.csv
            fi;

            #REMOVE OR COUNT OUTSIDER
            ## TODO GESTION DE SUPPRESSION
            if ! test -s ../../OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv ; then
                sed -i 's/r NB_OUTSIDER, eval=TRUE,/r, eval=FALSE,/g' index.Rmd
                sed -i 's/r TSD, eval=TRUE,/r, eval=FALSE,/g' index.Rmd
                sed -i 's/r FREQ, eval=TRUE,/r, eval=FALSE,/g' index.Rmd

                sed -i '/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE/d' index.Rmd
            else
                #COUNT
                awk -F "\t" 'BEGIN{{print "name,value"}}NR>1{{print $2","$3}}' ../../OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL_COUNT.csv > tmp.csv
                python3 ${{path_to_pipline}}/lib/python/graphs/conv_js_histo_grouped.py tmp.csv data > js/COUNT_TE_OUTSIDER.js

                test -s js/COUNT_TE_OUTSIDER.js && \
                    sed 's/%%VAR_JS%%/COUNT_TE_OUTSIDER.js/g' lib/template_COUNT_TE.html > lib/template_COUNT_TE_OUTSIDER.html

                #FREQUENCE OUTSIDER
                test -s ../../TE_INFOS.bed && \
                    grep OUTSIDER ../../TE_INFOS.bed | awk '
                        BEGIN{{print "name,value"}} 
                        $12!="NONE" {{ split($4, TEID, "|"); print TEID[1]","$12 }}  
                        $12=="NONE" && $11!="NONE" {{ split($4, TEID, "|"); print TEID[1]","$11 }}
                        ' > tmp_freq.csv

                test -s tmp_freq.csv && \
                    python3 ${{path_to_pipline}}/lib/python/graphs/conv_js_histo_grouped.py tmp_freq.csv data_freq > js/FREQ_TE_OUTSIDER.js && \
                test -s ../../OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL_COUNT.csv && \
                    awk -F "\t" 'BEGIN{{chain="var order = ["}} NR>1 {{ if(NR!=2){{ chain=chain", \\""$2"\\""}}else{{chain=chain"\\""$2"\\""}} }} END{{print chain"]"}}' ../../OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL_COUNT.csv >> js/FREQ_TE_OUTSIDER.js

                test -s js/FREQ_TE_OUTSIDER.js && \
                    sed 's/%%VAR_JS%%/FREQ_TE_OUTSIDER.js/g' lib/template_FREQ_TE.html > lib/template_FREQ_TE_OUTSIDER.html

                
                #TODO calcul FREQ OUT

                 bedtools sort -i ../../TE_INFOS.bed | grep OUTSIDER | awk -v IN_OUT="OUTSIDER" '
                    BEGIN{{ print "chrom\tx\ty\tgroup\tname\ttype\tIN_OUT\tID" }} 
                    OFS="\t" {{ 
                        if($12 != "NONE"){{FREQ=$12}}else if($11 != "NONE"){{FREQ=$11}}else{{FREQ="NONE"}};  
                        if(FREQ!="NONE"){{ split($4, sp, "|"); split(sp[2], group, "."); print $1, $2, FREQ/100, $15, $1":"$2":"sp[1], $5, IN_OUT, $4}} 
                    }}' | tr "," "." > tmp_scatter.csv

                awk '
                    BEGIN{{
                        gen="";
                        name="";
                        chrom="";
                        id="";
                        type="";
                        IN_OUT="";
                    }} 

                    NR>1 {{
                        if( chrom != $1 ){{
                            if( chrom != "" ){{
                                print "\\"type\\": \\""type"\\",";
                                print "\\"id\\": \\""id"\\",";
                                print "\\"name\\": \\""name"\\"\\n}}];\\n\\n";
                            }}

                            chrom=$1;

                            print "var data"chrom" = [{{";
                            print "\\""$4"x\\": "$2",";
                            print "\\""$4"y\\": "$3",";
                            print "\\""$4"io\\": \\""$7"\\",";
                            gen=$4;
                            id=$5;
                            type=$6;
                            IN_OUT=$7;
                            split($5, sp, ":");
                            name=sp[3];
                        }}
                        else if( id != $5 ){{
                            print "\\"type\\": \\""type"\\",";
                            print "\\"id\\": \\""id"\\",";
                            print "\\"name\\": \\""name"\\"";
                            print "}}, {{\\n""\\""$4"x\\": "$2",";
                            print "\\""$4"y\\": "$3",";
                            print "\\""$4"io\\": \\""$7"\\",";
                            gen=$4;
                            id=$5;
                            type=$6;
                            IN_OUT=$7;
                            split($5, sp, ":");
                            name=sp[3];
                        }}
                        else {{
                            print "\\""$4"x\\": "$2",";
                            print "\\""$4"y\\": "$3",";
                            print "\\""$4"io\\": \\""$7"\\",";
                        }}
                    }}

                    END{{
                        print "\\"name\\": \\""name"\\"\\n}}]";
                    }}' tmp_scatter.csv > js/FREQ_TE_OUTSIDER_CHROM.js

                cut -f 1 tmp_scatter.csv | sort -u > tmp_chrom.txt
                grep -v -f tmp_chrom.txt ${{path_fai}} | cut -f 1 | awk '{{print "var data"$1" = []"}}' >> js/FREQ_TE_OUTSIDER_CHROM.js || echo ""
                test -s js/FREQ_TE_OUTSIDER_CHROM.js && \
                    sed 's/%%VAR_JS%%/FREQ_TE_OUTSIDER_CHROM.js/g' lib/template_FREQ_CHROM.html > lib/template_FREQ_CHROM_OUTSIDER.html

                test -s js/groups_OUTSIDER.js && \
                    sed -i 's/%%VAR_GROUP%%/groups_OUTSIDER.js/g' lib/template_FREQ_CHROM_OUTSIDER.html

                rm -f tmp.csv tmp_freq.csv tmp_scatter.csv

                rm -f tmp.csv
            fi;

            ## GET AUTHOR RANDOM
            #author=`(curl "localhost:4242/author" > tmp_author.txt && cat tmp_author.txt) || echo "<strong>Author<\/strong> : Maybe You ?"`
            author=`(curl https://author.infinity-atom.fr/author > tmp.txt && cat tmp.txt) || echo "<strong>Author<\/strong> : Maybe You ?"`
            
            if [ `echo $author | grep "404 Not Found" -c` -eq 1 ]; 
            then 
                sed -i "s/unknown/<strong>Author<\/strong> : Maybe You ?/g" index.Rmd
            else
                sed -i "s/unknown/$author/g" index.Rmd
            fi;

            #rm -f tmp_author.txt

            #REMOVE OR COUNT INOUTSIDER
            ## TODO GESTION DE SUPPRESSION
            if ! test -s ../../INSIDER/TE_DETECTION/INSERTION.csv || ! test -s ../../OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv; then
                echo "ERROR NO TE INSERTION FOUND";
            else
                test -s ../../TE_INFOS.bed && \
                    awk 'NR>1 {{split($4, sp, "|"); print sp[1]}}' ../../TE_INFOS.bed | sort | uniq -c | awk '{{print $1"\t"$2}}' | sort -k 1 -n | awk 'BEGIN{{print "x\ty\tz"}} OFS="\t"{{print "", $2, $1}}' > tmp_ALL_TE_COUNT.csv
                
                awk -F "\t" 'BEGIN{{print "name,value"}}NR>1{{print $2","$3}}' tmp_ALL_TE_COUNT.csv  > tmp.csv
                python3 ${{path_to_pipline}}/lib/python/graphs/conv_js_histo_grouped.py tmp.csv data > js/COUNT_TE_INOUTSIDER.js

                test -s js/COUNT_TE_INOUTSIDER.js && \
                    sed 's/%%VAR_JS%%/COUNT_TE_INOUTSIDER.js/g' lib/template_COUNT_TE.html > lib/template_COUNT_TE_INOUTSIDER.html

                #FREQUENCE INOUTSIDER
                #test -s ../../OUTSIDER/FREQ_OPTIMIZED/DEPTH_TE.csv && \
                #    awk 'BEGIN{{print "name,value"}} NR>1 {{print $7","$6}}' ../../OUTSIDER/FREQ_OPTIMIZED/DEPTH_TE.csv > tmp_freq.csv
                    
                #! test -s ../../OUTSIDER/FREQ_OPTIMIZED/DEPTH_TE.csv && test -s ../../OUTSIDER/TE_DETECTION/DEPTH_TE.csv && \
                #    awk 'BEGIN{{print "name,value"}} NR>1 {{print $7","$6}}' ../../OUTSIDER/TE_DETECTION/DEPTH_TE.csv > tmp_freq.csv
                
                #test -s ../../OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL_COUNT.csv && \
                #    awk -F "\t" 'BEGIN{{chain="var order = ["}} NR>1 {{ if(NR!=2){{ chain=chain", \\""$2"\\""}}else{{chain=chain"\\""$2"\\""}} }} END{{print chain"]"}}' ../../OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL_COUNT.csv >> js/FREQ_TE_OUTSIDER.js

                #test -s ../../INSIDER/FREQ_INSIDER/DEPTH_TE_INSIDER.csv && \
                #    awk 'NR>1 {{print $7","$6}}' ../../INSIDER/FREQ_INSIDER/DEPTH_TE_INSIDER.csv >> tmp_freq.csv

                #test -s tmp_freq.csv && \
                #    python3 ${{path_to_pipline}}/lib/python/graphs/conv_js_histo_grouped.py tmp_freq.csv data_freq > js/FREQ_TE_INOUTSIDER.js
                
                #test -s ../../INSIDER/TE_DETECTION/INSERTION_COUNT_TE.csv && \
                #    awk -F "\t" 'BEGIN{{chain="var order = ["}} NR>1 {{ if(NR!=2){{ chain=chain", \\""$2"\\""}}else{{chain=chain"\\""$2"\\""}} }} END{{print chain"]"}}' ../../INSIDER/TE_DETECTION/INSERTION_COUNT_TE.csv >> js/FREQ_TE_INOUTSIDER.js

                #test -s js/FREQ_TE_INOUTSIDER.js && \
                #    sed 's/%%VAR_JS%%/FREQ_TE_INOUTSIDER.js/g' lib/template_FREQ_TE.html > lib/template_FREQ_TE_INOUTSIDER.html;

                #TODO calcul FREQ INOUT
                bedtools sort -i ../../TE_INFOS.bed | awk -v IN_OUT="INOUTSIDER" '
                    BEGIN{{ print "chrom\tx\ty\tgroup\tname\ttype\tIN_OUT\tID" }} 
                    OFS="\t" {{ 
                        if($12 != "NONE"){{FREQ=$12}}else if($11 != "NONE"){{FREQ=$11}}else{{FREQ="NONE"}};  
                        if(FREQ!="NONE"){{ split($4, sp, "|"); split(sp[2], group, "."); print $1, $2, FREQ/100, $15, $1":"$2":"sp[1], $5, IN_OUT, $4}} 
                    }}' | tr "," "." > tmp_scatter.csv

                awk '
                    BEGIN{{
                        gen="";
                        name="";
                        chrom="";
                        id="";
                        type="";
                        IN_OUT="";
                    }} 

                    NR>1 {{
                        if( chrom != $1 ){{
                            if( chrom != "" ){{
                                print "\\"type\\": \\""type"\\",";
                                print "\\"id\\": \\""id"\\",";
                                print "\\"name\\": \\""name"\\"\\n}}];\\n\\n";
                            }}

                            chrom=$1;

                            print "var data"chrom" = [{{";
                            print "\\""$4"x\\": "$2",";
                            print "\\""$4"y\\": "$3",";
                            print "\\""$4"io\\": \\""$7"\\",";
                            gen=$4;
                            id=$5;
                            type=$6;
                            IN_OUT=$7;
                            split($5, sp, ":");
                            name=sp[3];
                        }}
                        else if( id != $5 ){{
                            print "\\"type\\": \\""type"\\",";
                            print "\\"id\\": \\""id"\\",";
                            print "\\"name\\": \\""name"\\"";
                            print "}}, {{\\n""\\""$4"x\\": "$2",";
                            print "\\""$4"y\\": "$3",";
                            print "\\""$4"io\\": \\""$7"\\",";
                            gen=$4;
                            id=$5;
                            type=$6;
                            IN_OUT=$7;
                            split($5, sp, ":");
                            name=sp[3];
                        }}
                        else {{
                            print "\\""$4"x\\": "$2",";
                            print "\\""$4"y\\": "$3",";
                            print "\\""$4"io\\": \\""$7"\\",";
                        }}
                    }}

                    END{{
                        print "\\"name\\": \\""name"\\"\\n}}]";
                    }}' tmp_scatter.csv > js/FREQ_TE_INOUTSIDER_CHROM.js

                cut -f 1 tmp_scatter.csv | sort -u > tmp_chrom.txt
                grep -v -f tmp_chrom.txt ${{path_fai}} | cut -f 1 | awk '{{print "var data"$1" = []"}}' >> js/FREQ_TE_INOUTSIDER_CHROM.js || echo ""
                test -s js/FREQ_TE_INOUTSIDER_CHROM.js && \
                    sed 's/%%VAR_JS%%/FREQ_TE_INOUTSIDER_CHROM.js/g' lib/template_FREQ_CHROM.html > lib/template_FREQ_CHROM_INOUTSIDER.html

                test -s js/groups_INOUTSIDER.js && \
                    sed -i 's/%%VAR_GROUP%%/groups_INOUTSIDER.js/g' lib/template_FREQ_CHROM_INOUTSIDER.html

                rm -f tmp.csv tmp_freq.csv tmp_scatter.csv
                rm -f tmp_ALL_TE_COUNT.csv
            fi;

            if ! test -e ../../VALUES_TSD_GROUP_OUTSIDER.csv; then
                sed -i 's/r TSD, eval=TRUE,/r, eval=FALSE,/g' index.Rmd
            fi;

            ## TIMELINE RULE ----------------------------------------------
            cat ../../log/Snakefile_*.err | grep "^rule" -B 2 | awk '
                BEGIN{{
                    chain=""
                }} 

                {{
                    if(substr($0, 1, 1) == "[" ){{ 
                        date=$0; 
                        rule="" 
                    }}else if(substr($0, 1, 4) == "rule"){{
                        split($0, sp, " "); 
                        rule=sp[2]; 
                        print date";"rule 
                    }} 
                }} ' > timeline.csv


            while read line; 
            do 

                date=`echo $line | cut -d ";" -f 1 | tr -d "[]"`; 
                rule=`echo $line | cut -d ";" -f 2 | tr -d ":"`;   
                datetime=`date -d "$date" +"%F %k:%M:%S"`; 
                echo "$datetime;$rule";  

            done < timeline.csv | awk -F ";" '
                BEGIN{{
                    start=""; 
                    end="";
                    print "data = [";
                }}
                {{
                    if( NR==1 ){{ 
                        start = $1; 
                        text=$2; 
                    }}
                    else{{
                        print "{{\\"category\\": \\""text"\\", \\"start\\": \\""start"\\", \\"end\\": \\""$1"\\", \\"text\\": \\""text"\\", color: colorSet.getIndex("(((NR * 4) % 16) + 1)")}},";
                        text=$2; 
                        start=$1;
                    }} 
                }}
                END{{
                    print "{{\\"category\\": \\""text"\\", \\"start\\": \\""start"\\", \\"end\\": \\""$1"\\", \\"text\\": \\""text"\\", color: colorSet.getIndex("((((NR+1) * 4) % 16) + 1)")}}\\n];";
                }} ' > js/data_timeline.js;


            #CHECKING R PACKAGES...
            echo "CHECKING R PACKAGES..."
            R --save -e 'if(!require(stringi)) install.packages("stringi")' >&2
            R --save -e 'if(!require(stringr)) install.packages("stringr")' >&2

            echo "MAKE REPORT"
            make

            cp -r ./lib ./js ./css ./web/

            path_to_report=`readlink -f ../report.html`

            printf "%s\\n" "{params.cmess} [SNK]--[`date`]--[INFO] CHECK $path_to_report [^-^] {params.cend}"

            cd $old_path
        fi;

        if [ {params.INTERMEDIATE_FILE} = "False" ]; then
            rm -fr {params.work_directory}/OUTSIDER
            rm -fr {params.work_directory}/INSIDER
            rm -f  {params.work_directory}/VALUES_TSD*
        fi;

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] BUILD REPORT DONE, CHECK {params.work_directory}/REPORT/report.html [^-^] {params.cend}"

        rm -f COMBINE_TE.csv
        rm -f {params.work_directory}/test.csv
        #rm -f {params.work_directory}/params.log;
        rm -fr {params.work_directory}/tmp* ;
        #rm -fr {params.work_directory}/INPUT
        """



#END REPORT






rule FIND_TE_ON_REF :
    input:
        ref         = config["DATA"]["REFERENCE"],
        genome_real = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_TOWARD_GENOME/PSEUDO_GENOME_TE_DB_ID.fasta",
        fasta_TE    = config["DATA"]["TE_DB"],
        all_te      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        sam         = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/INSIDER_VR/pm_against_ref.sam",
        delta       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/INSIDER_VR/pm_against_ref.sam.delta",
        bed         = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/INSIDER_VR/assemblytics_out.Assemblytics_structural_variants.bed",
        stats       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/INSIDER_VR/assemblytics_out.Assemblytics_assembly_stats.txt",
        input_link=[],
    output:
        output_link=[],
        
    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        call_sv         = config["CHOICE"]["OUTSIDER_VARIANT"]["CALL_SV"],

        env            = env, #source environnement

        pars_bln_option_insider = config["PARAMS"]["INSIDER_VARIANT"]["PARS_BLN_OPTION"],
        threads                 = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,


        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/FIND_TE_ON_REF",


    shell:
        #TODO broullion
        """

        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        rm -f `find {params.work_directory} -name "*.fai"`
        rm -f `find {params.work_directory} -name "*.fa*.fai"`

        samtools faidx {input.genome_real}
        samtools faidx {input.ref}
        samtools faidx {input.fasta_TE}

        rm -f {log}.*
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        
        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] ANNOT TE ON REF {params.cend}"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        {params.env}
        path_to_pipline=`dirname {params.path_snk}`
        
        rm -fr {params.work_directory}/INSIDER/TE_INSIDER_VR/*
        mkdir -p {params.work_directory}/INSIDER/TE_INSIDER_VR/

        #GETTING SEQUENCE FASTA INSERTION
        array_type=( "INSERTION" "Repeat_expansion" "Tandem_expansion" )
        for type in "${{array_type[@]}}"
        do
            echo "type=${{type}}";
            grep -i ${{type}} {input.bed} | awk '{{print $10":"$4}}' | awk -v type="${{type}}" -F ":" 'OFS="\t"{{split($2, a, "-"); print $1 , a[1], a[2], $4":"$3":"type}}' > {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bed || echo "[SNK  INFO]: ${{type}} NOT FOUND in bed file."
            test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bed || echo "[SNK  INFO]: ${{type}}.bed IS EMPTY"
            
            test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bed && \
                bedtools getfasta -fi {input.genome_real} -bed {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bed -name+ > {params.work_directory}/INSIDER/TE_INSIDER_VR/tmp_${{type}}_SEQ.fasta
            
            test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/tmp_${{type}}_SEQ.fasta || echo "[SNK  INFO]: tmp_${{type}}_SEQ.fasta IS EMPTY"
            
            #TODO warning get_seq_with_id.sh only svim
            ( test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/tmp_${{type}}_SEQ.fasta && \
                sh ${{path_to_pipline}}/lib/bash/get_seq_with_id.sh {params.work_directory}/INSIDER/TE_INSIDER_VR/tmp_${{type}}_SEQ.fasta {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta ) || echo "SEQUENCE $type NOT FOUND"
            
            #RENAME ID (ID_SV_ at on get_seq_with_id.sh)
            if [ {params.call_sv} = "svim" ]; then
                test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta && \
                    sed -i 's/ID_SV_/svim.INS./g' {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta
            else
                test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta && \
                    sed -i 's/ID_SV_//g' {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta
            fi;

            ( test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta && echo "NUMBER OF SEQUENCE" `grep ">" {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta -c ` ) || echo "[SNK  INFO]: ${{type}}_SEQ.fasta IS EMPTY"
            test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta && cat {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta >> {params.work_directory}/INSIDER/TE_INSIDER_VR/INSERTION_SEQ_ALL.fasta
        done;
        
        #cat {params.work_directory}/INSIDER/TE_INSIDER_VR/Tandem_expansion_SEQ.fasta {params.work_directory}/INSIDER/TE_INSIDER_VR/Repeat_expansion_SEQ.fasta {params.work_directory}/INSIDER/TE_INSIDER_VR/INSERTION_SEQ.fasta > {params.work_directory}/INSIDER/TE_INSIDER_VR/INSERTION_SEQ_ALL.fasta
        test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/INSERTION_SEQ_ALL.fasta && \
            cat {params.work_directory}/INSIDER/TE_INSIDER_VR/INSERTION_SEQ_ALL.fasta > {params.work_directory}/INSIDER/TE_INSIDER_VR/INSERTION_SEQ.fasta
        

        #GETTING SEQUENCE FASTA DELETION
        array_type_deletion=( "DELETION" "Repeat_contraction" "Tandem_contraction" );
        for type in "${{array_type_deletion[@]}}"
        do
            grep -i ${{type}}  {input.bed} | awk  -v type="$type" 'OFS="\t"{{print $1, $2, $3, $4":"$6":"type}}' > {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bed || echo "[SNK  INFO]: ${{type}} NOT FOUND in bed file."

            test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bed && \
                bedtools getfasta -fi {input.ref}  -bed {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bed -name+ > {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta

            test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta && cat {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta >> {params.work_directory}/INSIDER/TE_INSIDER_VR/DELETION_SEQ_ALL.fasta
        done;
        
        #cat {params.work_directory}/INSIDER/TE_INSIDER_VR/Tandem_contraction_SEQ.fasta {params.work_directory}/INSIDER/TE_INSIDER_VR/Repeat_contraction_SEQ.fasta {params.work_directory}/INSIDER/TE_INSIDER_VR/DELETION_SEQ.fasta > {params.work_directory}/INSIDER/TE_INSIDER_VR/DELETION_SEQ_ALL.fasta
        
        test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/DELETION_SEQ_ALL.fasta && \
            cat {params.work_directory}/INSIDER/TE_INSIDER_VR/DELETION_SEQ_ALL.fasta > {params.work_directory}/INSIDER/TE_INSIDER_VR/DELETION_SEQ.fasta

        #GETTING CSV TE
        array_type=( "INSERTION" "Repeat_expansion" "Tandem_expansion" "DELETION" "Repeat_contraction" "Tandem_contraction" )
        for type in "${{array_type[@]}}"
        do
            echo -e "\nTYPE : $type";

            if test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta; then
                
                awk 'BEGIN{{header="";}}{{if(substr($0, 1, 1) == ">"){{header=$0;}}else if(length($0)>30){{print header"\\n"$0}}}}' {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta > {params.work_directory}/INSIDER/TE_INSIDER_VR/tmp.fasta
                
                cat {params.work_directory}/INSIDER/TE_INSIDER_VR/tmp.fasta > {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta

                makeblastdb -in {input.fasta_TE} -dbtype nucl  2> {log}.err 1> {log}.out;

                blastn -num_threads {params.threads} -db {input.fasta_TE} \
                -query {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_SEQ.fasta \
                -outfmt 6 \
                -out {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bln 2> {log}.err 1> {log}.out;

                number_lines_bln=`cat {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bln | wc -l`
                if [ "$number_lines_bln" -gt 500000  ]; then
                    awk 'BEGIN{{qseqid=""; sseqid=""}}{{if(qseqid!=$1){{qseqid=$1; sseqid=$2; print $0;}}else if(sseqid==$2){{print $0}}}}' {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bln \
                        > {params.work_directory}/INSIDER/TE_INSIDER_VR/tmp_pre_filtre.bln

                    test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bln && \
                        python3 ${{path_to_pipline}}/lib/python/parsing/global_sv_id.py {params.pars_bln_option_insider} \
                             --combine_name {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_COMBINE_TE.csv \
                            {params.work_directory}/INSIDER/TE_INSIDER_VR/tmp_pre_filtre.bln \
                            {input.fasta_TE} \
                            {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.csv 
                else

                    test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bln && \
                        python3 ${{path_to_pipline}}/lib/python/parsing/global_sv_id.py {params.pars_bln_option_insider} \
                             --combine_name {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_COMBINE_TE.csv \
                            {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.bln \
                            {input.fasta_TE} \
                            {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.csv 
                fi;
                

                test -s {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.csv && \
                awk 'NR>1{{print $1}}' {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}.csv | sort | uniq -c | sort -k 1 -n | \
                    awk 'BEGIN{{print "x\ty\tz"}} OFS="\t"{{print "", $2, $1}}' > {params.work_directory}/INSIDER/TE_INSIDER_VR/${{type}}_COUNT_TE.csv

            fi;
        done;

        rm -f {params.work_directory}/INSIDER/TE_INSIDER_VR/tmp_*

        REF=`realpath -s {input.ref}`
        QUERY=`realpath -s {input.genome_real}`
        TREMOLO_PATH=`readlink -f ${{path_to_pipline}}`

        echo "REF :$REF"
        echo "QUERY :$QUERY"
        #echo "TREMOLO_PATH :$TREMOLO_PATH"

        #### CD
        ## CHANGE DIRECTORY
        path_work=`realpath {params.work_directory}`
        old_path=`dirname $path_work`
        cd {params.work_directory}/INSIDER/TE_INSIDER_VR/



        if test -s INSERTION.csv; then

            awk '{{print $2}}' INSERTION.csv | cut -d ":" -f 1 > ID_asm.txt
            grep -w -f ID_asm.txt ../../OUTSIDER/INSIDER_VR/assemblytics_out.Assemblytics_structural_variants.bed | awk 'OFS="\t"{{print $1, $2, $3, $4"|"$7}}' > TE_FOUND.bed

            grep -v "INSERTION" INSERTION.csv | awk -v size="4000" 'NR>1 && OFS="\t"{{split($2, a, ":"); 
                split(a[6], b, "-"); 
                if(b[1]-size > 0){{ print a[5] , b[1]-size, b[1], a[1]":LEFT\\n" a[5], b[2], b[2]+size, a[1]":RIGTH" }} else{{ print a[5] , b[1], b[1]+1, a[1]":LEFT\\n" a[5], b[2], b[2]+size, a[1]":RIGTH" }}
            }}' > tmp_Repeat_expension.bed

            echo "TE GENOME FLANKING TO REFERENCE...";
            bedtools getfasta -fi $QUERY -bed tmp_Repeat_expension.bed -name+ > tmp_Repeat_expension.fasta

            makeblastdb -in $REF -dbtype nucl
            blastn -num_threads {params.threads} -db $REF \
            -query tmp_Repeat_expension.fasta \
            -outfmt 6 \
            -out position_Repeat_expension.bln



            rm -f pos_TE_expension.bed pos_TE_insertion.bed pos_TE_insertion.csv

            if test -s position_Repeat_expension.bln ; then
                awk '{{if(!dic[$1]){{dic[$1]=$1; print $0 }} }}' position_Repeat_expension.bln | awk '$3>80 && $4>1500' > position_Repeat_expension_best_score.csv

                python3 $TREMOLO_PATH/lib/python/parsing/global_position_expansion.py position_Repeat_expension_best_score.csv position_Repeat_expension_best_score_size_pos.csv

                test -s position_Repeat_expension_best_score_size_pos.csv && \
                    cat position_Repeat_expension_best_score_size_pos.csv | cut -f 3 | awk -F ":" 'NR>1 {{print $1}} ' > ID.txt || echo "NO TE EXPENSION FOUND"

                awk 'OFS="\t"{{ split($4, a, "|"); print $0, a[1], a[2] }}' TE_FOUND.bed > TE_FOUND.csv

                test -s position_Repeat_expension_best_score_size_pos.csv && \
                    awk 'NR>1 && OFS="\t"{{split($3, a, ":"); print $0, a[1], a[2]":"a[3]}}' position_Repeat_expension_best_score_size_pos.csv > pos_expension.csv

                ## sort le fichier pos_TE_expension.csv
                test -s pos_expension.csv && \
                    python3 $TREMOLO_PATH/lib/python/parsing/global_position_all.py TE_FOUND.csv INSERTION.csv pos_expension.csv pos_TE_expension.csv

                test -s pos_TE_expension.csv && \
                    awk 'NR>1 && OFS="\t" {{print $1, $2, $2+1, $7}}'  pos_TE_expension.csv > pos_TE_expension.bed
            fi;

            
            rm -f POS_ALT_TE_OUTSIDER_ON_REF.bed
            if test -s TE_FOUND.bed; then

                for ID in `cat TE_FOUND.bed | cut -f 4 | cut -d "|" -f 1`; do 

                    TE=`grep -w "$ID" INSERTION.csv | cut -f 1`; 
                    line=`grep -w "$ID" TE_FOUND.bed | cut -f 1-3`;
                    ID_OUTSIDER=`grep -w "$ID" INSERTION.csv | cut -f 2 | cut -d ":" -f 7` #ID svim, or sniffles

                    ID_OUTSIDER_T=`(awk 'NR>1' ../../OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv | cut -f 2 | cut -d ":" -f 5 | grep -w "$ID_OUTSIDER") || echo ""`;

                    if [ -n "$TE" ] && [ -n "$ID_OUTSIDER_T" ] ; then
                        echo -e "$line\t$TE|$ID|$ID_OUTSIDER_T" >> POS_ALT_TE_OUTSIDER_ON_REF.bed;
                    fi;
                done;
            fi;
        fi;

        test -s pos_TE_insertion.csv && awk 'NR>1 && OFS="\t"{{ print $17, $18, $18+1, $19 }}' pos_TE_insertion.csv > pos_TE_insertion.bed
        ##POSTITION START PAR ASSEMBLITICS
        test -s pos_TE_expension.bed && cat pos_TE_expension.bed > $path_work/POS_TE_OUTSIDER_ON_REF.bed
        test -s pos_TE_insertion.bed && cat pos_TE_insertion.bed >> $path_work/POS_TE_OUTSIDER_ON_REF.bed
        ##POSITION ENTIEREMENT FOURNI PAR ASSEMBLITICS
        test -s POS_ALT_TE_OUTSIDER_ON_REF.bed && ln -f -s -r POS_ALT_TE_OUTSIDER_ON_REF.bed $path_work/

        rm -f ID*.txt

        rm -f pos_*
        rm -f Repeat*
        rm -f Tandem*
        rm -f *SEQ_ALL.fasta
        rm -f tmp*

        cd "$old_path";

        test -s POS_TE_*_ON_REF.bed && cat {params.work_directory}/POS_TE_*_ON_REF.bed > {params.work_directory}/POSITION_TE_ON_REF.bed

        rm -f {params.work_directory}/ID.txt
        
        
        """


#END FIND_TE_ON_REF



rule FIND_SV_ON_REF :
    input:
        ref         = config["DATA"]["REFERENCE"],
        genome_real = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_TOWARD_GENOME/PSEUDO_GENOME_TE_DB_ID.fasta",
        fasta_TE    = config["DATA"]["TE_DB"],
        all_te      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        input_link=[],
    output:
        output_link=[],
        sam   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/INSIDER_VR/pm_against_ref.sam",
        delta = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/INSIDER_VR/pm_against_ref.sam.delta",
        bed   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/INSIDER_VR/assemblytics_out.Assemblytics_structural_variants.bed",
        stats = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/INSIDER_VR/assemblytics_out.Assemblytics_assembly_stats.txt",
        

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement
        threads        = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,


        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

        step=0,

    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/FIND_TE_ON_REF",


    shell:
        #TODO broullion
        """

        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        rm -f {log}.*
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        
        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] FIND SV ON REF {params.cend}"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        mkdir -p {params.work_directory}/OUTSIDER/INSIDER_VR/
        mkdir -p {params.work_directory}/log/

        path_to_pipline=`dirname {params.path_snk}`

        minimap2 -ax asm5 --cs -t {params.threads} {input.ref} {input.genome_real} > {output.sam} 2> {params.work_directory}/log/pm_contigs_against_ref.sam.log

        python3 ${{path_to_pipline}}/lib/python/assemblitics/sam2delta.py {output.sam} || fail_msg "ERROR : SAM TO DELTA ✘\\n" | tee -a {log}.err;
        

        python3 ${{path_to_pipline}}/lib/python/assemblitics/Assemblytics_uniq_anchor.py \
            --delta {output.delta} \
            --unique-length 20000 \
            --out {params.work_directory}/OUTSIDER/INSIDER_VR/assemblytics_out \
            --keep-small-uniques || fail_msg "ERROR : Assemblytics_uniq_anchor.py ✘\\n" | tee -a {log}.err;


        perl ${{path_to_pipline}}/lib/perl/Assemblytics_between_alignments.pl \
            {params.work_directory}/OUTSIDER/INSIDER_VR/assemblytics_out.coords.tab \
            50 \
            20000 \
            all-chromosomes \
            exclude-longrange \
            bed > {params.work_directory}/OUTSIDER/INSIDER_VR/assemblytics_out.variants_between_alignments.bed || \
                fail_msg "ERROR : Assemblytics_between_alignments.pl ✘\\n" | tee -a {log}.err;


        python3 ${{path_to_pipline}}/lib/python/assemblitics/Assemblytics_within_alignment.py \
            --delta {params.work_directory}/OUTSIDER/INSIDER_VR/assemblytics_out.Assemblytics.unique_length_filtered_l20000.delta \
            --min 50 > {params.work_directory}/OUTSIDER/INSIDER_VR/assemblytics_out.variants_within_alignments.bed || \
                fail_msg "ERROR : Assemblytics_within_alignment.py ✘\\n" | tee -a {log}.err;


        test -s {params.work_directory}/OUTSIDER/INSIDER_VR/assemblytics_out.variants_between_alignments.bed && \
            cat {params.work_directory}/OUTSIDER/INSIDER_VR/assemblytics_out.variants_between_alignments.bed > {output.bed}

        test -s {params.work_directory}/OUTSIDER/INSIDER_VR/assemblytics_out.variants_within_alignments.bed && \
            cat {params.work_directory}/OUTSIDER/INSIDER_VR/assemblytics_out.variants_within_alignments.bed >> {output.bed}
        

        path_ref=`readlink -f {input.ref}`
        path_genome=`readlink -f {input.genome_real}`
        
        old_path=`pwd`
        
        cd {params.work_directory}/OUTSIDER/INSIDER_VR/
            python3 ${{path_to_pipline}}/lib/python/assemblitics/filter_gap_SVs.py ${{path_ref}} ${{path_genome}} || \
                fail_msg "ERROR : filter_gap_SVs.py ✘\\n" | tee -a {log}.err;
        cd ${{old_path}}

        name_ref=`basename {input.ref}`
        name_query=`basename {input.genome_real}`

        printf "%s\\n" "{params.cmess} [SNK]--[`date`]--[INFO] REFERENCE : $name_ref {params.cend}"
        printf "%s\\n\\n" "{params.cmess} [SNK]--[`date`]--[INFO] PSEUDO GENOME : $name_query {params.cend}"

        sed -i "s/file1/${{name_ref}}/g" {output.stats}
        sed -i "s/file2/${{name_query}}/g" {output.stats}

        """

#END FIND_SV_ON_REF



rule TE_TOWARD_GENOME :
    input:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/VALUES_TSD_GROUP_OUTSIDER.csv" if config["CHOICE"]["PIPELINE"]["OUTSIDER_VARIANT"] == True else config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/VALUES_TSD_INSIDER_GROUP.csv",
        input_link=[],
        fasta_TE     = config["DATA"]["TE_DB"],
        genome       = config["DATA"]["GENOME"],
        all_te       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        snif_seqs    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/VARIANT_CALLING/SEQUENCE_INDEL.fasta",
        
    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_TOWARD_GENOME/PSEUDO_GENOME_TE_DB_ID.fasta",
        #config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_TOWARD_GENOME/NEO_GENOME.fasta",
        output_link=[],

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        #FOR DETECTION ON ASM
        choice_insider_sv   = config["CHOICE"]["PIPELINE"]["INSIDER_VARIANT"],

        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/TE_TOWARD_GENOME",


    shell:
        """

        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] PUT TE OUTSIDER ON GENOME... {params.cend}"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        mkdir -p {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/
        rm -f {log}*
        rm -f {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/PSEUDO_GENOME_TE_DB_ID.fasta.fai

        echo "[`date`] LOG TASK {log}.out, {log}.err"

        echo "REFORMAT FASTA GENOME FOR TE INTEGRATION..."
        python3 ${{path_to_pipline}}/lib/python/format_files/fasta_to_fasta.py {input.genome} > {params.work_directory}/tmp_genome_format.fasta

        ##CHECK_FT_GENOME
        echo "CHECK FORMAT GENOME..." | tee -a {log}.out {log}.err
        awk 'BEGIN{{h_s="H"; is_fasta="True"}} 
            {{
                if( h_s == "H" && $0!="" ){{ 
                    if(substr($0, 1, 1) != ">"){{
                        is_fasta="NO_HEADER"; 
                        print $0; 
                        exit 0;
                    }}; 
                    h_s="S";
                }}
                else if(h_s == "S" && $0 != ""){{ 
                    if(! match($0, /^[ACGTURYKMSWBDHVNacgturykmswbdhvn]*$/)){{
                        is_fasta="NO_NT"; 
                        print $0; 
                        exit 0
                    }}; 
                        h_s = "H"; 
                }}  
            }} 

            END{{print is_fasta}}' {params.work_directory}/tmp_genome_format.fasta > {params.work_directory}/.tmp_check_ft_genome.txt;

        cat {params.work_directory}/.tmp_check_ft_genome.txt >> {log}.err

        [[ "`tail -n 1 {params.work_directory}/.tmp_check_ft_genome.txt`" != "True" ]] && fail_msg "ERROR : BAD FORMAT FASTA GENOME FOR INTEGRATION TE ✘\\n" && exit 6

        echo "CHECK FORMAT GENOME ✔" | tee -a {log}.out;

        #create index genome
        samtools faidx {params.work_directory}/tmp_genome_format.fasta

        ( test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed && \
            cut -f 4 {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed | cut -d "|" -f 2 > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/ID.txt && \
                echo "GET ID TE MERGE ✔" | tee -a {log}.out ) || fail_msg "ERROR : GET ID TE MERGE ✘\\n" | tee -a {log}.err

        rm -f {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_DB_TE.fasta && \
            touch {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_DB_TE.fasta

        #SEQ INDEL to Cannonical SEQ
        ( test -s {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/ID.txt && \
            for ID_TE in `cat "{params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/ID.txt"`; do
                IS_CLIPPED=`echo $ID_TE | grep -E -o "SOFT|HARD" || echo ""`

                if ! test -n "$IS_CLIPPED"; then
                    #seq_old=`( grep -w "$ID_TE" {input.snif_seqs} -A 1 || grep -w "$ID_TE" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.fasta ) | grep -v ">"`
                    
                    tmp_info_var=`( grep -w "$ID_TE" {input.all_te} || grep -w "$ID_TE" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv ) || echo ""`
                    
                    if test -n "$tmp_info_var";
                    then
                        TE=`( grep -w "$ID_TE" {input.all_te} || grep -w "$ID_TE" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv ) | cut -f 1`
                        strand=`( grep -w "$ID_TE" {input.all_te} || grep -w "$ID_TE" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv ) | grep ":[-+]" -o | tr -d ":"`
                        ID_CSV=`( grep -w "$ID_TE" {input.all_te} || grep -w "$ID_TE" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv ) | cut -f 2`

                        if [[ $strand = "+" ]]; then
                            seq_TE_cannonical=`grep -w "${{TE}}$" {input.fasta_TE} -A 1 | grep -v ">" | tr "atgcn" "ATGCN"`
                        else
                            seq_TE_cannonical=`grep -w "${{TE}}$" {input.fasta_TE} -A 1 | grep -v ">" | tr "ATGCatgcn" "TACGTACGN" | rev`
                        fi
                        
                        #echo "ID_TE:$ID_TE; TE:$TE; ID_CSV:$ID_CSV";
                        echo ">$ID_CSV" >> {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_DB_TE.fasta

                        #WARNING SEQ WITH NUMBER
                        echo "${{ID_TE}}$seq_TE_cannonical" >> {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_DB_TE.fasta
                    fi;
                fi;
            done && \
                echo "SEQ INDEL to Cannonical SEQ ✔" | tee -a {log}.out ) || fail_msg "ERROR : SEQ INDEL to Cannonical SEQ FAIL ✘\\n" | tee -a {log}.err;

        #************************
        ##INTEGRATION SEQUENCE DB
        ( test -s {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_DB_TE.fasta && \
            awk 'BEGIN{{start=0; header=0;}} OFS="\t"{{if(substr($0, 1, 1) == ">"){{split($0, sp, ":"); header=$0; start=sp[3];}}else{{print header, start, start+length($0)}} }}' \
                {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_DB_TE.fasta | sed 's/^>//g' > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL.bed && \
                    echo "INTEGRATION SEQUENCE DB ✔" | tee -a {log}.out ) || fail_msg "ERROR : INTEGRATION SEQUENCE DB ✘\\n" | tee -a {log}.err;
        

        ( test -s {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/ID.txt && \
            grep -w -f {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/ID.txt {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_DB_TE.fasta -A 1 | grep -v "^\-\-" \
                > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE.fasta ) || \
                    echo "ERROR : CONVERT FASTA SEQUENCE_INDEL_DB_TE.fasta to SEQUENCE_INDEL_as_TE.fasta ✘" >> {log}.err;

        #FOR DB SEQUENCE TO ANALYSIS REF
        ( test -s {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/ID.txt && \
            grep -f {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/ID.txt {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL.bed \
                > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE.bed ) || \
                    echo "ERROR : CONVERT BED SEQUENCE_INDEL.bed to SEQUENCE_INDEL_as_TE.bed ✘" >> {log}.err;

        #BED TO FORMAT bed for script vr_to_genome
        ( ( test -s {input.all_te} || test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv ) && \
            while read l; do 
                to_find=`echo $l | cut -d " " -f 1`; 
                chrom=`echo $l | cut -d ":" -f 1`;
                start=`echo $l | cut -d " " -f 2`; 
                end=`echo $l | cut -d " " -f 3`; 
                ID=`echo $l | cut -f 1 | cut -d":" -f 5`;

                TE=`( grep -w "$to_find" {input.all_te} || grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv ) | cut -f 1 || echo "NONE"` ;

                if [ "$TE" != "NONE" ]; then
                    echo "$chrom $start $end $TE:$ID"; 
                fi;

            done < {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE.bed | tr " " "\t" > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_TE.bed ) || \
                echo "ERROR : CONVERT BED SEQUENCE_INDEL.bed to SEQUENCE_INDEL_as_TE.bed ✘" >> {log}.err;
        

        echo "CHECK POSITION..."
        NB_POS_BAD=`awk '$3<=$2' {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_TE.bed | wc -l`
        if [ $NB_POS_BAD -eq 0 ]; then
            echo "   CHECK POSITION  ✔";
        else
            echo "   ERROR : BAD POSITION FOUND ERROR ✘";
        fi;


        echo "INTEGRATE TE DB_ID TO GENOME..."

        SIZE_TO_ADD=`awk '/^[^>]/ {{size+=length($0)}} END{{print size}}' {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE.fasta`;
        echo "   SIZE TO ADD : $SIZE_TO_ADD";

        ## INTEGRATE TE TO GENOME
        python3 ${{path_to_pipline}}/lib/python/vr_to_genome.py \
            -ob {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE_PSEUDO.bed \
            -og {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/PSEUDO_GENOME_TE_DB_ID.fasta \
            {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_TE.bed \
            {params.work_directory}/tmp_genome_format.fasta \
            {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE.fasta 2>> {log}.err


        SIZE_GENOME_BEFOR=`awk '{{s+=$2}} END{{print s}}' {params.work_directory}/tmp_genome_format.fasta.fai`;
        samtools faidx {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/PSEUDO_GENOME_TE_DB_ID.fasta;
        SIZE_GENOME_AFTER=`awk '{{s+=$2}} END{{print s}}' {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/PSEUDO_GENOME_TE_DB_ID.fasta.fai`;

        echo "   SIZE GENOME BEFORE INTEGRATION : $SIZE_GENOME_BEFOR";
        echo "   SIZE GENOME AFTER INTEGRATION  : $SIZE_GENOME_AFTER";
        echo "   SIZE ADDED : $((SIZE_GENOME_AFTER-SIZE_GENOME_BEFOR))";



        ( test -s {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE_PSEUDO.bed && \
            cat {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE_PSEUDO.bed | tr ":" "|" > {params.work_directory}/POSITION_TE_OUTSIDER_IN_PSEUDO_GENOME.bed ) || \
                fail_msg "ERROR : TRUE_POSITION_TE_PSEUDO FAIL ✘\\n" | tee -a {log}.err;

        
        #***********************************
        #FOR SEQUENCE IN READS PSEUDO GENOME

        #NO CHOICE
        test -s {params.work_directory}/OUTSIDER/VARIANT_CALLING/SEQUENCE_INDEL.fasta && \
            cat {params.work_directory}/OUTSIDER/VARIANT_CALLING/SEQUENCE_INDEL.fasta > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/tmp_SEQ_INDEL_MERGE.fasta
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.fasta && \
            cat {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.fasta >> {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/tmp_SEQ_INDEL_MERGE.fasta
        
        test -s {input.all_te} && \
            cat {input.all_te} | cut -f 1,2 | sed 's/:[+-]//g' > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/tmp_ssqid_TE.txt
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv && \
            cat {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv | cut -f 1,2 | sed 's/:[+-]//g' >> {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/tmp_ssqid_TE.txt

        ! test -s {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/tmp_ssqid_TE.txt && fail_msg "ERROR : NO ssqid found ✘\\n" | tee -a {log}.err && exit 4;

        rm -f {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE_READS.fasta
        for ID in `cat {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/ID.txt`; do

            IS_CLIPPED=`echo $ID | grep -E -o "SOFT|HARD" || echo ""`

            if ! test -n "$IS_CLIPPED"; then
                tmp_info_var=`grep -w "$ID" {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/tmp_ssqid_TE.txt || echo ""`;
                
                if test -n "$tmp_info_var";
                then
                    TE=`grep -w "$ID" {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/tmp_ssqid_TE.txt | cut -f 1`
                    head=`grep -w "$ID" {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/tmp_ssqid_TE.txt | cut -f 2`
                    TSD_SEQ_EXIST=`test -s {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{TE}}_OK_SEQ.fasta && grep -w "$ID" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{TE}}_OK_SEQ.fasta || echo ""`;
                    start=`grep -w "$ID" {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/tmp_ssqid_TE.txt | cut -f 2 | cut -d ":" -f 3`

                    if [ -n "$TSD_SEQ_EXIST" ]; then
                        
                        #TSD NEW POS
                        NEW_POS=`(grep "OK:$ID]" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{TE}}.txt -A 5 | grep "TSD_POSITION" | cut -d ":" -f 2) || echo ""`
                        if [ ! -n "$NEW_POS" ] && test -s {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{TE}}_KO_corrected.txt; then
                            NEW_POS=`grep "KO->OK:$ID]" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{TE}}_KO_corrected.txt -A 5 | grep "NEW_POS=" | cut -d "=" -f 2 | cut -d ":" -f 1 || echo "$start"`                
                        elif [ ! -n "$NEW_POS" ]; then
                            NEW_POS="$start";
                        fi;

                        head=`echo "$head" | awk -v NEW_POS="$NEW_POS" -F ":" 'OFS=":" {{ if( $3 != NEW_POS ){{$3=NEW_POS; $4=NEW_POS+1; $7="PRECISE-TSD"; print $0}}else{{print $0}} }}'`
                        seq=`grep -w "$ID" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{TE}}_OK_SEQ.fasta -A 1 | grep -v ">"` 
                    else
                        seq=`grep -w "$head" {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/tmp_SEQ_INDEL_MERGE.fasta -A 1 | grep -v ">"`
                    fi;

                    #if [ -n "$head" ] && [ -n "$seq" ]; then
                        echo ">$head" >> {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE_READS.fasta
                        echo "$seq" >> {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE_READS.fasta
                    #fi;
                fi;
            fi;
        done;

        awk 'BEGIN{{start=0; header=0;}} OFS="\t"{{if(substr($0, 1, 1) == ">"){{split($0, sp, ":"); header=$0; start=sp[3];}}else{{print header, start, start+length($0)}} }}' \
            {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE_READS.fasta | sed 's/^>//g' > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_READS.bed

        grep -f {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/ID.txt {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_READS.bed \
            > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE_READS.bed

        #FASTA TO FORMAT bed for script vr_to_genome
        while read l; do 
            chrom=`echo $l | cut -d ":" -f 1`;  
            start=`echo $l | cut -d " " -f 2`; 
            end=`echo $l | cut -d " " -f 3`; 
            ID=`echo $l | cut -f 1 | cut -d":" -f 5`;
            TE=`(grep -w "$ID" {input.all_te} || grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv) | cut -f 1 || echo "NONE"` ;
            if [ "$TE" != "NONE" ]; then
                echo "$chrom $start $end $TE:$ID"; 
            fi;

        done < {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE_READS.bed | tr " " "\t" > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_TE_READS.bed
        echo  "INTEGRATE TE IN READS TO GENOME..."

        SIZE_TO_ADD=`awk '/^[^>]/ {{size+=length($0)}} END{{print size}}' {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE_READS.fasta`;
        echo "   SIZE TO ADD : $SIZE_TO_ADD";

        ## INTEGRATE TE TO GENOME
        python3 ${{path_to_pipline}}/lib/python/vr_to_genome.py \
            -ob {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE_NEO.bed \
            -og {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/NEO_GENOME.fasta \
            {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_TE_READS.bed \
            {params.work_directory}/tmp_genome_format.fasta \
            {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE_READS.fasta

        cat {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE_NEO.bed | tr ":" "|" > {params.work_directory}/POSITION_TE_OUTSIDER_IN_NEO_GENOME.bed

        samtools faidx {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/NEO_GENOME.fasta;
        SIZE_GENOME_AFTER=`awk '{{s+=$2}} END{{print s}}' {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/NEO_GENOME.fasta.fai`;

        echo "   SIZE GENOME BEFORE INTEGRATION : $SIZE_GENOME_BEFOR";
        echo "   SIZE GENOME AFTER INTEGRATION  : $SIZE_GENOME_AFTER";
        echo "   SIZE ADDED : $((SIZE_GENOME_AFTER-SIZE_GENOME_BEFOR))";

        ## CHECKING TE INTEGRATED ##
        echo  "CHECKING TE INTEGRATED..."

        cat {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/PSEUDO_GENOME_TE_DB_ID.fasta > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/tmp_PSEUDO_GENOME_TE_DB_ID.fasta


        bedtools getfasta -fi {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/PSEUDO_GENOME_TE_DB_ID.fasta \
            -bed {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE_PSEUDO.bed \
            -name+ > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE.fasta

        TOTAL_TE=`grep -w -v -E "SOFT.[0-9]+|HARD.[0-9]+" {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed -c`

        ! test -s {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE.fasta || ! test -s  {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE.fasta && fail_msg "ERROR : MISSING FASTA PSEUDO FOUND ✘\\n" | tee -a {log}.err;
        
        NB_SEQ_FOUND=`grep -w -f {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE.fasta {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE.fasta -c || echo 0`
        
        echo "TOTAL TE: $TOTAL_TE ; TE INTEGRATE ON GENOME TE_DB_ID : $NB_SEQ_FOUND ;"

        ###READS
        bedtools getfasta -fi {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/NEO_GENOME.fasta \
            -bed {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE_NEO.bed \
            -name+ > {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE_READS.fasta

        ! test -s {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE_READS.fasta || ! test -s  {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE_READS.fasta && fail_msg "ERROR : MISSING FASTA NEO FOUND ✘\\n" | tee -a {log}.err;

        NB_SEQ_FOUND=`grep -w -f {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/TRUE_POSITION_TE_READS.fasta {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_as_TE_READS.fasta -c || echo 0`
        
        echo "TOTAL TE: $TOTAL_TE ; TE INTEGRATE ON NEO GENOME: $NB_SEQ_FOUND ;"
        
        rm -f {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/PSEUDO_GENOME_TE_DB_ID.fasta.fai #important to delet this
        rm -f {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/ID.txt;
        rm -f {params.work_directory}/OUTSIDER/TE_TOWARD_GENOME/SEQUENCE_INDEL_TE*
        rm -f `find {params.work_directory} -name "*.fai"`
        rm -f {params.work_directory}/tmp_geno*
        """

#END TE_TOWARD_GENOME



rule TSD :
    input:
        input_link=[],
        #directory(config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/" + "ET_FIND_FA"),
        fasta_TE  = config["DATA"]["TE_DB"],
        genome    = config["DATA"]["GENOME"],
        

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/VALUES_TSD_GROUP_OUTSIDER.csv" if config["CHOICE"]["PIPELINE"]["OUTSIDER_VARIANT"] == True else config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/VALUES_TSD_INSIDER_GROUP.csv",
        #directory(config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/" + "TSD"),
        output_link=[],

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        choice_outsider_sv  = config["CHOICE"]["PIPELINE"]["OUTSIDER_VARIANT"],

        #TSD
        FILE_SIZE_TE_TSD = config["PARAMS"]["OUTSIDER_VARIANT"]["TSD"]["FILE_SIZE_TE_TSD"],
        SIZE_FLANK       = config["PARAMS"]["OUTSIDER_VARIANT"]["TSD"]["SIZE_FLANK"],

        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/TSD",

    shell:
        #TODO broullion
        """

        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        
        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] <<< TSD >>> {params.cend}"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        rm -f {log}*
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        echo -e "x\ty\tcondition" > {params.work_directory}/VALUES_TSD_GROUP_OUTSIDER.csv

        mkdir -p {params.work_directory}/OUTSIDER/TE_DETECTION/TSD ;
        mkdir -p {params.work_directory}/TSD_TMP

        
        read_directory="{params.work_directory}/OUTSIDER/READ_FASTQ_TE"
        fasta_dir_find="{params.work_directory}/OUTSIDER/FASTA_FIND"

        echo "   SIZE FLANKING SEQUENCE : {params.SIZE_FLANK}"

        if [ {params.choice_outsider_sv} = "True" ]; then
            
            ! test -s "{params.FILE_SIZE_TE_TSD}" && warn_msg "  WARNING : FILE TSD SIZE {params.FILE_SIZE_TE_TSD} NOT FOUND\\n";
            ln -sfr {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/COUNT_READS.txt {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/
            NB_FILE=`ls {params.work_directory}/OUTSIDER/ET_FIND_FA | wc -l` ;
            i=0 ;
            for TE_found_fa in `ls {params.work_directory}/OUTSIDER/ET_FIND_FA/`; do
                
                nameTE=`echo $TE_found_fa | sed -E 's/TE_REPORT_FOUND_|\.fasta//g'`;
                SIZE_TSD=`test -n "{params.FILE_SIZE_TE_TSD}" && test -s "{params.FILE_SIZE_TE_TSD}" && grep -w "${{nameTE}}" {params.FILE_SIZE_TE_TSD} || echo "NONE"`; # EX: ZAM 4 :or: -1
                
                #echo "TE : $nameTE"
                
                if [[ $SIZE_TSD != "NONE" ]]; then
                    SIZE_TSD=`echo $SIZE_TSD | awk '{{print $2}}'`;
                    echo "SIZE-TSD : $SIZE_TSD"

                    #echo "TE=$nameTE ; SIZE TSD=$SIZE_TSD" 
                    
                    sh ${{path_to_pipline}}/lib/TSD/find_fq_to_fasta.sh {params.work_directory}/OUTSIDER/ET_FIND_FA/$TE_found_fa \
                       ${{read_directory}} \
                       ${{fasta_dir_find}} >> {log}.out 2>> {log}.err;


                    echo "sseqid", "qseqid", "pident", "size_per", "size_el", "mismatch", "gapopen", "qstart", "qend", "sstart", "send", "evalue", "bitscore" | tr -d " " | tr "," "\t" > {params.work_directory}/tmp_COMBINE_MERGE.csv
                    ( test -s {params.work_directory}/OUTSIDER/TE_DETECTION/COMBINE_TE.csv && \
                        awk 'NR>1 && OFS="\t"{{print $1, $2, $3, $4, $5, "mismatch", "gapopen", $6, $7, $8, $9, "evalue", "bitscore"}}' {params.work_directory}/OUTSIDER/TE_DETECTION/COMBINE_TE.csv >> {params.work_directory}/tmp_COMBINE_MERGE.csv ) || \
                            warn_msg "WARNING : FAIL GET INFO COMBINE sniffles ✘\\n" | tee -a {log}.err
                    ( test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/COMBINE_INS_TREMOLO.csv && \
                        awk 'NR>1 && OFS="\t"{{print $1, $2, $3, $4, $5, "mismatch", "gapopen", $6, $7, $8, $9, "evalue", "bitscore"}}' {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/COMBINE_INS_TREMOLO.csv  >> {params.work_directory}/tmp_COMBINE_MERGE.csv ) || \
                            warn_msg "WARNING : FAIL GET INFO COMBINE TrEMOLO ✘\\n" | tee -a {log}.err

                    sh ${{path_to_pipline}}/lib/TSD/tsd_te.sh {params.work_directory}/OUTSIDER/ET_FIND_FA/$TE_found_fa \
                        ${{read_directory}} \
                        ${{fasta_dir_find}} \
                        {input.fasta_TE} \
                        {params.SIZE_FLANK} \
                        $SIZE_TSD {params.work_directory}/tmp_COMBINE_MERGE.csv \
                        {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt \
                        {input.genome} >> {log}.out 2>> {log}.err || ( fail_msg "ERROR FOUND TSD PLEASE CHECK {log}.out, {log}.err\\n" )

                    test -s {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt && \
                        sh ${{path_to_pipline}}/lib/TSD/revise_TSD.sh {input.genome} \
                            {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt \
                            {params.SIZE_FLANK} \
                            $SIZE_TSD \
                            {params.work_directory}/TSD_TMP >> {log}.out 2>> {log}.err;
                    
                else
                    SIZE_TSD=-1;
                    #echo "SIZE-TSD = $SIZE_TSD"

                    #echo "TE=$nameTE ; SIZE TSD=?" 
                    
                    sh ${{path_to_pipline}}/lib/TSD/find_fq_to_fasta.sh {params.work_directory}/OUTSIDER/ET_FIND_FA/$TE_found_fa \
                       ${{read_directory}} \
                       ${{fasta_dir_find}} >> {log}.out 2>> {log}.err;

                    echo "sseqid", "qseqid", "pident", "size_per", "size_el", "mismatch", "gapopen", "qstart", "qend", "sstart", "send", "evalue", "bitscore" | tr -d " " | tr "," "\t" > {params.work_directory}/tmp_COMBINE_MERGE.csv
                    ( test -s {params.work_directory}/OUTSIDER/TE_DETECTION/COMBINE_TE.csv && \
                        awk 'NR>1 && OFS="\t"{{print $1, $2, $3, $4, $5, "mismatch", "gapopen", $6, $7, $8, $9, "evalue", "bitscore"}}' {params.work_directory}/OUTSIDER/TE_DETECTION/COMBINE_TE.csv >> {params.work_directory}/tmp_COMBINE_MERGE.csv ) || \
                            warn_msg "WARNING : FAIL GET INFO COMBINE sniffles ✘\\n" | tee -a {log}.err
                    ( test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/COMBINE_INS_TREMOLO.csv && \
                        awk 'NR>1 && OFS="\t"{{print $1, $2, $3, $4, $5, "mismatch", "gapopen", $6, $7, $8, $9, "evalue", "bitscore"}}' {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/COMBINE_INS_TREMOLO.csv  >> {params.work_directory}/tmp_COMBINE_MERGE.csv ) || \
                            warn_msg "WARNING : FAIL GET INFO COMBINE sniffles ✘\\n" | tee -a {log}.err

                    sh ${{path_to_pipline}}/lib/TSD/tsd_te.sh {params.work_directory}/OUTSIDER/ET_FIND_FA/$TE_found_fa \
                        ${{read_directory}} \
                        ${{fasta_dir_find}} \
                        {input.fasta_TE} \
                        {params.SIZE_FLANK} \
                        $SIZE_TSD {params.work_directory}/tmp_COMBINE_MERGE.csv \
                        {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt \
                        {input.genome} >> {log}.out 2>> {log}.err || ( rm -f {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt && fail_msg "ERROR FOUND TSD PLEASE CHECK {log}.out, {log}.err\\n" )

                    test -s {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt && \
                        if [ 0 -ne `grep "^(" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt | grep "OK" -c || printf ""` ]; then
                            SIZE_TSD_MOY=`grep "^(" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt | grep "OK" | tr -d ")" | cut -d "," -f 6 | awk 'BEGIN{{somme=0}}{{somme+=$0}}END{{print int(somme/NR)}}' || echo 4`
                            echo "SIZE-TSD-MEAN : $SIZE_TSD_MOY ;"

                            sh ${{path_to_pipline}}/lib/TSD/revise_TSD.sh {input.genome} \
                                {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt \
                                {params.SIZE_FLANK} \
                                $SIZE_TSD_MOY \
                                {params.work_directory}/TSD_TMP >> {log}.out 2>> {log}.err;
                        fi;
                fi;

                ERROR=`grep "ERROR-404" -o -c {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt || echo "TE:$nameTE;TSD:NOT ERROR-404" >&2`;
                if [[ -n "$ERROR" ]] && [[ $ERROR -ne 0 ]]; then
                    rm -f {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt
                    warn_msg "ERROR-403 : TSD not evaluated TE=$nameTE; \\n"
                fi;

                ## GET SEQUENCE TE with TSD
                test -s {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt && \
                    grep "OK:" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt -A 2 | awk -v TE="$nameTE" '{{
                        if( substr($0, 1, 1) == "(" ) {{
                            where = match($0, /TrEMOLO.INS.[0-9]+|sniffles.INS.[0-9]+|svim.INS.[0-9]+|SOFT.[0-9]+|HARD.[0-9]+/);
                            if ( where != 0 ) {{
                                print ">"TE"|"substr($0, RSTART, RLENGTH);
                            }}
                        }}
                        else if( substr($0, 1, 1) == ">" ) {{
                            split($0, TSD, ":");
                        }}
                        else if( match($0, /\+\+:/) ) {{
                            split($0, SEQ, "|");
                            print SEQ[2]""TSD[2]
                        }}
                    }}' > {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}_OK_SEQ.fasta || echo "WARNING : TSD OK ${{nameTE}} NOT FOUND" >> {log}.err

                test -s {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}_KO_corrected.txt && \
                    grep "OK:" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}_KO_corrected.txt -A 2 | awk -v TE="$nameTE" '{{
                        if ( substr($0, 1, 3) == "SVI" ) {{
                            where = match($0, /TrEMOLO.INS.[0-9]+|sniffles.INS.[0-9]+|svim.INS.[0-9]+|SOFT.[0-9]+|HARD.[0-9]+/);
                            if ( where != 0 ) {{
                                print ">"TE"|"substr($0, RSTART, RLENGTH);
                            }}
                        }}
                        else if( substr($0, 1, 3) == "TSM" ) {{
                            where = match($0, /TSM=[A-Z]+/);
                            if ( where != 0 ) {{
                                split(substr($0, RSTART, RLENGTH), TSD, "=");
                            }}
                        }}
                        else if( match($0, /\+\+:/) ) {{
                            split($0, SEQ, "|");
                            print SEQ[2]""TSD[2]
                        }}
                    }}' >> {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}_OK_SEQ.fasta || echo "WARNING : TSD OK ${{nameTE}} NOT FOUND IN KO CORRECTED" >> {log}.err


                if test -s {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt;
                then
                    TOTAL=`grep "^OK/total" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 2`
                    NB_TSD_OK=`grep "^OK/total" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 1`
                    NB_TSD_KO=`grep "^KO/total" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 1`
                    NB_TSD_K_gap_O=`grep "^K-O/total" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 1`

                    if test -e {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}_KO_corrected.txt ; then
                        NB_TSD_OK_corrected=`grep "OK/total" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}_KO_corrected.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 1`
                        NB_TSD_KO_corrected=`grep "KO/total" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}_KO_corrected.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 1`
                    else
                        NB_TSD_OK_corrected=0;
                        NB_TSD_KO_corrected=0;
                    fi;

                    OK_K_gap_O=$(($NB_TSD_OK + $NB_TSD_K_gap_O + $NB_TSD_OK_corrected));
                                
                    PERCENT=$(($OK_K_gap_O*100/$TOTAL))

                    ###KO=$(($NB_TSD_KO-$NB_TSD_OK_corrected))
                    KO=$(($TOTAL-$OK_K_gap_O));

                    echo "TE:$nameTE;   TOTAL-TE:$TOTAL;   TSD [OK]:$NB_TSD_OK ✔ ;   TSD [K-O]:$NB_TSD_K_gap_O;   TSD [KO]:$KO ✘ ;   TSD CORRECTED [KO->OK]:$NB_TSD_OK_corrected ;  "

                    ###echo -e "${{nameTE}}\t${{PERCENT}}\tTE" >> {params.work_directory}/VALUES_TSD.csv

                    echo -e "${{nameTE}}\t${{OK_K_gap_O}}\tTSD OK" >> {params.work_directory}/VALUES_TSD_GROUP_OUTSIDER.csv
                    echo -e "${{nameTE}}\t${{KO}}\tTSD KO" >> {params.work_directory}/VALUES_TSD_GROUP_OUTSIDER.csv
                fi;

                i=$(($i + 1)) ;
                printf "%s\\n" "{params.cmess} [SNK]--[`date`] [TSD:snk] : $i/$NB_FILE {params.cend}"
            done;
        fi;


        ## TE INSIDER 
        rm -f {params.work_directory}/INS_*
        if test -s {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv && [ `cat {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv | wc -l` -ge 2 ]; then
                
            rm -f {params.work_directory}/VALUES_TSD_INSIDER_GROUP.csv
            rm -f {params.work_directory}/VALUES_TSD_INSIDER.csv

            printf "\\n%s\\n\\n" "{params.cmess} [SNK] TSD TE ASSEMBLED {params.cend}"
            mkdir -p {params.work_directory}/INSIDER/TE_DETECTION/TSD/
            
            awk 'NR>1 {{ print $1 }}' {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv | sort -u > {params.work_directory}/TE_NAME.txt

            NB_TE=`cat {params.work_directory}/TE_NAME.txt | wc -l`

            e=0;

            # show_step="$e/$NB_TE : TSD TE ASSEMBLED "
            # number_of_char=`echo "$show_step" | wc -c`
            # number_of_char=$(($number_of_char-1));
            # printf "\b%.0s" `seq 1 $number_of_char`
            # printf "$show_step";

            for TE in `cat {params.work_directory}/TE_NAME.txt`; do
                
                ###echo "TE == $TE"
                grep "^$TE\s" {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv | \
                    awk 'OFS="\t"{{split($2, a, ":"); split(a[6], b, "-"); print a[5], b[1], b[2], $1"|"a[1]}}' > {params.work_directory}/INS_$TE.bed;
                
                #rm -f {params.work_directory}/total_results_tsd.txt;

                NB_TE_FM=`cat {params.work_directory}/INS_$TE.bed | wc -l`

                a=0;

                show_step="$a/$NB_TE_FM : TSD TE:${{TE}} ASSEMBLED "
                number_of_char=`echo "$show_step" | wc -c`
                number_of_char=$(($number_of_char-1));
                printf "\b%.0s" `seq 1 $number_of_char`
                printf "$show_step";

                rm -f {params.work_directory}/INSIDER/TE_DETECTION/TSD/TSD_${{TE}}.txt
                for i in `cat {params.work_directory}/INS_$TE.bed | tr "\t" ":"`; 
                do 
                    #echo "i == $i";
                    echo $i | tr ":" "\t" > {params.work_directory}/TE.bed;
                    bedtools getfasta -fi {input.genome} -bed {params.work_directory}/TE.bed > {params.work_directory}/TE.fasta

                    ID=`cat {params.work_directory}/TE.bed | cut -f 4 | cut -d "|" -f 2`
                    #echo "ID = $ID"
                    
                    strand=`grep -w "$ID" {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv | awk 'OFS="\t"{{split($2, a, ":"); print a[7]}}'`
                    #echo "ID = $ID; strand = $strand;"
                    
                    cat {params.work_directory}/TE.bed | awk -v size_flank="{params.SIZE_FLANK}" 'OFS="\t"{{ if($2-size > 0){{ print $1, $2-size_flank, $2; print $1, $3, $3+size_flank; }}else{{ print $1, $2, $2+1; print $1, $3, $3+size_flank; }} }}' > {params.work_directory}/FLANK.bed;
                    bedtools getfasta -fi {input.genome} -bed {params.work_directory}/FLANK.bed > {params.work_directory}/FLANK.fasta

                    #echo "ARG : {params.work_directory}/FLANK.fasta {params.work_directory}/TE.fasta {params.SIZE_FLANK} $ID $strand -1"
                    if [ "$strand" = "-" ] || [ "$strand" = "+" ]; then
                        python3 ${{path_to_pipline}}/lib/TSD/find_tsd.py {params.work_directory}/FLANK.fasta {params.work_directory}/TE.fasta {params.SIZE_FLANK} "$ID" "$strand" "-1" >> {params.work_directory}/INSIDER/TE_DETECTION/TSD/TSD_${{TE}}.txt
                    fi;

                    a=$(($a+1));

                    show_step="$a/$NB_TE_FM : CHECKING TSD TE ASSEMBLED "
                    number_of_char=`echo "$show_step" | wc -c`
                    number_of_char=$(($number_of_char-1));
                    printf "\b%.0s" `seq 1 $number_of_char`
                    printf "$show_step";
                done;
                
                bash ${{path_to_pipline}}/lib/TSD/TSD_VG.sh {params.work_directory}/INSIDER/TE_DETECTION/TSD/TSD_${{TE}}.txt
                
                rm -f {params.work_directory}/TE.bed {params.work_directory}/INS_$TE.bed ;
                rm -f {params.work_directory}/TE.fasta {params.work_directory}/FLANK.fasta ;

                e=$(($e+1));
                echo "$e/$NB_TE :: TE ASSEMBLED ";

                # show_step="$e/$NB_TE : TSD TE ASSEMBLED "
                # number_of_char=`echo "$show_step" | wc -c`
                # number_of_char=$(($number_of_char-1));
                # printf "\b%.0s" `seq 1 $number_of_char`
                # printf "$show_step";

                TOTAL=`grep "^OK/total" {params.work_directory}/INSIDER/TE_DETECTION/TSD/TSD_${{TE}}.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 2`
                NB_TSD_OK=`grep "^OK/total" {params.work_directory}/INSIDER/TE_DETECTION/TSD/TSD_${{TE}}.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 1`
                NB_TSD_KO=`grep "^KO/total" {params.work_directory}/INSIDER/TE_DETECTION/TSD/TSD_${{TE}}.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 1`
                NB_TSD_K_gap_O=`grep "^K-O/total" {params.work_directory}/INSIDER/TE_DETECTION/TSD/TSD_${{TE}}.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 1`

                OK_K_gap_O=$(($NB_TSD_OK + $NB_TSD_K_gap_O));
                            
                PERCENT=$(($OK_K_gap_O*100/$TOTAL))

                KO=$(($TOTAL-$OK_K_gap_O));

                ## echo "TE:$TE ;  TOTAL-TE:$TOTAL ;   TSD [OK]:$NB_TSD_OK ;   TSD [K-O]:$NB_TSD_K_gap_O ;   TSD [KO]:$KO ;"

                ## echo -e "${{TE}}\t${{PERCENT}}\tTE" >> {params.work_directory}/VALUES_TSD_INSIDER.csv

                echo -e "${{TE}}\t${{OK_K_gap_O}}\tTSD OK" >> {params.work_directory}/VALUES_TSD_INSIDER_GROUP.csv
                echo -e "${{TE}}\t${{KO}}\tTSD KO" >> {params.work_directory}/VALUES_TSD_INSIDER_GROUP.csv
                
                printf "%s\\n" "{params.cmess} [SNK]--[`date`] [TSD:snk] : $e/$NB_TE {params.cend}"

            done;
            rm -f {params.work_directory}/FLANK.bed {params.work_directory}/TE.bed {params.work_directory}/TE_NAME.txt
            echo


            #** TDS ALL **#
            echo -e "x\ty\tcondition" > {params.work_directory}/VALUES_TSD_ALL_GROUP.csv
            for TE in `cat {params.work_directory}/VALUES_TSD_GROUP_OUTSIDER.csv {params.work_directory}/VALUES_TSD_INSIDER_GROUP.csv | awk 'NR>1' | cut -f 1 | sort -u`; do
                ###echo "TE : $TE"
                NBOK1=`grep -w "^$TE" {params.work_directory}/VALUES_TSD_GROUP_OUTSIDER.csv | grep OK | cut -f 2 || echo "0"`;
                NBOK2=`grep -w "^$TE" {params.work_directory}/VALUES_TSD_INSIDER_GROUP.csv  | grep OK | cut -f 2 || echo "0"`;

                if [ ! -n "$NBOK1" ]; then
                    NBOK1=0;
                fi;

                if [ ! -n "$NBOK2" ]; then
                    NBOK2=0;
                fi;

                NBKO1=`grep -w "^$TE" {params.work_directory}/VALUES_TSD_GROUP_OUTSIDER.csv | grep KO | cut -f 2 || echo "0"`;
                NBKO2=`grep -w "^$TE" {params.work_directory}/VALUES_TSD_INSIDER_GROUP.csv | grep KO | cut -f 2 || echo "0"`;

                if [ ! -n "$NBKO1" ]; then
                    NBKO1=0;
                fi;

                if [ ! -n "$NBKO2" ]; then
                    NBKO2=0;
                fi;

                echo -e "$TE\t$(($NBOK1+$NBOK2))\tTSD OK" >> {params.work_directory}/VALUES_TSD_ALL_GROUP.csv;
                echo -e "$TE\t$(($NBKO1+$NBKO2))\tTSD KO" >> {params.work_directory}/VALUES_TSD_ALL_GROUP.csv;
            done;

            awk 'BEGIN{{print "x\ty\tcondition"}}{{print $0}}' {params.work_directory}/VALUES_TSD_INSIDER_GROUP.csv > {params.work_directory}/tmp.csv
            mv {params.work_directory}/tmp.csv {params.work_directory}/VALUES_TSD_INSIDER_GROUP.csv
        fi;


        #rm -fr DIR_SEQ_TE_READ_POS
        #rm -fr {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/DIR_SEQ_TE_READ_POS
        #rm -f {params.work_directory}/OUTSIDER/FASTA_FIND/*.fasta.*
        rm -fr {params.work_directory}/OUTSIDER/FASTA_FIND
        #test -d DIR_SEQ_TE_READ_POS && \
        #test -d {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/ && \
        rm -f `find {params.work_directory} -name "*.fai"`
        rm -fr {params.work_directory}/TSD_TMP

        """



#END TSD


rule TSD_MULTI_THREADS :
    input:
        input_link=[],
        #directory(config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/" + "ET_FIND_FA"),
        fasta_TE  = config["DATA"]["TE_DB"],
        genome    = config["DATA"]["GENOME"],
        

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/VALUES_TSD_GROUP_OUTSIDER.csv" if config["CHOICE"]["PIPELINE"]["OUTSIDER_VARIANT"] == True else config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/VALUES_TSD_INSIDER_GROUP.csv",
        #directory(config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/" + "TSD"),
        output_link=[],

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        threads        = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,

        choice_outsider_sv  = config["CHOICE"]["PIPELINE"]["OUTSIDER_VARIANT"],

        #TSD
        FILE_SIZE_TE_TSD = config["PARAMS"]["OUTSIDER_VARIANT"]["TSD"]["FILE_SIZE_TE_TSD"],
        SIZE_FLANK       = config["PARAMS"]["OUTSIDER_VARIANT"]["TSD"]["SIZE_FLANK"],

        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/TSD",

    shell:
        #TODO broullion
        """

        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        
        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] <<< TSD >>> {params.cend}"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        rm -f {log}.*
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        rm -f `find {params.work_directory} -name "*.fai"`
        ###echo -e "x\ty\tfill" > {params.work_directory}/VALUES_TSD.csv;
        echo -e "x\ty\tcondition" > {params.work_directory}/VALUES_TSD_GROUP_OUTSIDER.csv


        mkdir -p {params.work_directory}/OUTSIDER/TE_DETECTION/TSD ;
        mkdir -p {params.work_directory}/TSD_TMP

        echo "THREADS: {params.threads}"
        read_directory="{params.work_directory}/OUTSIDER/READ_FASTQ_TE"
        fasta_dir_find="{params.work_directory}/OUTSIDER/FASTA_FIND"

        echo "   SIZE FLANKING SEQUENCE : {params.SIZE_FLANK}"

        #fun parallel
        find_TSD_OUTSIDER () {{
            TE_found_fa=$1;
            i=$2;

            ##echo "TE_found_fa:$TE_found_fa; i=$i"
            nameTE=`echo $TE_found_fa | sed -E 's/TE_REPORT_FOUND_|\.fasta//g'` ;
                
            ! test -s {params.FILE_SIZE_TE_TSD} && fail_msg "  Warning FILE {params.FILE_SIZE_TE_TSD} NOT FOUND\n"
            
            SIZE_TSD=`test -n "{params.FILE_SIZE_TE_TSD}" && test -s {params.FILE_SIZE_TE_TSD} && grep -w "${{nameTE}}" {params.FILE_SIZE_TE_TSD} || echo "NONE"`; # EX: ZAM 4 :or: -1
            
            ##echo "TE : $nameTE"
            
            if [[ $SIZE_TSD != "NONE" ]]; then
                SIZE_TSD=`echo $SIZE_TSD | awk '{{print $2}}'`;
                echo "SIZE-TSD : $SIZE_TSD"

                #echo "TE=$nameTE ; SIZE TSD=$SIZE_TSD" 
                
                sh ${{path_to_pipline}}/lib/TSD/find_fq_to_fasta.sh {params.work_directory}/OUTSIDER/ET_FIND_FA/$TE_found_fa \
                   ${{read_directory}} \
                   ${{fasta_dir_find}} >> {log}.out 2>> {log}.err;


                echo "sseqid", "qseqid", "pident", "size_per", "size_el", "mismatch", "gapopen", "qstart", "qend", "sstart", "send", "evalue", "bitscore" | tr -d " " | tr "," "\t" > {params.work_directory}/tmp_COMBINE_MERGE_${{i}}.csv
                ( test -s {params.work_directory}/OUTSIDER/TE_DETECTION/COMBINE_TE.csv && \
                        awk 'NR>1 && OFS="\t"{{print $1, $2, $3, $4, $5, "mismatch", "gapopen", $6, $7, $8, $9, "evalue", "bitscore"}}' {params.work_directory}/OUTSIDER/TE_DETECTION/COMBINE_TE.csv >> {params.work_directory}/tmp_COMBINE_MERGE.csv ) || \
                            warn_msg "WARNING : FAIL GET INFO COMBINE sniffles ✘\\n" | tee -a {log}.err
                ( test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/COMBINE_INS_TREMOLO.csv && \
                    awk 'NR>1 && OFS="\t"{{print $1, $2, $3, $4, $5, "mismatch", "gapopen", $6, $7, $8, $9, "evalue", "bitscore"}}' {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/COMBINE_INS_TREMOLO.csv  >> {params.work_directory}/tmp_COMBINE_MERGE.csv ) || \
                        warn_msg "WARNING : FAIL GET INFO COMBINE sniffles ✘\\n" | tee -a {log}.err

                sh ${{path_to_pipline}}/lib/TSD/tsd_te.sh {params.work_directory}/OUTSIDER/ET_FIND_FA/$TE_found_fa \
                    ${{read_directory}} \
                    ${{fasta_dir_find}} \
                    {input.fasta_TE} \
                    {params.SIZE_FLANK} \
                    $SIZE_TSD {params.work_directory}/tmp_COMBINE_MERGE_${{i}}.csv \
                    {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt \
                    {input.genome} >> {log}.out 2>> {log}.err || (fail_msg "ERROR FOUND TSD PLEASE CHECK {log}.out, {log}.err")

                test -s {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt && \
                    sh ${{path_to_pipline}}/lib/TSD/revise_TSD.sh {input.genome} \
                        {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt \
                        {params.SIZE_FLANK} \
                        $SIZE_TSD \
                        {params.work_directory}/TSD_TMP >> {log}.out 2>> {log}.err;
                    
            else
                SIZE_TSD=-1;
                #echo "SIZE-TSD = $SIZE_TSD"

                #echo "TE=$nameTE ; SIZE TSD=?" 
                
                sh ${{path_to_pipline}}/lib/TSD/find_fq_to_fasta.sh {params.work_directory}/OUTSIDER/ET_FIND_FA/$TE_found_fa \
                   ${{read_directory}} \
                   ${{fasta_dir_find}} >> {log}.out 2>> {log}.err;

                echo "sseqid", "qseqid", "pident", "size_per", "size_el", "mismatch", "gapopen", "qstart", "qend", "sstart", "send", "evalue", "bitscore" | tr -d " " | tr "," "\t" > {params.work_directory}/tmp_COMBINE_MERGE_${{i}}.csv
                ( test -s {params.work_directory}/OUTSIDER/TE_DETECTION/COMBINE_TE.csv && \
                        awk 'NR>1 && OFS="\t"{{print $1, $2, $3, $4, $5, "mismatch", "gapopen", $6, $7, $8, $9, "evalue", "bitscore"}}' {params.work_directory}/OUTSIDER/TE_DETECTION/COMBINE_TE.csv >> {params.work_directory}/tmp_COMBINE_MERGE.csv ) || \
                            warn_msg "WARNING : FAIL GET INFO COMBINE sniffles ✘\\n" | tee -a {log}.err
                ( test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/COMBINE_INS_TREMOLO.csv && \
                    awk 'NR>1 && OFS="\t"{{print $1, $2, $3, $4, $5, "mismatch", "gapopen", $6, $7, $8, $9, "evalue", "bitscore"}}' {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/COMBINE_INS_TREMOLO.csv  >> {params.work_directory}/tmp_COMBINE_MERGE.csv ) || \
                        warn_msg "WARNING : FAIL GET INFO COMBINE sniffles ✘\\n" | tee -a {log}.err

                sh ${{path_to_pipline}}/lib/TSD/tsd_te.sh {params.work_directory}/OUTSIDER/ET_FIND_FA/$TE_found_fa \
                    ${{read_directory}} \
                    ${{fasta_dir_find}} \
                    {input.fasta_TE} \
                    {params.SIZE_FLANK} \
                    $SIZE_TSD {params.work_directory}/tmp_COMBINE_MERGE_${{i}}.csv \
                    {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt \
                    {input.genome} >> {log}.out 2>> {log}.err || ( rm -f {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt && fail_msg "ERROR FOUND TSD PLEASE CHECK {log}.out, {log}.err\\n" )

                test -s {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt && \
                    if [ 0 -ne `grep "^(" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt | grep "OK" -c || printf ""` ]; then
                        SIZE_TSD_MOY=`grep "^(" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt | grep "OK" | tr -d ")" | cut -d "," -f 6 | awk 'BEGIN{{somme=0}}{{somme+=$0}}END{{print int(somme/NR)}}' || echo 4`
                        echo "SIZE-TSD-MEAN : $SIZE_TSD_MOY ;"

                        sh ${{path_to_pipline}}/lib/TSD/revise_TSD.sh {input.genome} \
                            {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt \
                            {params.SIZE_FLANK} \
                            $SIZE_TSD_MOY \
                            {params.work_directory}/TSD_TMP >> {log}.out 2>> {log}.err;
                    fi;
                    
            fi;

            ERROR=`grep "ERROR-404" -o -c {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt || echo "TE:$nameTE;TSD:NOT ERROR-404" >&2`;
            if [[ -n "$ERROR" ]] && [[ $ERROR -ne 0 ]]; then
                rm -f {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt
                warn_msg "ERROR-403 : TSD not evaluated TE=$nameTE; \\n"
            fi;

            ## GET SEQUENCE TE with TSD
            test -s {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt && \
                grep "OK:" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt -A 2 | awk -v TE="$nameTE" '{{
                    if( substr($0, 1, 1) == "(" ) {{
                        where = match($0, /TrEMOLO.INS.[0-9]+|sniffles.INS.[0-9]+|svim.INS.[0-9]+|SOFT.[0-9]+|HARD.[0-9]+/);
                        if ( where != 0 ) {{
                            print ">"TE"|"substr($0, RSTART, RLENGTH);
                        }}
                    }}
                    else if( substr($0, 1, 1) == ">" ) {{
                        split($0, TSD, ":");
                    }}
                    else if( match($0, /\+\+:/) ) {{
                        split($0, SEQ, "|");
                        print SEQ[2]""TSD[2]
                    }}
                }}' > {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}_OK_SEQ.fasta || echo "WARNING : TSD OK ${{nameTE}} NOT FOUND" >> {log}.err

            test -s {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}_KO_corrected.txt && \
                grep "OK:" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}_KO_corrected.txt -A 2 | awk -v TE="$nameTE" '{{
                    if ( substr($0, 1, 3) == "SVI" ) {{
                        where = match($0, /TrEMOLO.INS.[0-9]+|sniffles.INS.[0-9]+|svim.INS.[0-9]+|SOFT.[0-9]+|HARD.[0-9]+/);
                        if ( where != 0 ) {{
                            print ">"TE"|"substr($0, RSTART, RLENGTH);
                        }}
                    }}
                    else if( substr($0, 1, 3) == "TSM" ) {{
                        where = match($0, /TSM=[A-Z]+/);
                        if ( where != 0 ) {{
                            split(substr($0, RSTART, RLENGTH), TSD, "=");
                        }}
                    }}
                    else if( match($0, /\+\+:/) ) {{
                        split($0, SEQ, "|");
                        print SEQ[2]""TSD[2]
                    }}
                }}' >> {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}_OK_SEQ.fasta || echo "WARNING : TSD OK ${{nameTE}} NOT FOUND IN KO CORRECTED" >> {log}.err

            if test -s {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt;
            then
                TOTAL=`grep "^OK/total" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 2`
                NB_TSD_OK=`grep "^OK/total" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 1`
                NB_TSD_KO=`grep "^KO/total" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 1`
                NB_TSD_K_gap_O=`grep "^K-O/total" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 1`

                if test -e {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}_KO_corrected.txt ; then
                    NB_TSD_OK_corrected=`grep "OK/total" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}_KO_corrected.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 1`
                    NB_TSD_KO_corrected=`grep "KO/total" {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/TSD_${{nameTE}}_KO_corrected.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 1`
                else
                    NB_TSD_OK_corrected=0;
                    NB_TSD_KO_corrected=0;
                fi;

                OK_K_gap_O=$(($NB_TSD_OK + $NB_TSD_K_gap_O + $NB_TSD_OK_corrected));
                            
                PERCENT=$(($OK_K_gap_O*100/$TOTAL))

                ###KO=$(($NB_TSD_KO-$NB_TSD_OK_corrected))
                KO=$(($TOTAL-$OK_K_gap_O));

                echo "TE:$nameTE;   TOTAL-TE:$TOTAL;   TSD [OK]:$NB_TSD_OK ✔ ;   TSD [K-O]:$NB_TSD_K_gap_O;   TSD [KO]:$KO ✘ ;   TSD CORRECTED [KO->OK]:$NB_TSD_OK_corrected ;  "

                ###echo -e "${{nameTE}}\t${{PERCENT}}\tTE" >> {params.work_directory}/VALUES_TSD.csv

                echo -e "${{nameTE}}\t${{OK_K_gap_O}}\tTSD OK" >> {params.work_directory}/VALUES_TSD_GROUP_OUTSIDER.csv
                echo -e "${{nameTE}}\t${{KO}}\tTSD KO" >> {params.work_directory}/VALUES_TSD_GROUP_OUTSIDER.csv
            fi;
        }}


        makeblastdb -in {input.fasta_TE} -dbtype nucl

        ###RUN PARLELIZE
        count_task_running=0;
        if [ {params.choice_outsider_sv} = "True" ] && test -d {params.work_directory}/OUTSIDER/ET_FIND_FA; then
            
            NB_FILE=`ls {params.work_directory}/OUTSIDER/ET_FIND_FA | wc -l` ;
            i=0 ;

            #PARLELIZE
            
            pids=();
            for TE_found_fa in `ls {params.work_directory}/OUTSIDER/ET_FIND_FA/`; do
                
                ###echo "[TSD:snk] $i/$NB_FILE" ;

                find_TSD_OUTSIDER $TE_found_fa $i &
                pids[${{count_task_running}}]=$!;
                count_task_running=$(($count_task_running+1));

                if [ $count_task_running -ge {params.threads} ]; then
                    c=1;
                    for pid in ${{pids[*]}}; do
                        wait $pid || echo > /dev/null;
                        #echo "PID : $pid; TASK : $i; N : $c; done !"
                        c=$(($c+1));
                    done;
                    pids=();
                    count_task_running=0;
                fi;

                i=$(($i + 1)) ;
                printf "%s\\n" "{params.cmess} [SNK]--[`date`] [TSD:snk] : $i/$NB_FILE {params.cend}"
            done;

            #WAIT LAST TASKS
            if [ $count_task_running -lt {params.threads} ]; then
                pids[${{count_task_running}}]=$!
                task=1;
                for pid in ${{pids[*]}}; do
                    wait $pid || echo > /dev/null;
                    #echo "PID : $pid; TASK : $i; N : $c; done !"
                    task=$(($task+1));
                done;
            fi;
        fi;


        echo "4"
        #fun parallel
        find_TSD_INSIDER () {{
            i=$1;
            
            echo $i | tr ":" "\t" > {params.work_directory}/TE_${{i}}.bed;
            bedtools getfasta -fi {input.genome} -bed {params.work_directory}/TE_${{i}}.bed > {params.work_directory}/TE_${{i}}.fasta

            ID=`cat {params.work_directory}/TE_${{i}}.bed | cut -f 4 | cut -d "|" -f 2`
            #echo "ID = $ID"
            
            strand=`grep -w "$ID" {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv | awk 'OFS="\t"{{split($2, a, ":"); print a[7]}}'`
            #echo "ID = $ID; strand = $strand;"
            
            cat {params.work_directory}/TE_${{i}}.bed | awk -v size_flank="{params.SIZE_FLANK}" 'OFS="\t"{{ if($2-size > 0){{ print $1, $2-size_flank, $2; print $1, $3, $3+size_flank; }}else{{ print $1, $2, $2+1; print $1, $3, $3+size_flank; }} }}' > {params.work_directory}/FLANK_${{i}}.bed;
            bedtools getfasta -fi {input.genome} -bed {params.work_directory}/FLANK_${{i}}.bed > {params.work_directory}/FLANK_${{i}}.fasta

            #echo "ARG : {params.work_directory}/FLANK_${{i}}.fasta {params.work_directory}/TE_${{i}}.fasta {params.SIZE_FLANK} $ID $strand -1"
            if [ "$strand" = "-" ] || [ "$strand" = "+" ]; then
                python3 ${{path_to_pipline}}/lib/TSD/find_tsd.py {params.work_directory}/FLANK_${{i}}.fasta {params.work_directory}/TE_${{i}}.fasta {params.SIZE_FLANK} "$ID" "$strand" "-1" >> {params.work_directory}/INSIDER/TE_DETECTION/TSD/TSD_${{TE}}.txt
            fi;
            rm -f {params.work_directory}/TE_${{i}}.bed \
                {params.work_directory}/TE_${{i}}.fasta \
                {params.work_directory}/FLANK_${{i}}.bed \
                {params.work_directory}/FLANK_${{i}}.fasta

        }}

        echo
        echo "   TSD INSIDER"
        ## TE INSIDER 
        rm -f {params.work_directory}/INS_*
        if test -s {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv && [ `cat {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv | wc -l` -ge 2 ]; then
                
            rm -f {params.work_directory}/VALUES_TSD_INSIDER_GROUP.csv
            rm -f {params.work_directory}/VALUES_TSD_INSIDER.csv

            printf "\\n%s\\n\\n" "{params.cmess} [SNK] TSD TE ASSEMBLED {params.cend}"
            mkdir -p {params.work_directory}/INSIDER/TE_DETECTION/TSD/
            
            awk 'NR>1 {{ print $1 }}' {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv | sort -u > {params.work_directory}/TE_NAME.txt

            NB_TE=`cat {params.work_directory}/TE_NAME.txt | wc -l`

            e=0;

            # show_step="$e/$NB_TE : TSD TE ASSEMBLED "
            # number_of_char=`echo "$show_step" | wc -c`
            # number_of_char=$(($number_of_char-1));
            # printf "\b%.0s" `seq 1 $number_of_char`
            # printf "$show_step";

            for TE in `cat {params.work_directory}/TE_NAME.txt`; do
                
                ###echo "TE == $TE"
                grep "^$TE\s" {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv | \
                    awk 'OFS="\t"{{split($2, a, ":"); split(a[6], b, "-"); print a[5], b[1], b[2], $1"|"a[1]}}' > {params.work_directory}/INS_$TE.bed;
                
                #rm -f {params.work_directory}/total_results_tsd.txt;

                NB_TE_FM=`cat {params.work_directory}/INS_$TE.bed | wc -l`

                a=0;

                show_step="$a/$NB_TE_FM : TSD TE:${{TE}} ASSEMBLED "
                number_of_char=`echo "$show_step" | wc -c`
                number_of_char=$(($number_of_char-1));
                printf "\b%.0s" `seq 1 $number_of_char`
                printf "$show_step";

                count_task_running=0;
                pids=();

                rm -f {params.work_directory}/INSIDER/TE_DETECTION/TSD/TSD_${{TE}}.txt
                for i in `cat {params.work_directory}/INS_$TE.bed | tr "\t" ":"`; 
                do 
                    #echo "i == $i";
                    
                    find_TSD_INSIDER $i &
                    pids[${{count_task_running}}]=$!;
                    count_task_running=$(($count_task_running+1));

                    if [ $count_task_running -ge {params.threads} ]; then
                        c=1;
                        for pid in ${{pids[*]}}; do
                            wait $pid || echo > /dev/null;
                            #echo "PID : $pid; TASK : $i; N : $c; done !"
                            c=$(($c+1));
                        done;
                        pids=();
                        count_task_running=0;
                    fi;

                    a=$(($a+1));

                    show_step="$a/$NB_TE_FM : CHECKING TSD TE ASSEMBLED "
                    number_of_char=`echo "$show_step" | wc -c`
                    number_of_char=$(($number_of_char-1));
                    printf "\b%.0s" `seq 1 $number_of_char`
                    printf "$show_step";
                done;

                #WAIT LAST TASKS
                if [ $count_task_running -lt {params.threads} ]; then
                    pids[${{count_task_running}}]=$!
                    task=1;
                    for pid in ${{pids[*]}}; do
                        wait $pid || echo > /dev/null;
                        #echo "PID : $pid; TASK : $i; N : $c; done !"
                        task=$(($task+1));
                    done;
                fi;

                #bash ${{path_to_pipline}}/lib/TSD/TSD_VG.sh {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv {input.genome}
                
                bash ${{path_to_pipline}}/lib/TSD/TSD_VG.sh {params.work_directory}/INSIDER/TE_DETECTION/TSD/TSD_${{TE}}.txt
                
                rm -f {params.work_directory}/TE.bed {params.work_directory}/INS_$TE.bed ;
                rm -f {params.work_directory}/TE.fasta {params.work_directory}/FLANK.fasta ;

                e=$(($e+1));
                echo "$e/$NB_TE :: TE ASSEMBLED ";

                # show_step="$e/$NB_TE : TSD TE ASSEMBLED "
                # number_of_char=`echo "$show_step" | wc -c`
                # number_of_char=$(($number_of_char-1));
                # printf "\b%.0s" `seq 1 $number_of_char`
                # printf "$show_step";

                TOTAL=`grep "^OK/total" {params.work_directory}/INSIDER/TE_DETECTION/TSD/TSD_${{TE}}.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 2`
                NB_TSD_OK=`grep "^OK/total" {params.work_directory}/INSIDER/TE_DETECTION/TSD/TSD_${{TE}}.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 1`
                NB_TSD_KO=`grep "^KO/total" {params.work_directory}/INSIDER/TE_DETECTION/TSD/TSD_${{TE}}.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 1`
                NB_TSD_K_gap_O=`grep "^K-O/total" {params.work_directory}/INSIDER/TE_DETECTION/TSD/TSD_${{TE}}.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 1`

                OK_K_gap_O=$(($NB_TSD_OK + $NB_TSD_K_gap_O));
                            
                PERCENT=$(($OK_K_gap_O*100/$TOTAL))

                KO=$(($TOTAL-$OK_K_gap_O));

                ## echo "TE:$TE ;  TOTAL-TE:$TOTAL ;   TSD [OK]:$NB_TSD_OK ;   TSD [K-O]:$NB_TSD_K_gap_O ;   TSD [KO]:$KO ;"

                ## echo -e "${{TE}}\t${{PERCENT}}\tTE" >> {params.work_directory}/VALUES_TSD_INSIDER.csv

                echo -e "${{TE}}\t${{OK_K_gap_O}}\tTSD OK" >> {params.work_directory}/VALUES_TSD_INSIDER_GROUP.csv
                echo -e "${{TE}}\t${{KO}}\tTSD KO" >> {params.work_directory}/VALUES_TSD_INSIDER_GROUP.csv
                
                printf "%s\\n" "{params.cmess} [SNK]--[`date`] [TSD:snk] : $e/$NB_TE {params.cend}"

            done;
            rm -f {params.work_directory}/FLANK.bed {params.work_directory}/TE.bed {params.work_directory}/TE_NAME.txt
            echo


            #** TDS ALL **#
            echo -e "x\ty\tcondition" > {params.work_directory}/VALUES_TSD_ALL_GROUP.csv
            for TE in `cat {params.work_directory}/VALUES_TSD_GROUP_OUTSIDER.csv {params.work_directory}/VALUES_TSD_INSIDER_GROUP.csv | awk 'NR>1' | cut -f 1 | sort -u`; do
                ###echo "TE : $TE"
                NBOK1=`grep -w "^$TE" {params.work_directory}/VALUES_TSD_GROUP_OUTSIDER.csv | grep OK | cut -f 2 || echo "0"`;
                NBOK2=`grep -w "^$TE" {params.work_directory}/VALUES_TSD_INSIDER_GROUP.csv  | grep OK | cut -f 2 || echo "0"`;

                if [ ! -n "$NBOK1" ]; then
                    NBOK1=0;
                fi;

                if [ ! -n "$NBOK2" ]; then
                    NBOK2=0;
                fi;

                NBKO1=`grep -w "^$TE" {params.work_directory}/VALUES_TSD_GROUP_OUTSIDER.csv | grep KO | cut -f 2 || echo "0"`;
                NBKO2=`grep -w "^$TE" {params.work_directory}/VALUES_TSD_INSIDER_GROUP.csv | grep KO | cut -f 2 || echo "0"`;

                if [ ! -n "$NBKO1" ]; then
                    NBKO1=0;
                fi;

                if [ ! -n "$NBKO2" ]; then
                    NBKO2=0;
                fi;

                echo -e "$TE\t$(($NBOK1+$NBOK2))\tTSD OK" >> {params.work_directory}/VALUES_TSD_ALL_GROUP.csv;
                echo -e "$TE\t$(($NBKO1+$NBKO2))\tTSD KO" >> {params.work_directory}/VALUES_TSD_ALL_GROUP.csv;
            done;

            awk 'BEGIN{{print "x\ty\tcondition"}}{{print $0}}' {params.work_directory}/VALUES_TSD_INSIDER_GROUP.csv > {params.work_directory}/tmp.csv
            mv {params.work_directory}/tmp.csv {params.work_directory}/VALUES_TSD_INSIDER_GROUP.csv
        fi;


        #rm -fr DIR_SEQ_TE_READ_POS
        #rm -fr {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/DIR_SEQ_TE_READ_POS
        #rm -f {params.work_directory}/OUTSIDER/FASTA_FIND/*.fasta.*
        rm -fr {params.work_directory}/OUTSIDER/FASTA_FIND
        #test -d DIR_SEQ_TE_READ_POS && \
        #test -d {params.work_directory}/OUTSIDER/TE_DETECTION/TSD/ && \
        rm -f `find {params.work_directory} -name "*.fai"`
        rm -fr {params.work_directory}/TSD_TMP

        """


#END TSD_MULTI_THREADS



#Get just sequence potentiel candidate of TE
rule GET_SEQ_TE :
    input:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/ID_BEST_READ_TE.txt",
        all_te            = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        snif_seqs         = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/VARIANT_CALLING/SEQUENCE_INDEL.fasta",
        input_link=[],

    output:
        directory(config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/ET_FIND_FA/"),
        output_link=[],

    params:
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/GET_SEQ_TE"

    shell:
        """
        
        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] GET SEQUENCE OF TE [^-^] {params.cend}"

        {params.env}
        rm -f {log}*

        echo "[`date`] LOG TASK {log}.out, {log}.err"

        mkdir -p {params.work_directory}/OUTSIDER/ET_FIND_FA ;

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt
        
        rep="{params.work_directory}/OUTSIDER/ET_FIND_FA" 
        prefix="TE_REPORT"

        ##GET ID sniffles
        ( test -s {input.all_te} && \
            awk 'NR>1{{print $2}}' {input.all_te} > {params.work_directory}/.tmp_id.txt && \
                echo "GET ID sniffles ✔" | tee -a {log}.out ) || warn_msg "WARNING : FAIL GET ID sniffles ✘\\n" | tee -a {log}.err ; 

        ##GET ID TrEMOLO
        ( test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/ID_TrEMOLO.txt && \
            awk '{{print "TrEMOLO.INS."$0}}' {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/ID_TrEMOLO.txt > {params.work_directory}/.tmp_id_TrEMOLO.txt ) || \
                warn_msg "WARNING : GET ID TE OUTSIDER TrEMOLO 1 ✘\\n" | tee -a {log}.err ;

        ( test -s {params.work_directory}/.tmp_id_TrEMOLO.txt && \
            grep -w -f {params.work_directory}/.tmp_id_TrEMOLO.txt {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv | awk 'NR>1{{print $2}}' >> {params.work_directory}/.tmp_id.txt && \
                echo "GET ID TrEMOLO ✔" | tee -a {log}.out ) || warn_msg "WARNING : GET ID TE OUTSIDER TrEMOLO 2 ✘\\n" | tee -a {log}.err
        
        
        ##GET ID COMBINE sniffles
        ( test -s {params.work_directory}/.tmp_id.txt && \
            grep -w -f {params.work_directory}/.tmp_id.txt {params.work_directory}/OUTSIDER/TE_DETECTION/COMBINE_TE.csv > {params.work_directory}/.tmp_combine.csv && \
                echo "GET ID COMBINE sniffles ✔" | tee -a {log}.out ) || warn_msg "WARNING : GET ID COMBINE sniffles ✘\\n" | tee -a {log}.err
        
        

        ##GET ID COMBINE TrEMOLO
        ( test -s {params.work_directory}/.tmp_id.txt && \
            grep -w -f {params.work_directory}/.tmp_id.txt {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/COMBINE_INS_TREMOLO.csv >> {params.work_directory}/.tmp_combine.csv && \
                echo "GET ID COMBINE TrEMOLO ✔" | tee -a {log}.out ) || warn_msg "WARNING : GET ID COMBINE TrEMOLO ✘\\n" | tee -a {log}.err
        
        echo "sseqid", "qseqid", "pident", "size_per", "size_el", "mismatch", "gapopen", "qstart", "qend", "sstart", "send", "evalue", "bitscore" | tr -d " " | tr "," "\t" > {params.work_directory}/test.csv
        
        ( test -s {params.work_directory}/.tmp_combine.csv && \
            awk 'NR>1 && OFS="\t"{{print $1, $2, $3, $4, $5, "mismatch", "gapopen", $6, $7, $8, $9, "evalue", "bitscore"}}' {params.work_directory}/.tmp_combine.csv >> {params.work_directory}/tmp.csv ) || \
                warn_msg "NO TE COMBINE FOUND HEAD...\\n" | tee -a {log}.err

        test -s {params.work_directory}/tmp.csv && \
            ( [[ `cat {params.work_directory}/tmp.csv | wc -l` -gt 1 ]] && cat {params.work_directory}/tmp.csv | sed -e 's/:[-+]//g' > {params.work_directory}/tmp_TE_all.csv ) || \
                warn_msg "NO TE COMBINE FOUND ✘\\n" | tee -a {log}.err

        test -s {params.work_directory}/tmp_TE_all.csv && \
            awk -v dir="$rep" -v prefix="$prefix" 'BEGIN{{OFS="\t"}} NR>1 {{
                if($8<$9){{
                    print $2, $8-1, $9  >> dir"/"prefix"_find_"$1".bed"
                }} 
                else{{
                    print $2, $9-1, $8  >> dir"/"prefix"_find_"$1".bed"
                }} 
            }}' {params.work_directory}/tmp_TE_all.csv || \
                warn_msg "NO TE FOUND FOR BED ✘\\n" | tee -a {log}.err;

        ##TrEMOLO INS and sniffles/svim MERGE
        cat {input.snif_seqs} {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.fasta > {params.work_directory}/tmp_SEQ_TE_ALL.fasta

        for i in `ls {params.work_directory}/OUTSIDER/ET_FIND_FA | grep ".bed$"`; 
        do
            bedtools getfasta -fi {params.work_directory}/tmp_SEQ_TE_ALL.fasta \
               -bed {params.work_directory}/OUTSIDER/ET_FIND_FA/$i > {params.work_directory}/OUTSIDER/ET_FIND_FA/TE_REPORT_FOUND_`echo $i \
                | grep -o "find_[^.]*\." | sed 's/\.$//g' | sed 's/find_//g'`.fasta;
        done ;

        echo "IN {params.work_directory}/OUTSIDER/ET_FIND_FA NUMBER OF FAMILY : `ls {params.work_directory}/OUTSIDER/ET_FIND_FA | grep ".fasta" | wc -l`"

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] GETTING DONE ! [^-^] {params.cend}"

        rm -f {params.work_directory}/.tmp*
        rm -f {params.work_directory}/OUTSIDER/ET_FIND_FA/*.bed ;
        rm -f {params.work_directory}/tmp*.*
        rm -f `find {params.work_directory} -name "*.fai"`
        rm -f {params.work_directory}/test.csv
        """


#END GET_SEQ_TE


#Get reads supports
rule GET_READS_TE :
    input:
        all_te       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        bln          = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/BLAST_SEQUENCE_INDEL_vs_DBTE.bln",
        vcf          = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/VARIANT_CALLING/SV.vcf",
        merge_TE_bed = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed",
        read         = config["DATA"]["SAMPLE"],
        fasta_TE     = config["DATA"]["TE_DB"],
        input_link=[],

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/ID_BEST_READ_TE.txt",
        output_link=[],

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        CHROM_KEEP             = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["CHROM_KEEP"],
        GET_SEQ_REPORT_OPTION  = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["GET_SEQ_REPORT_OPTION"],
        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/GET_READS_TE"

    shell:
        """
        {params.env}
        rm -f {log}*

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] GET READS [^-^] {params.cend}"

        echo "[`date`] LOG TASK {log}.out, {log}.err"

        rm -fr {params.work_directory}/OUTSIDER/READ_FASTQ_TE
        mkdir -p {params.work_directory}/OUTSIDER/READ_FASTQ_TE ;

        path_to_pipline=`dirname {params.path_snk}`

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        ###TEST DEBUG
        #####test OUTSIDER TE EMPTY
        ###printf "" > {input.merge_TE_bed}

        test -s {input.merge_TE_bed} || warn_msg "WARNING : NO TE OUTSIDER\\n" | tee -a {log}.err;

        #GET ID only TE found sniffles
        ( test -s {input.merge_TE_bed} && \
            grep -E "sniffles.INS|sniffles.DEL" {input.merge_TE_bed} | cut -f 4 | cut -d "|" -f 2 > {params.work_directory}/ID_TE_SV_REPORT.txt && \
                echo "GET ID TE OUTSIDER sniffles ✔" | tee -a {log}.out ) || warn_msg "WARNING : FAIL GET ID TE OUTSIDER sniffles ✘\\n" | tee -a {log}.err ; 

        ##TODO : EXTRACT DEL
        #EXTRACT ID ALL READS SUPPORT sniffles
        ## sniffles/svim
        ( test -s {input.vcf} && \
            python3 ${{path_to_pipline}}/lib/python/parsing/extract_region_reads_vcf.py {params.GET_SEQ_REPORT_OPTION} -t "." -c '{params.CHROM_KEEP}' \
              {input.vcf} \
             -d {params.work_directory}/OUTSIDER/ID_READS_TE \
             -i {params.work_directory}/ID_TE_SV_REPORT.txt 2>> {log}.err && \
                echo "EXTRACT ALL ID READS SUPPORT sniffles ✔" | tee -a {log}.out ) || warn_msg "WARNING : EXTRACT ALL ID READS SUPPORT sniffles ✘\\n" | tee -a {log}.err;

        echo "  READS SUPPORT sniffles EXTRACTED : "`ls {params.work_directory}/OUTSIDER/ID_READS_TE | wc -l`


        ( test -s {input.merge_TE_bed} && \
            grep "TrEMOLO.INS" {input.merge_TE_bed} | cut -f 4 | cut -d "|" -f 2 | cut -d "." -f 3 > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/ID_TrEMOLO.txt || \
                touch {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/ID_TrEMOLO.txt && \
                    echo "GET ID TrEMOLO ✔" | tee -a {log}.out ) || warn_msg "WARNING : GET ID TrEMOLO ✘\\n" | tee -a {log}.err; 

        rm -f {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/tmp_clust.bed;
        ##TODO create index file for more fast traitement
        ( test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/ID_TrEMOLO.txt && \
            for ID in `cat {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/ID_TrEMOLO.txt`; 
            do 
                awk -v ID="$ID" '$6==ID {{print $0}}' {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.bed >> {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/tmp_clust.bed; 
            done && \
                echo "GET BED TE CLUST TrEMOLO ✔" | tee -a {log}.out ) || warn_msg "WARNING : GET BED TE CLUST TrEMOLO ✘\\n" | tee -a {log}.err ;


        ##INS CIGAR EXTRACTION
        ( test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/tmp_clust.bed && \
            awk -v path="{params.work_directory}/OUTSIDER/ID_READS_TE" '
                BEGIN{{
                    clust = 0;
                }}

                {{
                    if(clust == 0){{
                        chrom=$1; 
                        start=$2; 
                        end=$3; 
                        clust=$6;
                        
                        dic_clust[clust][1]["ID"]      = "TrEMOLO.INS."clust;
                        dic_clust[clust][1]["seq"]     = $5;
                        dic_clust[clust][1]["RS"]      = 1;
                        dic_clust[clust][1]["READ"]    = $4;
                    }}
                    else if(clust != 0 && clust != $6){{
                        chrom=$1; 
                        start=$2; 
                        end=$3;
                        
                        for(i=1; i <= dic_clust[clust][1]["RS"]; i++){{
                            print dic_clust[clust][i]["READ"] >> path"/reads_"chrom":"dic_clust[clust][1]["ID"]":"start"-"end".txt";
                        }}

                        clust=$6;

                        dic_clust[clust][1]["ID"]      = "TrEMOLO.INS."clust;
                        dic_clust[clust][1]["RS"]      = 1;
                        dic_clust[clust][1]["READ"]    = $4;

                    }}
                    else{{#CHECK READ EXIST
                        IN = 0;
                        for(i=1; i <= dic_clust[clust][1]["RS"]; i++){{
                            if(dic_clust[clust][i]["READ"] == $4){{
                                IN = 1;
                                i = dic_clust[clust][1]["RS"] + 1;
                            }}
                        }}

                        if(IN == 0){{
                            dic_clust[clust][1]["RS"] += 1;
                            dic_clust[clust][dic_clust[clust][1]["RS"]]["READ"] = $4;
                        }}
                        
                    }} 
                }}

                END{{
                    for(i=1; i <= dic_clust[clust][1]["RS"]; i++){{
                        print dic_clust[clust][i]["READ"] >> path"/reads_"chrom":"dic_clust[clust][1]["ID"]":"start"-"end".txt";
                    }}
                }}' {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/tmp_clust.bed && \
                    echo "GET READS TrEMOLO ✔" | tee -a {log}.out ) || warn_msg "WARNING : GET READS TrEMOLO ✘\\n" | tee -a {log}.err ; 

        echo "  READS SUPPORT TrEMOLO EXTRACTED : "`ls {params.work_directory}/OUTSIDER/ID_READS_TE | grep "TrEMOLO" | wc -l` | tee -a {log}.out

        ##TODO SOFT CIGAR EXTRACTION

        NB_FILE=`ls {params.work_directory}/OUTSIDER/ID_READS_TE | grep -v total -c`;
        i=0;

        show_step="$i/$NB_FILE TE "
        number_of_char=`echo "$show_step" | wc -c`
        number_of_char=$(($number_of_char-1));
        printf "\b%.0s" `seq 1 $number_of_char`
        printf "$show_step";

        PATH=`echo $PATH | sed "s|${{SAMTOOLS_1_9}}|${{SAMTOOLS_1_15_1}}|g"`

        samtools fqidx {input.read}

        #EXTRACT ALL READS SUPPORT
        for read_file in `ls {params.work_directory}/OUTSIDER/ID_READS_TE`; do

            region=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]"` ;

            echo -e "@read_file:$read_file; \\n@##region:$region" >> {log}.err
            
            if ! test -s {params.work_directory}/OUTSIDER/READ_FASTQ_TE/reads_${{region}}.fastq; then

                id=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]" | cut -d":" -f 2`
                nb_read=`cat {params.work_directory}/OUTSIDER/ID_READS_TE/$read_file | sort | uniq | wc -l`
                #TODO ?
                #TE=`(grep ":$id:[0-9]*:[IP]" {input.all_te} || grep ":$id:[0-9]*:[IP]" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv) | cut -f 1 || echo "NONE"`

                printf "%s\\n" "      {params.cmess} [SNK]--[`date`] [GET_READS_TE:snk] $read_file {params.cend}" >> {log}.out
                printf "%s\\n" "      {params.cmess} [SNK]--[`date`] [GET_READS_TE:snk] [GET_READS_TE:snk] $i/$NB_FILE : nb_read=$nb_read : id=$id {params.cend}" >> {log}.out

                test -s {input.read}.fai || samtools fqidx {input.read}

                ## EXTRACT READS
                ( test -s {params.work_directory}/OUTSIDER/ID_READS_TE/$read_file && \
                    samtools fqidx {input.read} --fai-idx {input.read}.fai -r {params.work_directory}/OUTSIDER/ID_READS_TE/$read_file > \
                        {params.work_directory}/OUTSIDER/READ_FASTQ_TE/reads_${{region}}.fq ) || echo "$id NOT FOUND TrEMOLO" >> {log}.err ;

                ## CHANGE TO GOOD EXACTLY FORMAT FASTQ
                ( test -s {params.work_directory}/OUTSIDER/READ_FASTQ_TE/reads_${{region}}.fq && \
                    python3 ${{path_to_pipline}}/lib/python/format_files/fastq_to_fastq.py \
                         {params.work_directory}/OUTSIDER/READ_FASTQ_TE/reads_${{region}}.fq \
                         {params.work_directory}/OUTSIDER/READ_FASTQ_TE/reads_${{region}}.fastq >> {log}.out 2>> {log}.err ) || ( fail_msg "READ EXTRACT id=$id FAIL NOT FOUND \\n" && exit 1);

                test -s {params.work_directory}/OUTSIDER/READ_FASTQ_TE/reads_${{region}}.fastq || echo "[ERROR EXTRACT READ] $id" >> {log}.err
                
                rm -f {params.work_directory}/OUTSIDER/READ_FASTQ_TE/reads_${{region}}.fq
            fi;

            i=$(($i + 1));

            show_step="$i/$NB_FILE TE "
            number_of_char=`echo "$show_step" | wc -c`
            number_of_char=$(($number_of_char-1));
            printf "\b%.0s" `seq 1 $number_of_char`
            printf "$show_step";
        done; 

        printf "\\n%s\\n\\n" "{params.cmess} [SNK]--[`date`] EXTRACT DONE ! {params.cend}"

        #CHECK IF ALL READS ARE EXTRACTED
        NB_REGION=`ls {params.work_directory}/OUTSIDER/ID_READS_TE | wc -l`;
        NB_READS=`ls {params.work_directory}/OUTSIDER/READ_FASTQ_TE | wc -l`;

        echo "READS EXTRACTED : $NB_READS/$NB_REGION" | tee -a {log}.out

        ##GET BEST ID TE sniffles
        rm -f {params.work_directory}/tmp_ID_RD_SEQ.txt
        ( test -s {input.all_te} && \
            awk 'NR>1 {{print $2}}' {input.all_te} | cut -d ":" -f 5,8 > {params.work_directory}/tmp_ID_RD_SEQ.txt ) || \
                echo "WARNING : GET BEST ID READ tmp_ID_RD_SEQ sniffles ✘" >> {log}.err;

        ( test -s {params.work_directory}/ID_TE_SV_REPORT.txt && test -s {params.work_directory}/tmp_ID_RD_SEQ.txt && \
            grep -w -f {params.work_directory}/ID_TE_SV_REPORT.txt {params.work_directory}/tmp_ID_RD_SEQ.txt > {params.work_directory}/ID_RD_SEQ.txt ) || \
                echo "WARNING : GET BEST ID READ ID_RD_SEQ sniffles ✘" >> {log}.err;

        rm -f {params.work_directory}/OUTSIDER/ID_BEST_READ_TE.txt
        ( test -s {params.work_directory}/ID_RD_SEQ.txt && \
            for i in `cat {params.work_directory}/ID_RD_SEQ.txt`; 
            do  
                ID=`echo $i | cut -d ":" -f 1`; 
                num=`echo $i | cut -d ":" -f 2`; 
                name_file=`ls {params.work_directory}/OUTSIDER/ID_READS_TE/ | grep -w "$ID"`; 

                awk -v num="$num" -v ID="$ID" 'NR-1 == num {{print "ID="ID";RD="$0}}' {params.work_directory}/OUTSIDER/ID_READS_TE/$name_file >> {params.work_directory}/OUTSIDER/ID_BEST_READ_TE.txt;
            done && \
                echo "GET BEST ID READ sniffles ✔" | tee -a {log}.out ) || warn_msg "WARNING : GET BEST ID READ sniffles ✘\\n" | tee -a {log}.err;

        ##GET BEST ID TE TrEMOLO
        rm -f {params.work_directory}/tmp_ID_RD_SEQ.txt
        ( test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv && \
            awk 'NR>1 {{print $2}}' {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv | cut -d ":" -f 5,8 > {params.work_directory}/tmp_ID_RD_SEQ.txt ) || \
                echo "WARNING : GET BEST ID READ tmp_ID_RD_SEQ TrEMOLO ✘" >> {log}.err;

        ( test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/ID_TrEMOLO.txt && \
            awk '{{print "TrEMOLO.INS."$0}}' {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/ID_TrEMOLO.txt > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/tmp_ID_TrEMOLO.txt ) || \
                echo "WARNING : GET BEST ID READ tmp_ID_TrEMOLO TrEMOLO ✘" >> {log}.err;

        ( test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/tmp_ID_TrEMOLO.txt && test -s {params.work_directory}/tmp_ID_RD_SEQ.txt && \
            grep -w -f {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/tmp_ID_TrEMOLO.txt {params.work_directory}/tmp_ID_RD_SEQ.txt > {params.work_directory}/ID_RD_SEQ.txt ) || \
                echo "WARNING : GET BEST ID READ ID_RD_SEQ TrEMOLO ✘" >> {log}.err;

        ( test -s {params.work_directory}/ID_RD_SEQ.txt && \
            for i in `cat {params.work_directory}/ID_RD_SEQ.txt`;
            do
                ID=`echo $i | cut -d ":" -f 1`;
                num=`echo $i | cut -d ":" -f 2`; 
                name_file=`ls {params.work_directory}/OUTSIDER/ID_READS_TE/ | grep -w "$ID"`; 

                awk -v num="$num" -v ID="$ID" 'NR == num {{print "ID="ID";RD="$0}}' {params.work_directory}/OUTSIDER/ID_READS_TE/$name_file >> {params.work_directory}/OUTSIDER/ID_BEST_READ_TE.txt;
            done && \
                echo "GET BEST ID READ TrEMOLO ✔" | tee -a {log}.out ) || warn_msg "WARNING : GET BEST ID READ TrEMOLO ✘\\n" | tee -a {log}.err;

        PATH=`echo $PATH | sed "s|${{SAMTOOLS_1_15_1}}|${{SAMTOOLS_1_9}}|g"`

        ## REMOVE
        rm -f {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/tmp_*
        rm -f {params.work_directory}/ID_RD_SEQ.txt {params.work_directory}/ID_TE_SV_REPORT.txt \
            {params.work_directory}/tmp_*.txt
        rm -f `find {params.work_directory} -name "*.fai"`
        ###rm -fr {params.work_directory}/OUTSIDER/ID_READS_TE
        """


#END GET_READS_TE


#GET READS PARALLELIZE
rule GET_READS_TE_MULTI_THREADS :
    input:
        all_te       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        bln          = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/BLAST_SEQUENCE_INDEL_vs_DBTE.bln",
        vcf          = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/VARIANT_CALLING/SV.vcf",
        merge_TE_bed = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed",
        read         = config["DATA"]["SAMPLE"],
        fasta_TE     = config["DATA"]["TE_DB"],
        input_link=[],

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/ID_BEST_READ_TE.txt",
        output_link=[],

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        threads                = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,

        CHROM_KEEP             = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["CHROM_KEEP"],
        GET_SEQ_REPORT_OPTION  = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["GET_SEQ_REPORT_OPTION"],
        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/GET_READS_TE"

    shell:
        """
        {params.env}
        rm -f {log}*

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] GET READS [^-^] {params.cend}"

        echo "[`date`] LOG TASK {log}.out, {log}.err"


        rm -fr {params.work_directory}/OUTSIDER/READ_FASTQ_TE
        mkdir -p {params.work_directory}/OUTSIDER/READ_FASTQ_TE ;

        path_to_pipline=`dirname {params.path_snk}`

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        ###TEST DEBUG
        #####test OUTSIDER TE EMPTY
        ###printf "" > {input.merge_TE_bed}

        test -s {input.merge_TE_bed} || warn_msg "WARNING : NO TE OUTSIDER\\n" | tee -a {log}.err;

        #GET ID only TE found sniffles
        ( test -s {input.merge_TE_bed} && \
            grep "sniffles.INS" {input.merge_TE_bed} | cut -f 4 | cut -d "|" -f 2 > {params.work_directory}/ID_TE_SV_REPORT.txt && \
                echo "GET ID TE OUTSIDER sniffles ✔" | tee -a {log}.out ) || warn_msg "WARNING : FAIL GET ID TE OUTSIDER sniffles ✘\\n" | tee -a {log}.err ; 


        #EXTRACT ID ALL READS SUPPORT sniffles
        ## sniffles/svim
        ( test -s {input.vcf} && \
            python3 ${{path_to_pipline}}/lib/python/parsing/extract_region_reads_vcf.py {params.GET_SEQ_REPORT_OPTION} -c '{params.CHROM_KEEP}' \
              {input.vcf} \
             -d {params.work_directory}/OUTSIDER/ID_READS_TE \
             -i {params.work_directory}/ID_TE_SV_REPORT.txt && \
                echo "EXTRACT ALL ID READS SUPPORT sniffles ✔" | tee -a {log}.out ) || warn_msg "WARNING : EXTRACT ID ALL READS SUPPORT sniffles ✘\\n" | tee -a {log}.err;

        echo "  READS SUPPORT sniffles EXTRACTED : "`ls {params.work_directory}/OUTSIDER/ID_READS_TE | wc -l`


        ( test -s {input.merge_TE_bed} && \
            grep "TrEMOLO.INS" {input.merge_TE_bed} | cut -f 4 | cut -d "|" -f 2 | cut -d "." -f 3 > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/ID_TrEMOLO.txt || \
                touch {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/ID_TrEMOLO.txt && \
                    echo "GET ID TrEMOLO ✔" | tee -a {log}.out ) || warn_msg "WARNING : GET ID TrEMOLO ✘\\n" | tee -a {log}.err; 

        rm -f {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/tmp_clust.bed;
        ##TODO create index file for more fast traitement
        ( test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/ID_TrEMOLO.txt && \
            for ID in `cat {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/ID_TrEMOLO.txt`; 
            do 
                awk -v ID="$ID" '$6==ID {{print $0}}' {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.bed >> {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/tmp_clust.bed; 
            done && \
                echo "GET BED TE CLUST TrEMOLO ✔" | tee -a {log}.out ) || warn_msg "WARNING : GET BED TE CLUST TrEMOLO ✘\\n" | tee -a {log}.err ;


        ##INS CIGAR EXTRACTION
        ( test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/tmp_clust.bed && \
            awk -v path="{params.work_directory}/OUTSIDER/ID_READS_TE" '
                BEGIN{{
                    clust = 0;
                }}

                {{
                    if(clust == 0){{
                        chrom=$1; 
                        start=$2; 
                        end=$3; 
                        clust=$6;
                        
                        dic_clust[clust][1]["ID"]      = "TrEMOLO.INS."clust;
                        dic_clust[clust][1]["seq"]     = $5;
                        dic_clust[clust][1]["RS"]      = 1;
                        dic_clust[clust][1]["READ"]    = $4;
                    }}
                    else if(clust != 0 && clust != $6){{
                        chrom=$1; 
                        start=$2; 
                        end=$3;
                        
                        for(i=1; i <= dic_clust[clust][1]["RS"]; i++){{
                            print dic_clust[clust][i]["READ"] >> path"/reads_"chrom":"dic_clust[clust][1]["ID"]":"start"-"end".txt";
                        }}

                        clust=$6;

                        dic_clust[clust][1]["ID"]      = "TrEMOLO.INS."clust;
                        dic_clust[clust][1]["RS"]      = 1;
                        dic_clust[clust][1]["READ"]    = $4;

                    }}
                    else{{#CHECK READ EXIST
                        IN = 0;
                        for(i=1; i <= dic_clust[clust][1]["RS"]; i++){{
                            if(dic_clust[clust][i]["READ"] == $4){{
                                IN = 1;
                                i = dic_clust[clust][1]["RS"] + 1;
                            }}
                        }}

                        if(IN == 0){{
                            dic_clust[clust][1]["RS"] += 1;
                            dic_clust[clust][dic_clust[clust][1]["RS"]]["READ"] = $4;
                        }}
                        
                    }} 
                }}

                END{{
                    for(i=1; i <= dic_clust[clust][1]["RS"]; i++){{
                        print dic_clust[clust][i]["READ"] >> path"/reads_"chrom":"dic_clust[clust][1]["ID"]":"start"-"end".txt";
                    }}
                }}' {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/tmp_clust.bed && \
                    echo "GET READS TrEMOLO ✔" | tee -a {log}.out ) || warn_msg "WARNING : GET READS TrEMOLO ✘\\n" | tee -a {log}.err ; 

        echo "  READS SUPPORT TrEMOLO EXTRACTED : "`ls {params.work_directory}/OUTSIDER/ID_READS_TE | grep "TrEMOLO" | wc -l` | tee -a {log}.out

        ##TODO SOFT CIGAR EXTRACTION


        NB_FILE=`ls {params.work_directory}/OUTSIDER/ID_READS_TE | grep -v total -c` ;
        i=0 ;

        show_step="$i/$NB_FILE TE "
        number_of_char=`echo "$show_step" | wc -c`
        number_of_char=$(($number_of_char-1));
        printf "\b%.0s" `seq 1 $number_of_char`
        printf "$show_step";

        get_read() {{
            read_file=$1;
            i=$2;

            region=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]"` ;

            echo -e "@read_file:$read_file; \\n@##region:$region" >> {log}.err
            
            if ! test -s {params.work_directory}/OUTSIDER/READ_FASTQ_TE/reads_${{region}}.fastq; then

                id=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]" | cut -d":" -f 2`
                nb_read=`cat {params.work_directory}/OUTSIDER/ID_READS_TE/$read_file | sort | uniq | wc -l`
                #TODO ?
                #TE=`(grep ":$id:[0-9]*:[IP]" {input.all_te} || grep ":$id:[0-9]*:[IP]" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv) | cut -f 1 || echo "NONE"`

                printf "%s\\n" "      {params.cmess} [SNK]--[`date`] [GET_READS_TE:snk] $read_file {params.cend}" >> {log}.out
                printf "%s\\n" "      {params.cmess} [SNK]--[`date`] [GET_READS_TE:snk] [GET_READS_TE:snk] $i/$NB_FILE : nb_read=$nb_read : id=$id {params.cend}" >> {log}.out

                test -s {input.read}.fai || samtools fqidx {input.read}

                ## EXTRACT READS
                ( test -s {params.work_directory}/OUTSIDER/ID_READS_TE/$read_file && \
                    samtools fqidx {input.read} --fai-idx {input.read}.fai -r {params.work_directory}/OUTSIDER/ID_READS_TE/$read_file > \
                        {params.work_directory}/OUTSIDER/READ_FASTQ_TE/reads_${{region}}.fq ) || echo "$id NOT FOUND TrEMOLO" >> {log}.err ;

                ## CHANGE TO GOOD EXACTLY FORMAT FASTQ
                ( test -s {params.work_directory}/OUTSIDER/READ_FASTQ_TE/reads_${{region}}.fq && \
                    python3 ${{path_to_pipline}}/lib/python/format_files/fastq_to_fastq.py \
                         {params.work_directory}/OUTSIDER/READ_FASTQ_TE/reads_${{region}}.fq \
                         {params.work_directory}/OUTSIDER/READ_FASTQ_TE/reads_${{region}}.fastq >> {log}.out 2>> {log}.err ) || ( fail_msg "READ EXTRACT id=$id FAIL NOT FOUND \\n" && exit 1);

                test -s {params.work_directory}/OUTSIDER/READ_FASTQ_TE/reads_${{region}}.fastq || echo "[ERROR EXTRACT READ] $id" >> {log}.err
                
                rm -f {params.work_directory}/OUTSIDER/READ_FASTQ_TE/reads_${{region}}.fq
            fi;
        }}

        
        PATH=`echo $PATH | sed "s|${{SAMTOOLS_1_9}}|${{SAMTOOLS_1_15_1}}|g"`
        #index
        samtools fqidx {input.read}

        #PARLELIZE
        count_task_running=0;
        pids=();
        #EXTRACT ALL READS SUPPORT
        for read_file in `ls {params.work_directory}/OUTSIDER/ID_READS_TE`; do

            get_read "$read_file" "$i" &
            pids[${{count_task_running}}]=$!;
            count_task_running=$(($count_task_running+1));

            if [ $count_task_running -ge {params.threads} ]; then
                c=1;
                for pid in ${{pids[*]}}; do
                    wait $pid || echo > /dev/null;
                    #echo "PID : $pid; TASK : $i; N : $c; done !"
                    c=$(($c+1));
                done;
                pids=();
                count_task_running=0;
            fi;

            i=$(($i + 1));

            show_step="$i/$NB_FILE TE "
            number_of_char=`echo "$show_step" | wc -c`
            number_of_char=$(($number_of_char-1));
            printf "\b%.0s" `seq 1 $number_of_char`
            printf "$show_step";
        done;

        #WAIT LAST TASKS
        if [ $count_task_running -lt {params.threads} ]; then
            pids[${{count_task_running}}]=$!
            task=1;
            for pid in ${{pids[*]}}; do
                wait $pid || echo > /dev/null;
                #echo "PID : $pid; TASK : $i; N : $c; done !"
                task=$(($task+1));
            done;
        fi;

        printf "\\n%s\\n" "{params.cmess} [SNK]--[`date`] EXTRACT DONE ! {params.cend}"

        #CHECK IF ALL READS ARE EXTRACTED
        NB_REGION=`ls {params.work_directory}/OUTSIDER/ID_READS_TE | wc -l`;
        NB_READS=`ls {params.work_directory}/OUTSIDER/READ_FASTQ_TE | wc -l`;

        echo "READS EXTRACTED : $NB_READS/$NB_REGION" | tee -a {log}.out

        ##GET BEST ID TE sniffles
        rm -f {params.work_directory}/tmp_ID_RD_SEQ.txt
        ( test -s {input.all_te} && \
            awk 'NR>1 {{print $2}}' {input.all_te} | cut -d ":" -f 5,8 > {params.work_directory}/tmp_ID_RD_SEQ.txt ) || \
                echo "WARNING : GET BEST ID READ tmp_ID_RD_SEQ sniffles ✘" >> {log}.err;

        ( test -s {params.work_directory}/ID_TE_SV_REPORT.txt && test -s {params.work_directory}/tmp_ID_RD_SEQ.txt && \
            grep -w -f {params.work_directory}/ID_TE_SV_REPORT.txt {params.work_directory}/tmp_ID_RD_SEQ.txt > {params.work_directory}/ID_RD_SEQ.txt ) || \
                echo "WARNING : GET BEST ID READ ID_RD_SEQ sniffles ✘" >> {log}.err;

        rm -f {params.work_directory}/OUTSIDER/ID_BEST_READ_TE.txt
        ( test -s {params.work_directory}/ID_RD_SEQ.txt && \
            for i in `cat {params.work_directory}/ID_RD_SEQ.txt`; 
            do  
                ID=`echo $i | cut -d ":" -f 1`; 
                num=`echo $i | cut -d ":" -f 2`; 
                name_file=`ls {params.work_directory}/OUTSIDER/ID_READS_TE/ | grep -w "$ID"`; 

                awk -v num="$num" -v ID="$ID" 'NR-1 == num {{print "ID="ID";RD="$0}}' {params.work_directory}/OUTSIDER/ID_READS_TE/$name_file >> {params.work_directory}/OUTSIDER/ID_BEST_READ_TE.txt;
            done && \
                echo "GET BEST ID READ sniffles ✔" | tee -a {log}.out ) || warn_msg "WARNING : GET BEST ID READ sniffles ✘\\n" | tee -a {log}.err;


        ##GET BEST ID TE TrEMOLO
        rm -f {params.work_directory}/tmp_ID_RD_SEQ.txt
        ( test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv && \
            awk 'NR>1 {{print $2}}' {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv | cut -d ":" -f 5,8 > {params.work_directory}/tmp_ID_RD_SEQ.txt ) || \
                echo "WARNING : GET BEST ID READ tmp_ID_RD_SEQ TrEMOLO ✘" >> {log}.err;

        ( test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/ID_TrEMOLO.txt && \
            awk '{{print "TrEMOLO.INS."$0}}' {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/ID_TrEMOLO.txt > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/tmp_ID_TrEMOLO.txt ) || \
                echo "WARNING : GET BEST ID READ tmp_ID_TrEMOLO TrEMOLO ✘" >> {log}.err;

        ( test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/tmp_ID_TrEMOLO.txt && test -s {params.work_directory}/tmp_ID_RD_SEQ.txt && \
            grep -w -f {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/tmp_ID_TrEMOLO.txt {params.work_directory}/tmp_ID_RD_SEQ.txt > {params.work_directory}/ID_RD_SEQ.txt ) || \
                echo "WARNING : GET BEST ID READ ID_RD_SEQ TrEMOLO ✘" >> {log}.err;

        ( test -s {params.work_directory}/ID_RD_SEQ.txt && \
            for i in `cat {params.work_directory}/ID_RD_SEQ.txt`;
            do
                ID=`echo $i | cut -d ":" -f 1`;
                num=`echo $i | cut -d ":" -f 2`; 
                name_file=`ls {params.work_directory}/OUTSIDER/ID_READS_TE/ | grep -w "$ID"`; 

                awk -v num="$num" -v ID="$ID" 'NR == num {{print "ID="ID";RD="$0}}' {params.work_directory}/OUTSIDER/ID_READS_TE/$name_file >> {params.work_directory}/OUTSIDER/ID_BEST_READ_TE.txt;
            done && \
                echo "GET BEST ID READ TrEMOLO ✔" | tee -a {log}.out ) || warn_msg "WARNING : GET BEST ID READ TrEMOLO ✘\\n" | tee -a {log}.err;

        PATH=`echo $PATH | sed "s|${{SAMTOOLS_1_15_1}}|${{SAMTOOLS_1_9}}|g"`

        ## REMOVE
        rm -f {params.work_directory}/ID_RD_SEQ.txt {params.work_directory}/ID_TE_SV_REPORT.txt
        rm -f `find {params.work_directory} -name "*.fai"`
        rm -fr {params.work_directory}/OUTSIDER/ID_READS_TE
        """


#END GET_READS_TE_MULTI_THREADS



rule FREQUENCE :
    input:
        vcf           = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/VARIANT_CALLING/SV.vcf",
        fasta_TE      = config["DATA"]["TE_DB"],
        bam           = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/MAPPING/SAMPLE_mapping_GENOME_MD.sorted.bam",
        all_te        = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        genome        = config["DATA"]["GENOME"],
        SOFT_TE       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.csv",
        bed           = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.bed",
        bed_INS       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.bed",
        merge_TE_bed  = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed",
        outsider_bed  = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/POSITION_TE_OUTSIDER.bed",
        input_link=[],

    output:
        output_link=[],
        depth_te  = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/FREQ_OPTIMIZED/DEPTH_TE.csv",
        # bam_TE    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/FREQ_OPTIMIZED/MAPPING_POSTION_TE_MD.sorted.bam",
        
    params:
        path_snk        = path_snk,
        work_directory  = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        preset_view    = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_VIEW"]["PRESET_OPTION"]) + " --threads " + str(config["PARAMS"]["THREADS"]),
        preset_sort    = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_SORT"]["PRESET_OPTION"]) + " --threads " + str(config["PARAMS"]["THREADS"]),
        preset_callmd  = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_CALLMD"]["PRESET_OPTION"]) + " --threads " + str(config["PARAMS"]["THREADS"]),

        pars_bln_option = config["PARAMS"]["OUTSIDER_VARIANT"]["PARS_BLN_OPTION"],

        env             = env, #source environnement

        call_sv         = config["CHOICE"]["OUTSIDER_VARIANT"]["CALL_SV"],

        CHROM_KEEP             = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["CHROM_KEEP"],
        GET_SEQ_REPORT_OPTION  = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["GET_SEQ_REPORT_OPTION"],


        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/FREQUENCE"

    shell:
        """
        {params.env}

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] OPTIMIZE FREQUENCE [^-^] {params.cend}"

        path_to_pipline=`dirname {params.path_snk}`

        mkdir -p {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED

        rm -f {log}.out {log}.err
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        ###TEST DEBUG
        #####test OUTSIDER EMPTY
        ###printf "" > {input.outsider_bed}

        test -s {input.outsider_bed} || warn_msg "WARNING : NO TE OUTSIDER\\n" | tee -a {log}.err;

        touch {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_POSITION_START_TE.bed
        test -s {input.outsider_bed} && \
            awk -v size="15" '{{ if($2-size > 0){{  print $1, $2-size, $3+size, $4 }}else{{ print $1, $2, $3+size, $4  }} }}' {input.outsider_bed} > {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_POSITION_START_TE.bed
        samtools view {params.preset_view} -h -b {input.bam} -L {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_POSITION_START_TE.bed > {params.work_directory}/OUTSIDER/MAPPING/MAPPING_POSTION_TE.bam

        echo "GET BAM TE OUTSIDER ✔" | tee -a {log}.out

        FLAG_EXLUDE=`(echo {params.preset_view} | grep -E "\-F [0-9]+" > /dev/null && echo "") || echo "-F 2820"`

        samtools index {params.work_directory}/OUTSIDER/MAPPING/MAPPING_POSTION_TE.bam
        samtools view {params.preset_view} -h ${{FLAG_EXLUDE}} {params.work_directory}/OUTSIDER/MAPPING/MAPPING_POSTION_TE.bam > {params.work_directory}/MAPPING_POSTION_TE.sam

        echo "GET SAM TE OUTSIDER ✔" | tee -a {log}.out

        test -s {input.outsider_bed} && \
            awk 'OFS="\t"{{print $1, $2, $5, $4}}' {input.outsider_bed} \
                | sort -k 1 > {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/TE_POSITION_SIZE.txt

        ##CONVERSION OF CLIPPED READS
        echo "CHECK MAPPING POSTITION TE : " >> {log}.err
        echo "NB_LINE IN SAM FILE : "`grep -v "^@" {params.work_directory}/MAPPING_POSTION_TE.sam | wc -l` >> {log}.err || fail_msg "ERROR : NO READS MAPPING POSTITION TE\\n" | tee -a {log}.err
        
        ( test -s {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/TE_POSITION_SIZE.txt && \
            ${{path_to_pipline}}/lib/bash/awk_not_cliping.sh {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/TE_POSITION_SIZE.txt \
                {params.work_directory}/MAPPING_POSTION_TE.sam \
                {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_MAPPING_POSTION_TE.sam && \
                    echo "CLIPPED TO NOT CLIPPED ✔" | tee -a {log}.out ) || fail_msg "ERROR ; NO TE POSITION SIZE\\n" | tee -a {log}.err

        test -s {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_MAPPING_POSTION_TE.sam && \
            samtools sort {params.preset_sort} {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_MAPPING_POSTION_TE.sam > {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_MAPPING_POSTION_TE.sorted.bam && \
                samtools index {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_MAPPING_POSTION_TE.sorted.bam
        
        ( test -s {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_MAPPING_POSTION_TE.sorted.bam && \
            samtools calmd {params.preset_callmd} {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_MAPPING_POSTION_TE.sorted.bam {input.genome} > {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_MAPPING_POSTION_TE_MD.sorted.bam 2> {log}.err && \
                samtools view {params.preset_view} -b -h {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_MAPPING_POSTION_TE_MD.sorted.bam > {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/MAPPING_POSTION_TE_MD.sorted.bam && \
                    samtools index {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/MAPPING_POSTION_TE_MD.sorted.bam && echo "...BAM CLIPPED TO NOT CLIPPED ✔" | tee -a {log}.out ) || fail_msg "...FAILED BAM CLIPPED TO NOT CLIPPED ✘" | tee -a {log}.out

        number_lines=`cat {input.outsider_bed} | wc -l`

        i=0;
        printf "chrom\tposition\ttotal_depth\tdepth_empty_site\tread_support\tread_support_percent\tTE\tinfo_TE\\n" > {output.depth_te}
        while read line; do
            echo "Line : $line" >> {log}.err;
            ID=`echo $line | awk '{{ split($4, sp, "|"); print sp[2] }}'`
            TE=`echo $line | awk '{{ split($4, sp, "|"); print sp[1] }}'`
            
            chrom=`echo $line | awk '{{ print $1 }}'`
            start=`echo $line | awk '{{ print $2 }}'`
            end=`echo $line | awk '{{ print $3 }}'`
            size_TE=`echo $line | awk '{{ print $5 }}'`

            #TODO make global insertion count for less system calls
            rm -f {params.work_directory}/tmp_info.txt
            python3 ${{path_to_pipline}}/lib/python/parsing/find_ins.py -d 200 {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/MAPPING_POSTION_TE_MD.sorted.bam "$chrom:$start-$end:$size_TE" > {params.work_directory}/tmp_info.txt || echo "ERROR : find_ins=$chrom:$start-$end:$size_TE" >> {log}.err

            echo "tmp_info_ins : " >> {log}.err
            cat {params.work_directory}/tmp_info.txt >> {log}.err

            DEPTH=`grep -w DEPTH {params.work_directory}/tmp_info.txt | cut -d ":" -f 2`
            RS=`grep -w INS {params.work_directory}/tmp_info.txt | cut -d ":" -f 2`
            ID_type=`echo $ID | cut -d "." -f 1`

            #echo "ID_TYPE:$ID_type; RS:$RS; DEPTH:$DEPTH; ID:$ID";
            echo "ID_TYPE:$ID_type; RS:$RS; DEPTH:$DEPTH; ID:$ID" >> {log}.err

            echo "...GET RS and DEPTH" >> {log}.err

            ##KEEP OLD FREQUENCY
            if [ $RS -eq 0 ]; then
                echo "in.. ID_type=$ID_type" >> {log}.err
                if [ "$ID_type" = "sniffles" ] || [ "$ID_type" = "svim" ]; then
                    echo -e "\\nsniffles >> $ID:" >> {log}.err
                    grep -w "$ID" {params.work_directory}/OUTSIDER/TE_DETECTION/DEPTH_TE.csv >> {log}.err || echo "ERROR : $ID" >> {log}.err
                    
                    check_no_error=`grep -w "$ID" {params.work_directory}/OUTSIDER/TE_DETECTION/DEPTH_TE.csv | grep -o "ERROR" || echo "OK"`;
                    if [ "$check_no_error" != "ERROR" ]; then
                        RS=`grep -w "$ID" {params.work_directory}/OUTSIDER/TE_DETECTION/DEPTH_TE.csv | cut -f 5 || echo 0`
                    else
                        RS=0;
                    fi;
                    DEPTH=`grep -w "$ID" {params.work_directory}/OUTSIDER/TE_DETECTION/DEPTH_TE.csv | cut -f 3 || echo 0`
                elif [ "$ID_type" = "TrEMOLO" ]; then
                    echo -e "\\nTrEMOLO >> $ID:" >> {log}.err
                    grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv >> {log}.err || echo "ERROR : $ID" >> {log}.err

                    RS=`grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.bln | grep -w -F "$TE"  | cut -f 1 | sort -u | wc -l`
                    DEPTH=`samtools depth {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/MAPPING_POSTION_TE_MD.sorted.bam -r $chrom:$start-$end | awk '{{s+=$3;}} END{{print int(s/NR);}}' || echo "0"`
                elif [ "$ID_type" = "SOFT" ]; then
                    echo -e "\\nSOFT >> $ID:" >> {log}.err
                    grep -w "`echo $ID | sed 's/\.[RL]//g'`" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.bed >> {log}.err || echo "ERROR : $ID" >> {log}.err

                    ID_tmp=`echo $ID | sed 's/\.[RL]//g'`
                    RS=`grep -w "$ID_tmp" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.bed | cut -f 4 | cut -d ":" -f 2`
                    DEPTH=`samtools depth {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/MAPPING_POSTION_TE_MD.sorted.bam -r $chrom:$(($start-50))-$(($end+50)) | awk '{{s+=$3;}} END{{print int(s/NR);}}' || echo 0`
                elif [ "$ID_type" = "HARD" ]; then
                    echo -e "\\nHARD >> $ID:" >> {log}.err
                    grep -w "`echo $ID | sed 's/\.[RL]//g'`" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD.bln >> {log}.err || echo "ERROR : $ID" >> {log}.err

                    ID_tmp=`echo $ID | sed 's/\.[RL]//g'`                    
                    RS=`grep -w "$ID_tmp" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD.bln | grep -w "$TE" | cut -f 1 | sort -u | wc -l`
                    
                    echo "HARD = RS:$RS" >> {log}.err
                    
                    DEPTH=`samtools depth {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/MAPPING_POSTION_TE_MD.sorted.bam -r $chrom:$(($start-50))-$(($end+50)) | awk '{{s+=$3;}} END{{print int(s/NR);}}' || echo 0`
                    
                    echo "HARD = DEPTH:$DEPTH" >> {log}.err
                fi;
                echo "in..." >> {log}.err
            fi;

            echo "....." >> {log}.err

            if [ $DEPTH -eq 0 ]; then
                FREQ=0;
                echo "ERROR : DEPTH=0; ID=$ID;" >> {log}.err
            else
                echo "RS=$RS : NBD=$DEPTH : ID=$ID" >> {log}.err
                FREQ=`printf "%.6f" "$(((10**6 * $RS/$DEPTH) * 100))e-6"`;
                echo "VALIDATE FREQ=$FREQ : NBD=$DEPTH : ID=$ID" >> {log}.err
            fi;


            depth=`echo -e "$chrom\\t$start\\t$DEPTH"`

            if [ "$ID_type" = "sniffles" ] || [ "$ID_type" = "svim" ]; then
                TE=`grep -w "$ID" {params.work_directory}/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv | awk '{{print $1}}'`
                info_TE=`grep -w "$ID" {params.work_directory}/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv | awk 'OFS="\t"{{print $1, $2}}'`
            elif [ "$ID_type" = "TrEMOLO" ]; then
                TE=`grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv | awk '{{print $1}}'`
                info_TE=`grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv | awk 'OFS="\t"{{print $1, $2}}'`
            elif [ "$ID_type" = "SOFT" ]; then
                # ID=`echo $ID | sed 's/.[RL]//g'`
                TE=`grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/TE_SOFT.bed | cut -f 4 | cut -d "|" -f 1`
                info_TE=`( (grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.csv || grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT_TE_KEEP.csv || grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT_TE_KEEP_V2.csv ) | awk 'OFS="\t"{{print $1, $2}}' ) || depth="NONE"`
            elif [ "$ID_type" = "HARD" ]; then
                TE=`grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.bed | cut -f 4 | cut -d "|" -f 1`
                info_TE=`(grep -w "$ID" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.csv | awk 'OFS="\t"{{print $1, $2}}' ) || depth="NONE"`
            fi;
            echo "...TE:$TE;  info_TE:$info_TE;" >> {log}.err
            echo ".." >> {log}.err
            
            if [ -n "$depth" ] && [ "$depth" != "NONE" ]; then
                echo "DEPTH OK == $i : $info_TE : $depth : RS=$RS : DEPTH=$DEPTH" >> {log}.err
                printf "$depth\t$(($DEPTH-$RS))\t$RS\t%.4f\t$info_TE\\n" "$FREQ" | tr "," "." >> {output.depth_te}
            else
                depth=`echo -e "$chrom\\t$start\\t$DEPTH"`
                printf "$depth\t$(($DEPTH-$RS))\t$RS\t%.4f\t${{info_TE}}|ERROR\n" "0" | tr "," "." >> {output.depth_te}
                fail_msg "ERROR FOR ${{info_TE}} \\n ERROR GETTING DEPTH YOU NEED TO RECONSTRUCT YOUR BAM FILE\\n" | tee -a {log}.err;
            fi;

            echo "...." >> {log}.err
            
            i=$(($i+1));

            show_step="$i/$number_lines"
            number_of_char=`echo "$show_step" | wc -c`
            number_of_char=$(($number_of_char-1));
            printf "\b%.0s" `seq 1 $number_of_char`
            printf "$show_step";

        done < {input.outsider_bed};

        echo "FREQUENCY DONE ! ✔" | tee -a {log}.out

        ##
        rm -f {params.work_directory}/MAPPING_POSTION_TE.sam
        rm -f {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp*
        rm -f {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/TE_POSITION_SIZE.txt
        #rm -fr {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED
        rm -f `find {params.work_directory} -name "*.fai"`
        rm -f {params.work_directory}/TE_POS*
        """



#END FREQUENCE

rule FREQUENCEv2 :
    input:
        vcf           = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/VARIANT_CALLING/SV.vcf",
        fasta_TE      = config["DATA"]["TE_DB"],
        bam           = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/MAPPING/SAMPLE_mapping_GENOME_MD.sorted.bam",
        all_te        = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        genome        = config["DATA"]["GENOME"],
        bed_INS       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.bed",
        merge_TE_bed  = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed",
        outsider_bed  = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/POSITION_TE_OUTSIDER.bed",
        te_size       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/1-UTILS/TE_SIZE.tsv",
        input_link=[],

    output:
        output_link=[],
        depth_te  = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/FREQ_OPTIMIZED/FREQUENCY_TE_INS.tsv",
        # bam_TE    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/FREQ_OPTIMIZED/MAPPING_POSTION_TE_MD.sorted.bam",
        
    params:
        path_snk        = path_snk,
        work_directory  = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        threads        = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,

        preset_view    = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_VIEW"]["PRESET_OPTION"]) + " --threads " + str(config["PARAMS"]["THREADS"]),
        preset_sort    = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_SORT"]["PRESET_OPTION"]) + " --threads " + str(config["PARAMS"]["THREADS"]),
        preset_callmd  = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_CALLMD"]["PRESET_OPTION"]) + " --threads " + str(config["PARAMS"]["THREADS"]),

        pars_bln_option = config["PARAMS"]["OUTSIDER_VARIANT"]["PARS_BLN_OPTION"],

        env             = env, #source environnement

        call_sv         = config["CHOICE"]["OUTSIDER_VARIANT"]["CALL_SV"],

        CHROM_KEEP             = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["CHROM_KEEP"],
        GET_SEQ_REPORT_OPTION  = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["GET_SEQ_REPORT_OPTION"],


        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/FREQUENCEv2"

    shell:
        """
        {params.env}

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] OPTIMIZE FREQUENCE [^-^] {params.cend}"

        path_to_pipline=`dirname {params.path_snk}`

        mkdir -p {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED

        rm -f {log}.out {log}.err
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        ##FILTER_BLAST
        ###no header
        ###sniffles
        awk 'NR>1' {params.work_directory}/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv > {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_FILTER_BLAST_sniffles.csv 
        
        ###SOFT
        touch {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_FILTER_BLAST_SOFT.csv;
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.csv && \
            awk 'NR>1' {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.csv > {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_FILTER_BLAST_SOFT.csv

        ###HARD
        touch {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_FILTER_BLAST_HARD.csv;
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.csv && \
            awk 'NR>1' {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.csv > {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_FILTER_BLAST_HARD.csv

        cat {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv \
            {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_FILTER_BLAST_sniffles.csv \
            {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_FILTER_BLAST_SOFT.csv \
            {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_FILTER_BLAST_HARD.csv > {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/FILTER_BLAST_INS.csv

        ##SORT
        awk 'NR>1 && OFS="\t" {{split($2, sp, ":"); print sp[1], sp[3], sp[4]+1, $0}}' \
            {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/FILTER_BLAST_INS.csv | bedtools sort | cut -f 4- \
                > {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_FILTER_BLAST_INS.sorted.csv

        head -n 1 {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/FILTER_BLAST_INS.csv > {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_head.csv
        cat {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_head.csv \
            {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_FILTER_BLAST_INS.sorted.csv \
                > {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/FILTER_BLAST_INS.sorted.csv

        ####
        ##GET SV SIZE
        echo "  GET SV SIZE..." | tee -a {log}.out
        
        ###SV SEQ sniffles
        test -s {params.work_directory}/OUTSIDER/VARIANT_CALLING/SEQUENCE_INDEL.fasta && \
            awk ' /^>/ {{ head=substr($0, 2, length($0)); }} 
                /^[^>]/ && OFS="\t"{{ print head, length($0) }}' \
                {params.work_directory}/OUTSIDER/VARIANT_CALLING/SEQUENCE_INDEL.fasta \
                    > {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/SV_SIZE.tsv
        
        ###SV SEQ TrEMOLO
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.fasta && \
            awk ' /^>/ {{ head=substr($0, 2, length($0)); }} 
                /^[^>]/ && OFS="\t"{{ print head, length($0) }}' \
                {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.fasta \
                    >> {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/SV_SIZE.tsv

        ###SV SEQ SOFT
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.fasta && \
            awk ' /^>/ {{ head=substr($0, 2, length($0)); }} 
                /^[^>]/ && OFS="\t"{{ print head, length($0) }}' \
                {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.fasta \
                    >> {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/SV_SIZE.tsv

        ###SV SEQ HARD
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD.fasta && \
            awk ' /^>/ {{ head=substr($0, 2, length($0)); }} 
                /^[^>]/ && OFS="\t"{{ print head, length($0) }}' \
                {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD.fasta \
                    >> {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/SV_SIZE.tsv

        echo "  GET SV SIZE ✔" | tee -a {log}.out


        touch {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_POSITION_START_TE.bed
        awk -v window="50" 'NR>1 && OFS="\t" {{ split($2, sp, ":"); print sp[1], (sp[3]-window > 0 ? sp[3]-window : 1), sp[4]+window }}' {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/FILTER_BLAST_INS.sorted.csv \
            | bedtools merge -d 1 \
            > {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_POSITION_START_TE.bed

        samtools view {params.preset_view} -q 10 -F 4 -h -b {input.bam} -L {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp_POSITION_START_TE.bed > {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/MAPPING_POSTION_TE.bam
        samtools index {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/MAPPING_POSTION_TE.bam
        
        echo "GET BAM TE OUTSIDER ✔" | tee -a {log}.out 

        ##COUNT READS
        echo "  COUNT READS..." | tee -a {log}.out

        sizePercent=`echo "{params.pars_bln_option}" | grep -E 'min-size-percent [0-9]+' -o | awk '$2-10>5{{ print $2-10; }} $2-10<5{{ print 5; }}'`;
        
        
        echo "  BUILD CHUNKS..." | tee -a {log}.out
        python3 ${{path_to_pipline}}/lib/python/format_files/divideToChunks.py \
            {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/FILTER_BLAST_INS.sorted.csv \
            {params.threads} \
            {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/CHUNKS
        
        coutReadsFreq () {{
            echo "    CHUNK N=$1 -->" | tee -a {log}.out
            python3 ${{path_to_pipline}}/lib/python/parsing/getFrequency.py -p ${{sizePercent}} \
                {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/MAPPING_POSTION_TE.bam \
                {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/CHUNKS/tmp_chunk_${{1}}.csv \
                {params.work_directory}/1-UTILS/TE_SIZE.tsv \
                {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/SV_SIZE.tsv \
                {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/COUNT_READS_${{1}}.txt 2>> {log}.err \
                    || (fail_msg "...COUNT READS ✘" | tee -a {log}.out && exit 1)
        }}

        

        ###RUN PARLELIZE
        NB_FILE=`ls {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/CHUNKS/ | wc -l` ;
        i=0 ;

        #PARLELIZE
        count_task_running=0;
        pids=();
        for chunk in `ls {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/CHUNKS/`; do
            echo "  CHUNK : $chunk"
            
            coutReadsFreq $(($count_task_running+1)) &
            pids[${{count_task_running}}]=$!;
            count_task_running=$(($count_task_running+1));

            if [ $count_task_running -ge {params.threads} ]; then
                c=1;
                for pid in ${{pids[*]}}; do
                    wait $pid || echo > /dev/null;
                    c=$(($c+1));
                done;
                pids=();
                count_task_running=0;
            fi;

            i=$(($i + 1)) ;
            printf "%s\\n" "{params.cmess} [SNK]--[`date`] [CHUNK:snk] : $i/$NB_FILE {params.cend}"
        done;

        #WAIT LAST TASKS
        if [ $count_task_running -lt {params.threads} ]; then
            pids[${{count_task_running}}]=$!
            task=1;
            for pid in ${{pids[*]}}; do
                wait $pid || echo > /dev/null;
                task=$(($task+1));
            done;
        fi;

        ##MERGE COUNT_READS
        echo "  MERGE CHUNKS COUNT READS..." | tee -a {log}.out
        cat {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/COUNT_READS_*.txt | sort -k 3 \
            > {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/COUNT_READS.txt;

        echo "  COUNT READS ✔" | tee -a {log}.out


        ##GET FREQUENCY
        echo "  GET FREQUENCY..." | tee -a {log}.out
        awk '{{ print $3":"$2":"$1, $0 }}' {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/COUNT_READS.txt | \
        sort | cut -d " " -f 2- | \
        awk '
            ID!=$3 && NR>1 && OFS="\t" {{ 
                if(svType=="INS"){{
                    if(I<_RS) I=_RS; 
                    if(substr(ID, 1, 8) == "sniffles" && I_Only<_RS){{ 
                        I_Only=_RS;
                    }}
                    if(total<I || total==0) total=I;
                    if(total-I_clipped < I_Only || total-I_clipped==0) total_no_clipped=total; else total_no_clipped=(total-I_clipped);
                    print position, ID, TE, I_Only, I_clipped, total_no_clipped, I, total, (I_Only/total_no_clipped)*100, (I/total)*100, svType;
                }}
                else if(svType=="DEL") {{
                    if(D<_RS) D=_RS;
                    if(total<D || total==0) total=D;
                    print position, ID, TE, D, ".", total, (total-D), total, ((total-D)/total)*100, ((total-D)/total)*100, svType;
                }}
            }}

            ID!=$3 {{ total=0; D=0; I=0; I_Only=0; I_clipped=0; svType=$17; _RS=$5; ID=$3; TE=$4; position=$10; current_read=""; }}  
            
            $1!="E" && current_read!=$2 {{ 
                if(svType=="INS")
                    I+=1;

                if(svType=="DEL")
                    D+=1;

                current_read=$2;
                total+=1; 

                if($1=="S" || $1=="H"){{
                    I_clipped+=1;
                }}
                else if($1=="I"){{
                    I_Only+=1;
                }}
            }}

            ($1=="E" && current_read!=$2) {{ total+=1; current_read=$2;}}
            
            END {{ 
                if(svType=="INS"){{
                    if(I<_RS) I=_RS; 
                    if(substr(ID, 1, 8) == "sniffles" && I_Only<_RS){{ 
                        I_Only=_RS;
                    }}
                    if(total<I || total==0) total=I;
                    if(total-I_clipped < I_Only || total-I_clipped==0) total_no_clipped=total; else total_no_clipped=(total-I_clipped);
                    print position, ID, TE, I_Only, I_clipped, total_no_clipped, I, total, (I_Only/total_no_clipped)*100, (I/total)*100, svType;
                }}
                else if(svType=="DEL") {{
                    if(D<_RS) D=_RS;
                    if(total<D || total==0) total=D;
                    print position, ID, TE, D, ".", total, (total-D), total, ((total-D)/total)*100, ((total-D)/total)*100, svType;
                }}
            }}' \
                > {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/FREQUENCY_TE_INS.tsv \
                    || (fail_msg "...GET FREQUENCY ✘" | tee -a {log}.out && exit 1)

        echo "  GET FREQUENCY ✔" | tee -a {log}.out

        echo "FREQUENCY DONE ! ✔" | tee -a {log}.out

        ##
        rm -f {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED/tmp*
        #rm -fr {params.work_directory}/OUTSIDER/FREQ_OPTIMIZED
        rm -f `find {params.work_directory} -name "*.fai"`
        """



#END FREQUENCEv2


rule FREQ_INSIDER:
    input:
        merge_TE_bed = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed",
        TE_INS       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/TE_DETECTION/INSERTION.csv",
        bam          = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/MAPPING/SAMPLE_mapping_GENOME_MD.sorted.bam",

    output:
        DEPTH = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/FREQ_INSIDER/DEPTH_TE_INSIDER.csv",
        tmp   = output_link=[],

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env,

        preset_view    = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_VIEW"]["PRESET_OPTION"]) + " --threads " + str(config["PARAMS"]["THREADS"]),
        preset_sort    = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_SORT"]["PRESET_OPTION"]) + " --threads " + str(config["PARAMS"]["THREADS"]),
        preset_callmd  = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_CALLMD"]["PRESET_OPTION"]) + " --threads " + str(config["PARAMS"]["THREADS"]),

        
        #COLOR 
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/FREQ_INSIDER",

    shell:
        """

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] INSIDER FREQUENCY {params.cend}"

        {params.env}
        path_to_pipline=`dirname {params.path_snk}`
        
        mkdir -p {params.work_directory}/OUTSIDER/MAPPING_TO_REF/

        rm -f {log}.out {log}.err
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        ###TEST DEBUG
        #####test INSIDER EMPTY
        ###printf "" > {input.TE_INS}

        test -s {input.TE_INS} || warn_msg "WARNING : NO TE INSIDER\\n" | tee -a {log}.err;

        touch {params.work_directory}/OUTSIDER/MAPPING_TO_REF/FLANK_TE.bed
        test -s {input.TE_INS} && \
            cat {input.TE_INS} | cut -f 2 | \
                awk -v margin_flank="100" -F ":" 'OFS="\t"{{split($6, a, "-"); print $5, a[1]-margin_flank, a[1]-margin_flank+1; print $5, a[2]+margin_flank, a[2]+margin_flank+1}}' > {params.work_directory}/OUTSIDER/MAPPING_TO_REF/FLANK_TE.bed

        echo "GET FLANK TE ✔" | tee -a {log}.out

        #DROP CLIPPED
        touch {params.work_directory}/OUTSIDER/MAPPING_TO_REF/FLANK_TE_IN.bed
        test -s {input.TE_INS} && \
            cat {input.TE_INS} | cut -f 2 | \
                awk -v margin_flank="5" -F ":" 'OFS="\t"{{split($6, a, "-"); print $5, a[1]+margin_flank, a[1]+margin_flank+1; print $5, a[2]-margin_flank, a[2]-margin_flank+1}}' > {params.work_directory}/OUTSIDER/MAPPING_TO_REF/FLANK_TE_IN.bed

        echo "DROP CLIPPED ✔" | tee -a {log}.out

        FLAG_EXLUDE=`(echo {params.preset_view} | grep -E "\-F [0-9]+" > /dev/null && echo "") || echo "-F 2048"`

        samtools view {params.preset_view} -h -b {input.bam} $FLAG_EXLUDE -L {params.work_directory}/OUTSIDER/MAPPING_TO_REF/FLANK_TE.bed > {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp_flank_TE_OUT.bam
        samtools index {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp_flank_TE_OUT.bam

        echo "BAM GET FLANK TE ✔" | tee -a {log}.out

        #BAM DROP CLIPPED
        samtools view {params.preset_view} -h -b {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp_flank_TE_OUT.bam \
            $FLAG_EXLUDE -L {params.work_directory}/OUTSIDER/MAPPING_TO_REF/FLANK_TE_IN.bed > {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp2_flank_TE_OUT.bam

        echo "BAM DROP CLIPPED ✔" | tee -a {log}.out
        
        mv {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp2_flank_TE_OUT.bam {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp_flank_TE_OUT.bam
        rm -f {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp_flank_TE_OUT.bam.bai
        samtools index {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp_flank_TE_OUT.bam

        touch {params.work_directory}/OUTSIDER/MAPPING_TO_REF/INSERTION_TE.bed
        test -s {input.TE_INS} && \
            awk 'NR>1 && OFS="\t"{{split($2, a, ":"); split(a[6], b, "-"); print a[5], b[1], b[2], $1"|"a[1]}}' \
                {input.TE_INS} > {params.work_directory}/OUTSIDER/MAPPING_TO_REF/INSERTION_TE.bed

        echo "CSV to BED ✔" >> {log}.out

        printf "chrom\tposition\ttotal_depth\tdepth_empty_site\tread_support\tread_support_percent\tTE\tinfo_TE\\n" > {output.DEPTH}
        
        number_lines=`cat {params.work_directory}/OUTSIDER/MAPPING_TO_REF/INSERTION_TE.bed | wc -l`
        i=0;

        show_step="$i/$number_lines TE"
        number_of_char=`echo "$show_step" | wc -c`
        number_of_char=$(($number_of_char-1));
        printf "\b%.0s" `seq 1 $number_of_char`
        printf "$show_step";

        while read line; do
            read -r chrom start end info TE <<< $(echo $line | awk 'OFS="\t"{{split($4, TE, "|"); print $1, $2, $3, $4, TE[1]}}')

            size_TE=$(($end-$start))

            if test -s {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp_flank_TE_OUT.bam; then
                NB_DEL=`python3 ${{path_to_pipline}}/lib/python/parsing/find_del.py {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp_flank_TE_OUT.bam "$chrom:$start-$end" -m 30`
                
                depth_fk_left=`samtools depth {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp_flank_TE_OUT.bam -r $chrom:$(($start-30))-$(($start-30)) | cut -f 3`;
                depth_fk_right=`samtools depth {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp_flank_TE_OUT.bam -r $chrom:$(($end+30))-$(($end+30)) | cut -f 3`;

                if [ -n "$depth_fk_left" ] && [ -n "$depth_fk_right" ] ; then

                    depth_total_mean=$((($depth_fk_left+$depth_fk_right)/2));

                    if [ $depth_total_mean -ne 0 ]; then
                        NB_TE=$(($depth_total_mean-$NB_DEL))

                        if [ -n "$depth_total_mean" ]; then
                            printf "$chrom\t$start\t$depth_total_mean\t$NB_DEL\t$NB_TE\t%.4f\t$TE\t$info\\n" "$(((10**6 * $NB_TE/$depth_total_mean) * 100))e-6" | tr "," "." >> {output.DEPTH}
                        else
                            printf "$chrom\t$start\t-1\t$NB_DEL\t-1\t%.4f\t$TE\tinfo|ERROR\\n" "0" | tr "," "." >> {output.DEPTH}
                            fail_msg "ERROR FOR ${{info}} \\n ERROR GETTING DEPTH YOU NEED TO RECONSTRUCT YOUR BAM FILE\\n";
                        fi;
                    else
                        printf "$chrom\t$start\t0\t0\t0\t%.4f\t$TE\t$info\\n" "0" | tr "," "." >> {output.DEPTH}
                    fi;
                else
                    printf "$chrom\t$start\t0\t0\t0\t%.4f\t$TE\t$info\\n" "0" | tr "," "." >> {output.DEPTH}
                fi;
            else
                 printf "$chrom\t$start\t0\t0\t0\t%.4f\t$TE\t$info\\n" "0" | tr "," "." >> {output.DEPTH}
            fi;
            i=$(($i+1));

            show_step="$i/$number_lines TE"
            number_of_char=`echo "$show_step" | wc -c`
            number_of_char=$(($number_of_char-1));
            printf "\b%.0s" `seq 1 $number_of_char`
            printf "$show_step";

        done < {params.work_directory}/OUTSIDER/MAPPING_TO_REF/INSERTION_TE.bed;
        echo

        rm -f {params.work_directory}/OUTSIDER/MAPPING_TO_REF/tmp*
        rm -f {params.work_directory}/OUTSIDER/MAPPING_TO_REF/FLANK_TE*
        rm -f `find {params.work_directory} -name "*.fai"`
        """


#END FREQ_INSIDER


rule MERGE_TE :
    input:
        all_te           = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        soft_te          = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.bed",
        hard_te          = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.bed",
        TrEMOLO_TE_bed   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.bed",
        sniffles_TE_bed  = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/POSITION_START_TE.bed",

    output:
        merge_TE_bed = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed",
        outsider_bed = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/POSITION_TE_OUTSIDER.bed",
        tmp = output_link=[],

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        call_sv                = config["CHOICE"]["OUTSIDER_VARIANT"]["CALL_SV"],
        CHROM_KEEP             = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["CHROM_KEEP"],
        GET_SEQ_REPORT_OPTION  = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["GET_SEQ_REPORT_OPTION"],
        threads                = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,


        #COLORS
        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

        step=0,

    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/MERGE_TE"


    shell:
        """
        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] MERGE TE [^-^] {params.cend}"

        mkdir -p {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE

        rm -f {log}.out {log}.err
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt


        chrom_keep=`echo "{params.CHROM_KEEP}" | tr "," "|"`

        echo "CHROM KEEP : $chrom_keep;" | tee {log}.out;


        ###TEST DEBUG
        #####test sniffles EMPTY
        ##printf "" > {input.sniffles_TE_bed}
        #####test TrEMOLO EMPTY
        ##printf "" > {input.TrEMOLO_TE_bed}
        #####test SOFT EMPTY
        ##printf "" > {input.soft_te}
        #####test HARD EMPTY
        ##printf "" > {input.hard_te}

        
        test -s {input.sniffles_TE_bed} && \
            echo {input.sniffles_TE_bed} | tee  -a {log}.out || warn_msg "WARNING : NO TE sniffles\\n" | tee -a {log}.err;
        test -s {input.TrEMOLO_TE_bed} && \
            echo {input.TrEMOLO_TE_bed} | tee  -a {log}.out || warn_msg "WARNING : NO TE TrEMOLO\\n" | tee -a {log}.err;
        test -s {input.soft_te} && \
            echo {input.soft_te} | tee  -a {log}.out || warn_msg "WARNING : NO TE SOFT\\n" | tee -a {log}.err;
        test -s {input.hard_te} && \
            echo {input.hard_te} | tee  -a {log}.out || warn_msg "WARNING : NO TE HARD\\n" | tee -a {log}.err;

        ## MERGE TE sniffles and TrEMOLO window 100pb
        ##clusterise window 100nt
        touch {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_POSITION_TE_OUTSIDER_CLUSTER_100.bed;
        test -s {input.sniffles_TE_bed} && \
            bedtools sort -i {input.sniffles_TE_bed} | grep -E "$chrom_keep" | bedtools cluster -d 100 | awk 'BEGIN{{TE=""; num=""}} {{split($4, sp, "|"); if(num==$7 && sp[1]==TE){{TE=sp[1]; num=$7;}}else{{print $0; TE=sp[1]; num=$7;}} }}' | cut -f 1-6 \
                > {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_POSITION_TE_OUTSIDER_CLUSTER_100.bed
        
        echo "CLUSTERING sniffles passing ✔" >> {log}.out

        touch {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TrEMOLO_TE_OUTSIDER_CLUSTER_100.bed;
        test -s {input.TrEMOLO_TE_bed} && \
            bedtools sort -i {input.TrEMOLO_TE_bed} | grep -E "$chrom_keep" | bedtools cluster -d 100 | awk 'BEGIN{{TE=""; num=""}} {{split($4, sp, "|"); if(num==$7 && sp[1]==TE){{TE=sp[1]; num=$7;}}else{{print $0; TE=sp[1]; num=$7;}} }}' | cut -f 1-6 \
                > {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TrEMOLO_TE_OUTSIDER_CLUSTER_100.bed

        
        echo "CLUSTERING TrEMOLO passing ✔" >> {log}.out

        #Get ID Tr/sniffles intersect
        echo "MERGE Tr and svim/sniffles..." | tee -a {log}.out;
        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TrEMOLO_TE_OUTSIDER_CLUSTER_100.bed && \
            test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_POSITION_TE_OUTSIDER_CLUSTER_100.bed && \
            bedtools window -a {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TrEMOLO_TE_OUTSIDER_CLUSTER_100.bed -b {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_POSITION_TE_OUTSIDER_CLUSTER_100.bed -w 100 | \
                awk '{{split($4, sp1, "|");  split($10, sp2, "|"); if(sp1[1] == sp2[1]){{ print $4 }} }}' | sort -u > {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_ID_TrEMOLO.txt

        ###if no intersect get all ID Tr
        touch {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_ID_TrEMOLO.txt;

        echo "INTERSECT TrEMOLO vs sniffles passing ✔" >> {log}.out

        #show NB
        echo -e "BEFORE CLUSTERING" | tee -a {log}.out
        NB_TE_sn=`test -s {params.work_directory}/OUTSIDER/TE_DETECTION/POSITION_START_TE.bed && grep -E "$chrom_keep" {params.work_directory}/OUTSIDER/TE_DETECTION/POSITION_START_TE.bed -c || echo 0`        
        NB_TE_Tr=`test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.bed && grep -E "$chrom_keep" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.bed -c || echo 0`

        echo "      NB sniffles : $NB_TE_sn" | tee -a {log}.out;
        echo "      NB TrEMOLO  : $NB_TE_Tr" | tee -a {log}.out;

        echo -e "\\nAFTER CLUSTERING WINDOW 100" | tee -a {log}.out
        NB_TE_Tr=`test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TrEMOLO_TE_OUTSIDER_CLUSTER_100.bed && grep -E "$chrom_keep" {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TrEMOLO_TE_OUTSIDER_CLUSTER_100.bed -c || echo 0`        
        NB_TE_sn=`test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_POSITION_TE_OUTSIDER_CLUSTER_100.bed && grep -E "$chrom_keep" {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_POSITION_TE_OUTSIDER_CLUSTER_100.bed -c || echo 0`
        NB_intersect=`cat {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_ID_TrEMOLO.txt | wc -l`

        echo "      NB sniffles : $NB_TE_sn" | tee -a {log}.out;
        echo "      NB TrEMOLO  : $NB_TE_Tr" | tee -a {log}.out;
        echo "      NB TrEMOLO IN sniffles : $NB_intersect" | tee -a {log}.out;

        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TrEMOLO_TE_OUTSIDER_CLUSTER_100.bed && \
            grep -w -v -f {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_ID_TrEMOLO.txt {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TrEMOLO_TE_OUTSIDER_CLUSTER_100.bed > {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TE_TrEMOLO_NOT_FOUND_IN_sniffles.bed || \
                touch {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TE_TrEMOLO_NOT_FOUND_IN_sniffles.bed

        echo "TrEMOLO NOT FOUND IN sniffles passing ✔" >> {log}.out

        #SOFT
        echo "   SOFT..." | tee -a {log}.out;
        touch {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_SOFT_CLUSTER_100.bed
        test -s {input.soft_te} && \
            bedtools sort -i {input.soft_te} | grep -E "$chrom_keep" | bedtools cluster -d 100 | awk 'BEGIN{{TE=""; num=""}} {{split($4, sp, "|"); if(num==$7 && sp[1]==TE){{TE=sp[1]; num=$7;}}else{{print $0; TE=sp[1]; num=$7;}} }}' | cut -f 1-6 > {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_SOFT_CLUSTER_100.bed

        echo "      NB TE SOFT : `grep -E "$chrom_keep" {input.soft_te} | wc -l`" | tee -a {log}.out;
        echo "      NB TE SOFT CLUSTERED (-w 100) : `cat {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_SOFT_CLUSTER_100.bed | wc -l`" | tee {log}.out;

        ##Commun SOFT vs sniffles
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.bed && \
            test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_POSITION_TE_OUTSIDER_CLUSTER_100.bed && \
            bedtools window -a {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_SOFT_CLUSTER_100.bed -b {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_POSITION_TE_OUTSIDER_CLUSTER_100.bed -w 100 | awk '{{split($4, sp1, "|");  split($10, sp2, "|"); if(sp1[1] == sp2[1]){{ print $0 }} }}' | cut -f 4 | sort -u > {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_ID_SOFT_commun.txt
        
        echo "Commun SOFT vs sniffles passing ✔" >> {log}.out

        ##Commun SOFT vs TrEMOLO
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.bed && \
            test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TrEMOLO_TE_OUTSIDER_CLUSTER_100.bed && \
            bedtools window -a {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_SOFT_CLUSTER_100.bed -b {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TrEMOLO_TE_OUTSIDER_CLUSTER_100.bed -w 100 | awk '{{split($4, sp1, "|");  split($10, sp2, "|"); if(sp1[1] == sp2[1]){{ print $0 }} }}' | cut -f 4 | sort -u >> {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_ID_SOFT_commun.txt

        echo "Commun SOFT vs TrEMOLO passing ✔" >> {log}.out

        ##Get SOFT not found in sniffles and TrEMOLO
        touch {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TE_SOFT_NOT_FOUND_IN_sniffles_and_TrEMOLO.bed
        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_SOFT_CLUSTER_100.bed && \
            grep -w -v -f {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_ID_SOFT_commun.txt {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_SOFT_CLUSTER_100.bed > {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TE_SOFT_NOT_FOUND_IN_sniffles_and_TrEMOLO.bed

        echo "SOFT NOT in sniffles and TrEMOLO passing ✔" >> {log}.out

        ##HARD
        ###CLUSTERING
        touch {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_HARD_CLUSTER_100.bed
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.bed && \
            bedtools sort -i {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.bed | grep -E "$chrom_keep" | bedtools cluster -d 100 | awk 'BEGIN{{TE=""; num=""}} {{split($4, sp, "|"); if(num==$7 && sp[1]==TE){{TE=sp[1]; num=$7;}}else{{print $0; TE=sp[1]; num=$7;}} }}' | cut -f 1-6 > {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_HARD_CLUSTER_100.bed

        echo "   HARD..." | tee -a {log}.out;
        echo "      NB TE HARD ; `grep -E "$chrom_keep" {input.hard_te} -c`" | tee -a {log}.out
        echo "      NB TE HARD CLUSTERED (-w 100) ; `grep -E "$chrom_keep" {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_HARD_CLUSTER_100.bed -c`" | tee -a {log}.out

        ##COMMUN
        ##HARD vs sniffles
        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_HARD_CLUSTER_100.bed && \
            test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_POSITION_TE_OUTSIDER_CLUSTER_100.bed && \
            bedtools window -a {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_HARD_CLUSTER_100.bed -b {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_POSITION_TE_OUTSIDER_CLUSTER_100.bed -w 100 | awk '{{split($4, sp1, "|");  split($10, sp2, "|"); if(sp1[1] == sp2[1]){{ print $0 }} }}' | cut -f 4 | sort -u > {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_ID_HARD_commun.txt
        
        echo "Commun HARD vs sniffles passing ✔" >> {log}.out

        ##HARD vs TrEMOLO
        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_HARD_CLUSTER_100.bed && \
            test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TrEMOLO_TE_OUTSIDER_CLUSTER_100.bed && \
            bedtools window -a {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_HARD_CLUSTER_100.bed -b {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TrEMOLO_TE_OUTSIDER_CLUSTER_100.bed -w 100 | awk '{{split($4, sp1, "|");  split($10, sp2, "|"); if(sp1[1] == sp2[1]){{ print $0 }} }}' | cut -f 4 | sort -u >> {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_ID_HARD_commun.txt
        
        echo "Commun HARD vs TrEMOLO passing ✔" >> {log}.out

        ##HARD vs SOFT
        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_HARD_CLUSTER_100.bed && \
            test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_SOFT_CLUSTER_100.bed && \
            bedtools window -a {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_HARD_CLUSTER_100.bed -b {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_SOFT_CLUSTER_100.bed -w 100 | awk '{{split($4, sp1, "|");  split($10, sp2, "|"); if(sp1[1] == sp2[1]){{ print $0 }} }}' | cut -f 4 | sort -u >> {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_ID_HARD_commun.txt

        echo "Commun HARD vs SOFT passing ✔" >> {log}.out

        ##GET HARD not found in SOFT, sniffles, TrEMOLO
        touch {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_ID_HARD_commun.txt #if not exist
        touch {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TE_HARD_NOT_FOUND_IN_SOFT_sniffles_and_TrEMOLO.bed
        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_HARD_CLUSTER_100.bed && \
            grep -w -v -f {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_ID_HARD_commun.txt {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_HARD_CLUSTER_100.bed | grep -E "$chrom_keep" > {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TE_HARD_NOT_FOUND_IN_SOFT_sniffles_and_TrEMOLO.bed

        echo "   MERGE..." | tee -a {log}.out;

        rm -f {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed
        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_POSITION_TE_OUTSIDER_CLUSTER_100.bed && cat {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_POSITION_TE_OUTSIDER_CLUSTER_100.bed | grep -E "$chrom_keep" >> {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed
        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TE_TrEMOLO_NOT_FOUND_IN_sniffles.bed && cat {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TE_TrEMOLO_NOT_FOUND_IN_sniffles.bed | grep -E "$chrom_keep" >> {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed
        
        # test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_MERGE_TE_ALL.bed \
        #     && bedtools sort -i {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_MERGE_TE_ALL.bed \
        #     | bedtools cluster -d 100 | \
        #     awk '{{ split($4, sp, "|"); split(sp[2], sp_id, "."); print $0":"sp[1]":"sp_id[2]}}' | bedtools groupby -g 7 -c 1,2,3,4,5,6 -o first,first,first,first,first,first | cut -f 2- \
        #         > {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed
        
        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TE_SOFT_NOT_FOUND_IN_sniffles_and_TrEMOLO.bed && cat {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TE_SOFT_NOT_FOUND_IN_sniffles_and_TrEMOLO.bed | grep -E "$chrom_keep" >> {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed
        test -s {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TE_HARD_NOT_FOUND_IN_SOFT_sniffles_and_TrEMOLO.bed && cat {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/tmp_TE_HARD_NOT_FOUND_IN_SOFT_sniffles_and_TrEMOLO.bed | grep -E "$chrom_keep" >> {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed

        
        echo "      NB TE sniffles    : `grep "sniffles" {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed -c`" | tee -a {log}.out
        echo "      NB TE TrEMOLO INS : `grep "TrEMOLO.INS" {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed -c`" | tee -a {log}.out
        echo "      NB TE SOFT        : `grep "SOFT" {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed -c`" | tee -a {log}.out
        echo "      NB TE HARD        : `grep "HARD" {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed -c`" | tee -a {log}.out
        echo "   NB TE MERGED : "`cat {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed | wc -l` | tee -a {log}.out;
        cp {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL2.bed
        cut -f 4 {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed | cut -d "|" -f 1 | sort | uniq -c | awk 'OFS="\t"{{print $1, $2}}' | sort -k 1 -n | awk 'BEGIN{{print "x\ty\tz"}} OFS="\t"{{print "", $2, $1}}' > {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL_COUNT.csv
        
        rm -f {params.work_directory}/POSITION_TE_OUTSIDER.bed
        ln -srf {params.work_directory}/OUTSIDER/TE_DETECTION/MERGE_TE/MERGE_TE_ALL.bed {params.work_directory}/POSITION_TE_OUTSIDER.bed

        """


#END MERGE_TE




#
rule HARD_TE :
    input:
        read           = config["DATA"]["SAMPLE"],
        all_te         = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        fasta_TE       = config["DATA"]["TE_DB"],
        bam            = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/MAPPING/SAMPLE_mapping_GENOME_MD.sorted.bam",
        SOFT_all_te    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.csv",
        tr_vcf         = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/HARD/SV_HARD.tr_vcf",
    output:
        all_te    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.csv",
        bln       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD.bln",
        seqs      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD.fasta",
        
        bed       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.bed",

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        pars_bln_option        = config["PARAMS"]["OUTSIDER_VARIANT"]["PARS_BLN_OPTION"],
        call_sv                = config["CHOICE"]["OUTSIDER_VARIANT"]["CALL_SV"],
        CHROM_KEEP             = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["CHROM_KEEP"],
        GET_SEQ_REPORT_OPTION  = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["GET_SEQ_REPORT_OPTION"],
        threads                = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,


        #COLORS
        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

        step=0,

    log:
        hard = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/HARD"


    shell:
        """
        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] DETECTION TE IN HARD READS [^-^] {params.cend}"

        mkdir -p {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD

        rm -f {log}.out {log}.err
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        ## CREATE VCF HARD
        echo "CREATE VCF HARD..."
        ###python3 ${{path_to_pipline}}/lib/python/parsing/find_hard.py {input.bam} > {input.tr_vcf};
        awk 'NR>1 {{print $5}}' {input.tr_vcf} | sort -u > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/ID.txt

        ## GET SEQUENCE HARD
        echo "GET SEQUENCE HARD...";

        #if [ ! -n "$TrEMOLO_SIZE_MAX_TE" ]; then
            TrEMOLO_SIZE_MAX_TE=`awk '{{ if(substr($0, 1, 1) != ">"){{ if( length($0)>max ){{ max=length($0) }} }} }} END{{print max}}' {input.fasta_TE}`
            TrEMOLO_SIZE_MAX_TE=$((TrEMOLO_SIZE_MAX_TE + 100));
        #fi;

        PATH=`echo $PATH | sed "s|${{SAMTOOLS_1_9}}|${{SAMTOOLS_1_15_1}}|g"`
        
        test -s {input.read}.fai || samtools fqidx {input.read} 2>> {log.hard}
        samtools fqidx {input.read} --fai-idx {input.read}.fai -r {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/ID.txt > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/RS_HARD.fastq
        
        python3 ${{path_to_pipline}}/lib/python/format_files/fastq_to_fasta.py {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/RS_HARD.fastq {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/RS_HARD.fasta

        grep -n ">" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/RS_HARD.fasta | tr -d ">" > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/RS_HARD.fasta.fa_trml_idx

        python3 ${{path_to_pipline}}/lib/python/parsing/get_seq_hard.py -s "$TrEMOLO_SIZE_MAX_TE" {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/RS_HARD.fasta.fa_trml_idx {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/RS_HARD.fasta {input.tr_vcf} > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD.bed

        ## Warning : WINDOW cluster fixed 100
        ## Warning : tab_head[1] for take start end first detected
        bedtools sort -i {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD.bed | bedtools cluster -d 100 | awk 'BEGIN{{count=0; id="";}}  OFS=":"{{if(id != $8){{ if(NR>1){{ for(i=1; i<count+1; i++){{print tab_head[1], count, "IMPRECISE", (i-1); print tab_seq[i]}} }}; id=$8; count=0; delete tab_head; delete tab_seq;}}else{{tab_head[count+1] = ">"$1":<HARD>:"$2":"$3":HARD."id"."$6; tab_seq[count+1] = $5; count+=1}} }}' > {output.seqs}

        ## BLAST TE
        echo "BLAST TE HARD..."
        makeblastdb -in {input.fasta_TE} -dbtype nucl 2> {log.hard}.err;
        test -s {output.seqs} && \
            blastn -num_threads {params.threads} -db {input.fasta_TE} -query {output.seqs} -outfmt 6 -out {output.bln} 2>> {log.hard}.err;

        ## PARSING
        test -s {output.bln} && \
            python3 ${{path_to_pipline}}/lib/python/parsing/parse_blast_main.py \
                {output.bln} \
                {input.fasta_TE} \
                {output.all_te} \
                --combine_name {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/COMBINE_SV_HARD.csv -c -k "HARD" {params.pars_bln_option}

        test -s {output.all_te} && \
            awk 'NR>1 {{print $2":"$1":"$5}}' {output.all_te} | awk -F ":" 'OFS="\t"{{print $1, $3, $4, $10"|"$5, $11, $9}}' > {output.bed}

        ###TEST NO HARD
        ##rm -f {output.all_te} {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/*.bed

        ## NO TE HARD FOUND
        if ! test -s {input.tr_vcf} || ! test -s {output.all_te} || ! test -s {output.bln} || ! test -s {output.seqs}; then
            warn_msg "[SNK--WARNING] NO TE HARD FOUND";
            touch {input.tr_vcf}
            touch {output.all_te}
            touch {output.bln}
            touch {output.seqs}
        fi;

        ##PATH=`echo $PATH | sed "s|${{SAMTOOLS_1_15_1}}|${{SAMTOOLS_1_9}}|g"`

        #** REMOVE **#
        #rm -f {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/ID*;
        #rm -f {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/SV_SOFT_TE_KEEP*;
        rm -f `find {params.work_directory} -name "*.fai"`
        """


#END HARD_TE



#
rule SOFT_TE :
    input:
        all_te   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        fasta_TE = config["DATA"]["TE_DB"],
        bam      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/MAPPING/SAMPLE_mapping_GENOME_MD.sorted.bam",
        vcf       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.vcf",
    output:
        all_te    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.csv",
        bln       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.bln",
        seqs      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.fasta",
        
        bed       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.bed",
        sv_bed    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.bed",

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        pars_bln_option        = config["PARAMS"]["OUTSIDER_VARIANT"]["PARS_BLN_OPTION"],
        call_sv                = config["CHOICE"]["OUTSIDER_VARIANT"]["CALL_SV"],
        CHROM_KEEP             = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["CHROM_KEEP"],
        GET_SEQ_REPORT_OPTION  = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["GET_SEQ_REPORT_OPTION"],
        threads                = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,


        #COLORS
        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

        step=0,

    log:
        soft = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/SOFT"


    shell:
        """
        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] DETECTION TE IN SOFT READS [^-^] {params.cend}"

        mkdir -p {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT

        rm -f {log}.out {log}.err
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        ## CREATE VCF SOFT
        echo "CREATE VCF SOFT..."
        ###python3 ${{path_to_pipline}}/lib/python/parsing/find_soft.py {input.bam} > {input.vcf};

        ## GET SEQUENCE SOFT
        echo "GET SEQUENCE SOFT..."

        TrEMOLO_SIZE_MAX_TE=`awk '{{ if(substr($0, 1, 1) != ">"){{ if( length($0)>max ){{ max=length($0) }} }} }} END{{print max}}' {input.fasta_TE}`
        export TrEMOLO_SIZE_MAX_TE=$((TrEMOLO_SIZE_MAX_TE + 100));
        echo $TrEMOLO_SIZE_MAX_TE;

        ### GET SOFT SEQUENCE AND CUT SIZE
        ##cut size for less false (+)
        rm -f {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.bed
        awk -v max_size="$TrEMOLO_SIZE_MAX_TE" -v out_bed="{params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.bed" '{{
            split($4, spL, ";"); 
            split($5, spR, ";"); 
            split(spL[3], spLSEQ, "=");
            split(spR[3], spRSEQ, "=");
            

            split($6, spL_RS, "=");
            split($7, spR_RS, "=");

            NB_RS_LEFT  = split(spL_RS[2], spL_RS_READ, ",");
            NB_RS_RIGHT = split(spR_RS[2], spR_RS_READ, ",");

            if(spLSEQ[2] != "NONE"){{ 
                if(length(spLSEQ[2]) <= max_size){{
                    print ">"$1":<SOFT>:"$2":"$2+1":"$3".L:"NB_RS_LEFT":PRECISE:0\\n"spLSEQ[2];
                }}
                else{{
                    print ">"$1":<SOFT>:"$2":"$2+1":"$3".L:"NB_RS_LEFT":PRECISE:0\\n"substr(spLSEQ[2], length(spLSEQ[2])-max_size+1, max_size);
                }}
            }} 

            if(spRSEQ[2] != "NONE"){{
                if(length(spRSEQ[2]) <= max_size){{
                    print ">"$1":<SOFT>:"$2":"$2+1":"$3".R:"NB_RS_RIGHT":PRECISE:0\\n"spRSEQ[2];
                }}
                else {{
                    print ">"$1":<SOFT>:"$2":"$2+1":"$3".R:"NB_RS_RIGHT":PRECISE:0\\n"substr(spRSEQ[2], 1, max_size);
                }}
            }}

            print $1"\\t"$2"\\t"$2+1"\\t"$3":"(NB_RS_LEFT + NB_RS_RIGHT) >> out_bed

        }}' {input.vcf} | grep -v "^--" > {output.seqs};

        ## BLAST TE
        echo "BLAST TE SOFT BEST..."
        makeblastdb -in {input.fasta_TE} -dbtype nucl 2> {log.soft}.err;
        test -s {output.seqs} && \
            blastn -num_threads {params.threads} -db {input.fasta_TE} -query {output.seqs} -outfmt 6 -out {output.bln} 2>> {log.soft}.err || (echo "FAILDED" && exit 1);


        ## BIS FOR FREQUENCY
        echo "BLAST TE SOFT ALL..."
        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.vcf.bis && \
            awk 'BEGIN{{ID=""; count=1;}} NR>1 && OFS=":"{{
                if ( $4 != ID ) {{
                    ID=$4; 
                    count=1;
                }} 
                print ">"$1, $2"-"$3, $4, $5, count, $6, $8, $9"\\n"$10; 
                count += 1;
            }}' {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.vcf.bis > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.fasta.bis


        test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.fasta.bis && \
            blastn -num_threads {params.threads} -db {input.fasta_TE} \
            -query {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.fasta.bis \
            -outfmt 6 \
            -out {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.bln.bis 2>> {log.soft}.err;


        ## GET CANDIDATE TE
        echo "GET CANDIDATE TE SOFT..."
        number_lines_bln=`cat {output.bln} | wc -l`

        test -s {output.bln} && \
            python3 ${{path_to_pipline}}/lib/python/parsing/parse_blast_main.py \
                {output.bln} \
                {input.fasta_TE} \
                {output.all_te} \
                --combine_name {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/COMBINE_SV_SOFT.csv -c -k "SOFT" {params.pars_bln_option}

        test -s {output.all_te} && \
            awk 'NR>1 {{print $2":"$1}}' {output.all_te} | awk -F ":" 'OFS="\t"{{print $1, $3, $4, $10"|"$5}}' > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/TE_SOFT.bed

        test -s {output.all_te} && \
            awk 'NR>1 && OFS="\t"{{split($2, sp, ":"); print sp[1], sp[3], sp[4], $1"|"sp[5], $5, sp[9]}}' {output.all_te} > {output.bed}
        
        ###TEST NO SOFT
        ##rm -f {output.all_te} {output.bed} {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/TE_SOFT.bed

        ## NO TE SOFT FOUND
        if ! test -s {input.vcf} || ! test -s {output.all_te} || ! test -s {output.bln} || ! test -s {output.seqs}; then
            warn_msg "[SNK--WARNING] NO TE SOFT FOUND";
            touch {input.vcf}
            touch {output.all_te}
            touch {output.bln}
            touch {output.seqs}
        fi;

        #** REMOVE **#
        #rm -f {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/ID*;
        #rm -f {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT_TE_KEEP*;
        rm -f `find {params.work_directory} -name "*.fai"`
        """


#END SOFT_TE


#BLAST database of TE against SV (Structural variant)
rule DETECTION_TE :
    input:
        bed      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.bed",
        vcf      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/VARIANT_CALLING/SV.vcf",
        fasta_TE = config["DATA"]["TE_DB"],
        bam      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/MAPPING/SAMPLE_mapping_GENOME_MD.sorted.bam",

    output:
        sniffles_TE_bed  = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/POSITION_START_TE.bed",
        snif_seqs = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/VARIANT_CALLING/SEQUENCE_INDEL.fasta",
        bln       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/BLAST_SEQUENCE_INDEL_vs_DBTE.bln",
        all_te    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TE_DETECTION/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        preset_view    = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_VIEW"]["PRESET_OPTION"]) + " --threads " + str(config["PARAMS"]["THREADS"]),
        preset_sort    = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_SORT"]["PRESET_OPTION"]) + " --threads " + str(config["PARAMS"]["THREADS"]),
        preset_callmd  = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_CALLMD"]["PRESET_OPTION"]) + " --threads " + str(config["PARAMS"]["THREADS"]),

        OPTIMIZE_FREQUENCE     = config["CHOICE"]["OUTSIDER_VARIANT"]["OPTIMIZE_FREQUENCE"],
        call_sv                = config["CHOICE"]["OUTSIDER_VARIANT"]["CALL_SV"],
        CHROM_KEEP             = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["CHROM_KEEP"],
        pars_bln_option        = config["PARAMS"]["OUTSIDER_VARIANT"]["PARS_BLN_OPTION"],
        GET_SEQ_REPORT_OPTION  = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["GET_SEQ_REPORT_OPTION"],
        threads                = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,


        #COLORS
        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

        step=0,

    log:
        DETECTION = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/DETECTION_TE"


    shell:
        """
        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] DETECTION TE [^-^] {params.cend}"

        mkdir -p {params.work_directory}/OUTSIDER/TE_DETECTION/

        rm -f {log}.out {log}.err
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt


        #** GET SEQUENCE REPORT **#
        echo "   GET SEQUENCE REPORT..." | tee {log}.err {log}.log
        printf "%s\\n" "{params.cmess} [SNK]--[`date`] GET SEQUENCE VARIANT [^-^] {params.cend}"
        python3 ${{path_to_pipline}}/lib/python/parsing/get_seq_vcf.py {params.GET_SEQ_REPORT_OPTION} -c '{params.CHROM_KEEP}' {input.vcf} {output.snif_seqs} 2>> {log.DETECTION}.err ;
        test -s {output.snif_seqs} || (fail_msg "ERROR NO SEQUENCE SV FOUND" && exit 1)
        
        version_vcf=`grep fileformat {input.vcf} | cut -d "=" -f 2`

        #GET ALL SEQUENCE OF READ SUPPORT FOR SNIFFLES
        if [ "$version_vcf" = "VCFv4.1" ] || [ "$version_vcf" = "VCFv4.2" ] || [ "$version_vcf" = "VCFv4.3" ]; then
            #echo "SNIFFLES"
            awk 'OFS="\t"{{ if(substr($0, 1, 1) == ">"){{ split($0, sp, ":"); header=""substr(sp[1], 2, 500)"\t"sp[3]"\t"sp[4]"\t"substr($0, 2, 500); }}else{{ header=header"\t"length($0)"\t"$0; print header}} }}' \
                {output.snif_seqs} | grep -w -E "INS|DEL" > {params.work_directory}/OUTSIDER/TE_DETECTION/TE_VR.bed

            python3 ${{path_to_pipline}}/lib/python/parsing/parse_bam_found_ins.py {input.bam} \
                {params.work_directory}/OUTSIDER/TE_DETECTION/TE_VR.bed > {output.snif_seqs} 2>> {log.DETECTION}.err
        else
            fail_msg "Vesrion of VCF must be 'VCFv4.1', 'VCFv4.2' or 'VCFv4.3' " && exit 2
        fi;
        

        printf "%s\\n" "{params.cmess} [SNK]--[`date`] BLAST SV TO TE [^-^] {params.cend}" | tee {log}.err {log}.log
        
        #** BLAST SEQUENCE VCF on DATABASE TE **#
        echo "   BLAST SEQUENCE SV on DATABASE TE..." | tee {log}.err {log}.log
        makeblastdb -in {input.fasta_TE} -dbtype nucl 2> {log.DETECTION}.err;
        blastn -num_threads {params.threads} -db {input.fasta_TE} -query {output.snif_seqs} -outfmt 6 -out {output.bln} 2>> {log.DETECTION}.err;
        
        printf "%s\\n" "{params.cmess} [SNK]--[`date`] BLAST DONE CHECK logfile => {log.DETECTION} {params.cend}" | tee {log}.err {log}.log

        printf "%s\\n" "{params.cmess} [SNK]--[`date`] FILTER TE BLAST [^-^] {params.cend}" | tee {log}.err {log}.log
        
        #** FILTER TE BLAST **#
        echo "   FILTER TE BLAST..." | tee {log}.err {log}.log

        python3 ${{path_to_pipline}}/lib/python/parsing/parse_blast_main.py {output.bln} \
            {input.fasta_TE} \
            {output.all_te} -c \
            --combine_name {params.work_directory}/OUTSIDER/TE_DETECTION/COMBINE_TE.csv {params.pars_bln_option} 2>> {log.DETECTION}.err;
        
        awk 'NR>1 {{print $2":"$1":"$5}}' {output.all_te} | awk -F ":" 'OFS="\t"{{print $1, $3, ($3>=$4 ? $3+1 : $4), $10"|"$5, $11, $9}}' | bedtools sort > {params.work_directory}/OUTSIDER/TE_DETECTION/POSITION_START_TE.bed

        if [ `cat {output.all_te} | wc -l` -eq 1 ]; then
            fail_msg "ERROR EXIT PIPELINE BECAUSE NO TE FOUND\\n";
            exit 3;
        fi;

        #** REMOVE **#
        rm -f `find {params.work_directory} -name "*.fai"`
        """

#END DETECTION_TE



rule TrEMOLO_SV_TE :
    input:
        sv       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/VARIANT_CALLING/SV.vcf",
        bam      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/MAPPING/SAMPLE_mapping_GENOME_MD.sorted.bam",
        fasta_TE = config["DATA"]["TE_DB"],
        
    output:
        SV_CLUST_seq     = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.fasta",
        SV_INS_CLUST_bln = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.bln",
        INS_TREMOLO_csv  = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.csv",
        INS_TREMOLO_bed  = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/INS/INS_TREMOLO.bed",
        hard_vcf         = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/HARD/SV_HARD.tr_vcf",
        soft_vcf         = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/SOFT/SV_SOFT.vcf",
        soft_te          = [config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.bed", config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.bed"] if not config["CHOICE"]["OUTSIDER_VARIANT"]["CLIPPED_READS"] else [],
    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        CLIPPED_READS   = config["CHOICE"]["OUTSIDER_VARIANT"]["CLIPPED_READS"],  

        pars_bln_option = config["PARAMS"]["OUTSIDER_VARIANT"]["PARS_BLN_OPTION"],
        threads         = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,

        env            = env, #source environnement

        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

        step=0,

    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/TrEMOLO_SV_TE",

    shell:
        """
        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        mkdir -p {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/
        mkdir -p {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/
        mkdir -p {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] GET INSERTION TrEMOLO [^-^] {params.cend}"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        rm -f {log}.out {log}.err
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        samtools index {input.bam} 2> {log}.err

        echo "GET INSERTION..."
        ###python3 ${{path_to_pipline}}/lib/python/parsing/find_all_ins.py {input.bam} > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS.bed 2>> {log}.err
        python3 ${{path_to_pipline}}/lib/python/parsing/find_all_type_ins.py {input.bam} \
            --output-soft {output.soft_vcf} \
            --output-hard {output.hard_vcf} \
            --output-ins {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS.bed 2>> {log}.err

        ! test -s {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS.bed && fail_msg "[{rule}] ERROR : NO INSERTION FOUND\\n" && exit 5;

        bedtools sort -i {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS.bed | bedtools cluster -d 50 > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.bed 2>> {log}.err;

        echo "   NB INSERTION FOUND : `tail -n 1 {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.bed | cut -f 6`"

        awk '
            BEGIN{{
                clust = 0;
            }}

            {{
                if(clust == 0){{
                    chrom=$1; 
                    start=$2; 
                    end=$3; 
                    clust=$6;
                    
                    dic_clust[clust][1]["header"]  = ">"chrom":<INS>:"start":"end":TrEMOLO.INS."clust;
                    dic_clust[clust][1]["seq"]     = $5;
                    dic_clust[clust][1]["RS"]      = 1;
                    dic_clust[clust][1]["READ"]    = $4;
                }}
                else if(clust != 0 && clust != $6){{
                    chrom=$1; 
                    start=$2; 
                    end=$3;
                    
                    for(i=1; i <= dic_clust[clust][1]["RS"]; i++){{
                        print dic_clust[clust][i]["header"]":"dic_clust[clust][1]["RS"]":IMPRECISE:"i;
                        print dic_clust[clust][i]["seq"];
                    }}

                    clust=$6;

                    dic_clust[clust][1]["header"]  = ">"chrom":<INS>:"start":"end":TrEMOLO.INS."clust;
                    dic_clust[clust][1]["seq"]     = $5;
                    dic_clust[clust][1]["RS"]      = 1;
                    dic_clust[clust][1]["READ"]    = $4;

                }}
                else{{#CHECK READ EXIST
                    IN = 0;
                    for(i=1; i <= dic_clust[clust][1]["RS"]; i++){{
                        if(dic_clust[clust][i]["READ"] == $4){{
                            IN = 1;
                            i = dic_clust[clust][1]["RS"] + 1;
                        }}
                    }}

                    if(IN == 0){{
                        
                        dic_clust[clust][1]["RS"] += 1;
                        dic_clust[clust][dic_clust[clust][1]["RS"]]["READ"]    = $4;
                        dic_clust[clust][dic_clust[clust][1]["RS"]]["header"]  = ">"chrom":<INS>:"start":"end":TrEMOLO.INS."clust;
                        dic_clust[clust][dic_clust[clust][1]["RS"]]["seq"]     = $5;
                    }}
                    
                }} 
            }}' {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_INS_CLUST.bed > {output.SV_CLUST_seq}

        ##SIZE OF EACH SV
        awk ' 
            /^>/ {{ head=substr($0, 2, length($0)); }} 
            /^[^>]/ && OFS="\t" {{ print head, length($0); }}' \
                {output.SV_CLUST_seq} > {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/SV_SIZE.tsv

        echo "BLAST TE INSERTION..."
        makeblastdb -in {input.fasta_TE} -dbtype nucl
        echo
        blastn -num_threads {params.threads} -db {input.fasta_TE} -query {output.SV_CLUST_seq} -outfmt 6 -out {output.SV_INS_CLUST_bln}
         
        echo "GETTING TRUE TE INTO INSERTION..."
        python3 ${{path_to_pipline}}/lib/python/parsing/parse_blast_main.py \
              {output.SV_INS_CLUST_bln} \
              {input.fasta_TE} \
              {output.INS_TREMOLO_csv} \
              --combine_name {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/INS/COMBINE_INS_TREMOLO.csv -c {params.pars_bln_option} 2>> {log}.err 

        awk 'NR>1 && OFS="\t" {{ split($2, sp, ":"); print sp[1], sp[3], sp[3]+1, $1"|"sp[5], $5, sp[9] }}' {output.INS_TREMOLO_csv} > {output.INS_TREMOLO_bed}

        # ##CLIPPED
        if [ {params.CLIPPED_READS} = "False" ]; then
            touch {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.bed
            touch {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/SOFT/SOFT_TE.csv
            touch {params.work_directory}/OUTSIDER/TrEMOLO_SV_TE/HARD/HARD_TE.bed
        fi;
            

        """

#END TrEMOLO_SV_TE




#Get Strucural Variant (vcf file)
rule svim :
    input:
        genome = config["DATA"]["GENOME"],
        bam    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/MAPPING/SAMPLE_mapping_GENOME_MD.sorted.bam",

    output:
        svim   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/VARIANT_CALLING/SVIM_RESULT/variants.vcf", 
        sv     = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/VARIANT_CALLING/SV.vcf",
        
    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        #COLORS
        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

        step=0,

    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/svim"


    shell:
        """
        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] SVIM DETECTION VARIANT [^-^] {params.cend}"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        rm -f {log}.out {log}.err
        echo "[`date`] LOG TASK {log}.out, {log}.err"


        samtools index {input.bam} 2> {log}.err

        # svim alignment --read_names \
        #      --insertion_sequences \
        #      --minimum_depth 1 {params.work_directory}/OUTSIDER/VARIANT_CALLING/SVIM_RESULT {input.bam} {input.genome} 2> {log}.err

        ##printf "%s\\n" "{params.cmess} [SNK]--[`date`] SVIM DONE CHECK log file : {log}.err, {log}.out {params.cend}"

        begin_load `cat {params.work_directory}/.pid`
        #kill -10 `cat {params.work_directory}/.pid` || echo
        run_cmd "svim alignment --read_names --insertion_sequences --minimum_depth 1 {params.work_directory}/OUTSIDER/VARIANT_CALLING/SVIM_RESULT {input.bam} {input.genome}" "{log}" "SVIM" "False";
        end_load
        sleep 1

        cp {output.svim} {output.sv}

        """

#END svim



#Get Strucural Variant (vcf file)
rule sniffles :
    input:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/MAPPING/SAMPLE_mapping_GENOME_MD.sorted.bam",

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/VARIANT_CALLING/SV.vcf", 
        
    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

        step=0,

    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/sniffles",

    shell:
        """

        {params.env}
        path_to_pipline=`dirname {params.path_snk}`

        mkdir -p {params.work_directory}/OUTSIDER/VARIANT_CALLING/

        rm -f {log}*
        echo "[`date`] LOG TASK {log}.out, {log}.err"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] SNIFFLES [^-^] {params.cend}"

        samtools index {input} 2> {log}.err

        #sniffles --report-seq -s 1 -m {input} -v {output} -n -1 2> {log}.err;
        
        version=`sniffles -h 2>&1 | grep Version | cut -d " " -f 2`

        ## version work
        if [ "$version" = "1.0.10" ]; then

            begin_load `cat {params.work_directory}/.pid`
            #kill -10 `cat {params.work_directory}/.pid` || echo
            run_cmd "sniffles --report_seq -s 1 -m {input} -v {output} -n -1" "{log}" "SNIFFLES 1.0.10" "False";
            end_load
            sleep 1

        elif [ "$version" = "1.0.12" ] || [ "$version" = "1.0.11" ]; then

            begin_load `cat {params.work_directory}/.pid`
            #kill -10 `cat {params.work_directory}/.pid` || echo
            run_cmd "sniffles --report-seq -s 1 -m {input} -v {output} -n -1" "{log}" "SNIFFLES $version" "False";
            end_load
            sleep 1

        else
            fail_msg "[SNK] -- [`date`] -- [ERROR] version $version YOU HAVE NOT THE GOOD VERSION OF SNIFFLES, PLEASE GET VERSION 1.0.10, 1.0.11 or 1.0.12"
            exit 2
        fi;


        """

#END sniffles


#Sort and callmd
rule samtools :
    input:
        sam    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/MAPPING/SAMPLE_mapping_GENOME.sam",
        genome = config["DATA"]["GENOME"],

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/MAPPING/SAMPLE_mapping_GENOME_MD.sorted.bam",
        
    params:
        #DATA
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),
        
        env            = env, #source environnement
        path_snk       = path_snk,
        
        #PARAMS
        preset_view    = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_VIEW"]["PRESET_OPTION"])   + " --threads " + str(config["PARAMS"]["THREADS"]),
        preset_sort    = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_SORT"]["PRESET_OPTION"])   + " --threads " + str(config["PARAMS"]["THREADS"]),
        preset_callmd  = re.sub("--threads [0-9]+|-@ [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_CALLMD"]["PRESET_OPTION"]) + " --threads " + str(config["PARAMS"]["THREADS"]),
        
        #COLORS
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/samtools",

    shell:
        """
        {params.env}
        path_to_pipline=`dirname {params.path_snk}`
                
        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] SAMTOOLS [^-^] {params.cend}"

        mkdir -p {params.work_directory}/OUTSIDER/MAPPING/

        echo "[`date`] LOG TASK {log}.err"

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        FLAG_EXLUDE=`(echo {params.preset_view} | grep -E "\-F [0-9]+" > /dev/null && echo "") || echo "-F 4"`
        echo "FLAG_EXLUDE : $FLAG_EXLUDE";

        echo "---view---" | tee {log}.out
        #samtools view -h {params.preset_view} -F 4 -b {input.sam} > {input.sam}.bam 2>> {log}.err;
        run_cmd "samtools view -h {params.preset_view} $FLAG_EXLUDE -b {input.sam} -o {input.sam}.bam" "{log}" "SAMTOOLS_VIEW" "False";

        rm -f {log}.out

        echo "---sort---" | tee -a {log}.out
        #samtools sort {params.preset_sort} {input.sam}.bam -o {input.sam}.sorted.bam 2>> {log}.err;
        run_cmd "samtools sort {params.preset_sort} {input.sam}.bam -o {input.sam}.sorted.bam" "{log}" "SAMTOOLS_SORT" "False";

        echo "---calmd---" | tee -a {log}.out
        #samtools calmd {params.preset_callmd} -b {input.sam}.sorted.bam {input.genome} > {output} 2>> {log}.err; #CALL MD for sniffles
        run_cmd "samtools calmd {params.preset_callmd} -b {input.sam}.sorted.bam {input.genome} | tee {output}" "{log}" "SAMTOOLS_CALLMD" "False";#CALL MD for sniffles

        echo "---stats---" | tee -a {log}.out
        #samtools stats {input.sam}.sorted.bam | grep "^SN" > {params.work_directory}/OUTSIDER/MAPPING/stats.txt 2>> {log}.err; #CALL MD for sniffles
        run_cmd "samtools stats {input.sam} | grep "^SN" | cut -f 2-6 | tee {params.work_directory}/OUTSIDER/MAPPING/stats.txt" "{log}" "SAMTOOLS_STATS" "False";#STATS MAPPING

        # rm -f {input.sam} \
        #     {input.sam}.bam \
        #     {input.sam}.sorted.bam*;
        rm -f {log}.out;

        """


#END samtools




#Map reads on assembly genome
rule mapping :
    input:  
        read   = config["DATA"]["SAMPLE"],
        genome = config["DATA"]["GENOME"],

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/OUTSIDER/MAPPING/SAMPLE_mapping_GENOME.sam",
    
    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),
        config         = json.dumps(config),

        preset         = config["PARAMS"]["OUTSIDER_VARIANT"]["MINIMAP2"]["PRESET_OPTION"] if config["PARAMS"]["OUTSIDER_VARIANT"]["MINIMAP2"]["PRESET_OPTION"] != "" else "map-ont",
        option         = re.sub("-t [0-9]+", "", config["PARAMS"]["OUTSIDER_VARIANT"]["MINIMAP2"]["OPTION"]) + " -t " + str(config["PARAMS"]["THREADS"]),

        env            = env, #source environnement


        #COLOR 
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/minimap2"

    shell:
        """
        {params.env};
        path_to_pipline=`dirname {params.path_snk}`

        rm -f `find {params.work_directory} -name "*.fa*.fai"`

        mkdir -p {params.work_directory}/OUTSIDER/MAPPING/

        rm -f {log}*

        echo "[`date`] STEP OUTSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] MINIMAP2 MAPPING {params.cend}"
        
        #INDEX
        #minimap2 -x  {params.preset} -d {input.genome}.mmi {input.genome} 2> {log}.err;
        run_cmd "minimap2 -x  {params.preset} -d {input.genome}.mmi {input.genome}" "{log}" "MINIMAP2_INDEX" "False" ;

        #MAPPING
        #minimap2 -ax {params.preset} {params.option} {input.genome} {input.read} > {output} 2>> {log}.err;
        
        begin_load `cat {params.work_directory}/.pid`
            #kill -10 `cat {params.work_directory}/.pid` || echo
            run_cmd "minimap2 -ax {params.preset} {params.option} {input.genome} {input.read} | tee {output}" "{log}" "MINIMAP2" "False"; 
        end_load
        sleep 1

        test -s {output} || ( fail_msg "ERROR : MAPPING FAILED\\n" && exit 2 )

        rm -f {log}.out
        """


#END mapping



####
####
############# INSIDER VARIANT
####
####




rule TE_ALL_IN_ASSEMBLY:
    input:
        csv      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/TE_DETECTION/INSERTION.csv",
        query    = config["DATA"]["GENOME"],
        fasta_TE = config["DATA"]["TE_DB"],

    output:
        csv = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/TE_DETECTION/ALL_TE.csv",
        bed = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/TE_DETECTION/POSITION_ALL_TE.bed",
        tmp = output_link=[],

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env,

        pars_bln_option_insider = config["PARAMS"]["INSIDER_VARIANT"]["PARS_BLN_OPTION"],

        CHROM_KEEP     = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["CHROM_KEEP"],
        threads        = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,


        
        #COLOR 
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,

        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/TE_ALL_IN_ASSEMBLY",

    shell:
        """
        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] GET ALL TE IN ASSEMBLY {params.cend}"

        {params.env}
        path_to_pipline=`dirname {params.path_snk}`
        
        mkdir -p {params.work_directory}/INSIDER/TE_DETECTION/

        rm -f {log}.out {log}.err

        echo "[`date`] LOG TASK {log}.out, {log}.err"

        echo "[`date`] STEP {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        ## SEARCH ALL REGION TE WITH BLAST
        echo "  SEARCH ALL REGION TE ON GENOME..."
        makeblastdb -in {input.fasta_TE} -dbtype nucl  2> {log}.err 1> {log}.out;
        blastn -num_threads {params.threads} -db {input.fasta_TE} \
            -query {input.query} \
            -outfmt 6 \
            -out {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_1.bln 2>> {log}.err 1>> {log}.out;

        chrom_keep=`echo "{params.CHROM_KEEP}" | tr "," "|"`

        ## BUILD SEQUENCE CANDIDATE TE
        echo "  BUILD SEQUENCE CANDIDATE TE..."
        cut -f 1,7,8 {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_1.bln | grep -E "$chrom_keep" > {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_1.bed
        bedtools sort -i {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_1.bed | bedtools merge -d 100 | bedtools cluster > {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_1_merge_cluster.bed 
        bedtools getfasta -fi {input.query} -bed {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_1_merge_cluster.bed -name+ > {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_1_merge_cluster.fasta
        
        ## BLAST ALL REGION CANDIDATE OF TE
        echo "  BLAST ALL REGION CANDIDATE OF TE..."
        blastn -num_threads {params.threads} -db {input.fasta_TE} \
            -query {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_1_merge_cluster.fasta \
            -outfmt 6 \
            -out {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_2.bln 2>> {log}.err 1>> {log}.out;

        ## GETTING TE
        echo "  GETTING TE..."

        number_lines_bln=`cat {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_2.bln | wc -l`
        if [ "$number_lines_bln" -gt 100000  ]; then
            awk 'BEGIN{{qseqid=""; sseqid=""}}{{if(qseqid!=$1){{qseqid=$1; sseqid=$2; print $0;}}else if(sseqid==$2){{print $0}}}}' {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_2.bln \
                > {params.work_directory}/INSIDER/TE_DETECTION/tmp_pre_filtre.bln

            test -s {params.work_directory}/INSIDER/TE_DETECTION/tmp_pre_filtre.bln  && \
              python3 ${{path_to_pipline}}/lib/python/parsing/global_sv.py {params.pars_bln_option_insider} \
                --combine_name {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_COMBINE_TE.csv \
                {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_2.bln  \
                {input.fasta_TE} \
                {output.csv}

        else
            test -s {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_2.bln  && \
              python3 ${{path_to_pipline}}/lib/python/parsing/global_sv.py {params.pars_bln_option_insider} \
                --combine_name {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_COMBINE_TE.csv \
                {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_2.bln  \
                {input.fasta_TE} \
                {output.csv}
        fi;

        awk 'NR>1 && OFS="\t"{{ split($2, sp1, ":"); split(sp1[4], sp2, "-"); print sp1[3], sp2[1], sp2[2], $1"|"sp1[1] }}' {output.csv} > {output.bed}
        ln -s -r -f {output.bed} {params.work_directory}/`basename {output.bed}`

        rm -f {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_1*
        rm -f {params.work_directory}/INSIDER/TE_DETECTION/ALL_TE_2*
        """


#END TE_ALL_IN_ASSEMBLY



rule TE_INSIDER:
    input:  
        ref      = config["DATA"]["REFERENCE"],
        query    = config["DATA"]["GENOME"],
        sam      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/VARIANT_CALLING/pm_against_ref.sam",
        delta    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/VARIANT_CALLING/pm_against_ref.sam.delta",
        bed      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/VARIANT_CALLING/assemblytics_out.Assemblytics_structural_variants.bed",
        stats    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/VARIANT_CALLING/assemblytics_out.Assemblytics_assembly_stats.txt",

        fasta_TE = config["DATA"]["TE_DB"],


    output:
        csv = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/TE_DETECTION/INSERTION.csv",
        bed = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/TE_DETECTION/INSERTION_TE.bed",
        tmp = output_link=[],

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env,

        pars_bln_option_insider = config["PARAMS"]["INSIDER_VARIANT"]["PARS_BLN_OPTION"],
        threads                 = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,
        
        #COLOR 
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,


        step=0,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/TE_INSIDER",

    shell:
        """

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] GET TE INSIDER {params.cend}"

        echo "[`date`] STEP INSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        {params.env}
        path_to_pipline=`dirname {params.path_snk}`
        
        mkdir -p {params.work_directory}/INSIDER/TE_DETECTION/

        rm -f {log}.log {log}.err

        echo "[`date`] LOG TASK {log}.out, {log}.err"

        #echo "GET SEQUENCE SV"
        #GET SEQUENCE SV
        ## GET SEQUENCE SV INSERTION
        rm -f {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_SEQ_ALL.fasta
        array_type=( "INSERTION" "Repeat_expansion" "Tandem_expansion" );
        for type in "${{array_type[@]}}"
        do
            grep -i $type {input.bed} | awk '{{print $10":"$4}}' | awk -v type="$type" -F ":" 'OFS="\t"{{split($2, a, "-"); print $1 , a[1], a[2], $4":"$3":"type}}' > {params.work_directory}/INSIDER/TE_DETECTION/${{type}}.bed || echo "$type NOT FOUND"
            
            test -s {params.work_directory}/INSIDER/TE_DETECTION/${{type}}.bed && \
                ( bedtools getfasta -fi {input.query} -bed {params.work_directory}/INSIDER/TE_DETECTION/${{type}}.bed -name+ > {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_SEQ.fasta && \
                cat {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_SEQ.fasta >> {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_SEQ_ALL.fasta ) || ( echo "$type is EMPTY" && touch {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_SEQ.fasta && touch {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_SEQ_ALL.fasta )
        done;

        #cat {params.work_directory}/INSIDER/TE_DETECTION/Tandem_expansion_SEQ.fasta {params.work_directory}/INSIDER/TE_DETECTION/Repeat_expansion_SEQ.fasta {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_SEQ.fasta > {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_SEQ_ALL.fasta
        cat {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_SEQ_ALL.fasta > {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_SEQ.fasta

        #echo "GET SEQUENCE SV DELETION"
        ## GET SEQUENCE SV DELETION
        rm -f {params.work_directory}/INSIDER/TE_DETECTION/DELETION_SEQ_ALL.fasta
        array_type_deletion=( "DELETION" "Repeat_contraction" "Tandem_contraction" );
        for type in "${{array_type_deletion[@]}}"
        do

            grep -i ${{type}}  {input.bed} | awk  -v type="$type" 'OFS="\t"{{print $1, $2, $3, $4":"$6":"type}}' > {params.work_directory}/INSIDER/TE_DETECTION/${{type}}.bed || echo "$type NOT FOUND"

            #Warning : touch SEQ
            test -s {params.work_directory}/INSIDER/TE_DETECTION/${{type}}.bed && \
                ( bedtools getfasta -fi {input.ref}  -bed {params.work_directory}/INSIDER/TE_DETECTION/${{type}}.bed -name+ > {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_SEQ.fasta && \
                cat {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_SEQ.fasta >> {params.work_directory}/INSIDER/TE_DETECTION/DELETION_SEQ_ALL.fasta ) || ( echo "$type is EMPTY" && touch {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_SEQ.fasta && touch {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_SEQ_ALL.fasta )

        done;

        #cat {params.work_directory}/INSIDER/TE_DETECTION/Tandem_contraction_SEQ.fasta {params.work_directory}/INSIDER/TE_DETECTION/Repeat_contraction_SEQ.fasta {params.work_directory}/INSIDER/TE_DETECTION/DELETION_SEQ.fasta > {params.work_directory}/INSIDER/TE_DETECTION/DELETION_SEQ_ALL.fasta
        cat {params.work_directory}/INSIDER/TE_DETECTION/DELETION_SEQ_ALL.fasta > {params.work_directory}/INSIDER/TE_DETECTION/DELETION_SEQ.fasta


        #echo "GET TE IN SV"
        # GET TE IN SV
        array_type=( "INSERTION" "Repeat_expansion" "Tandem_expansion" "DELETION" "Repeat_contraction" "Tandem_contraction" )
        for type in "${{array_type[@]}}"
        do
            echo "TYPE : $type";

            if test -s {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_SEQ.fasta ; then

                echo "   Checking TE candidate..."
                makeblastdb -in {input.fasta_TE} -dbtype nucl  2> {log}.err 1> {log}.out;
                blastn -num_threads {params.threads} -db {input.fasta_TE} \
                    -query {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_SEQ.fasta \
                    -outfmt 6 \
                    -out {params.work_directory}/INSIDER/TE_DETECTION/${{type}}.bln 2> {log}.err 1> {log}.out;
                

                echo "   Getting TE..."
                test -s {params.work_directory}/INSIDER/TE_DETECTION/${{type}}.bln && \
                    python3 ${{path_to_pipline}}/lib/python/parsing/global_sv.py {params.pars_bln_option_insider} \
                        --combine_name {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_COMBINE_TE.csv \
                        {params.work_directory}/INSIDER/TE_DETECTION/${{type}}.bln \
                        {input.fasta_TE} \
                        {params.work_directory}/INSIDER/TE_DETECTION/${{type}}.csv 2>> {log}.err 1>> {log}.out;                

                echo "   Count TE..."
                test -s {params.work_directory}/INSIDER/TE_DETECTION/${{type}}.csv && \
                awk 'NR>1{{print $1}}' {params.work_directory}/INSIDER/TE_DETECTION/${{type}}.csv | sort | uniq -c | sort -k 1 -n | \
                    awk 'BEGIN{{print "x\ty\tz"}} OFS="\t"{{print "", $2, $1}}' > {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_COUNT_TE.csv

                echo
                #test -s {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_COUNT_TE.csv && \
                #tail {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_COUNT_TE.csv | awk -F "\t" 'OFS="\t"{{if(NR!=1){{print $2, $3}}else{{print "TE\tNUMBER"}}}}'
                test -s {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_COUNT_TE.csv && \
                    awk -F "\t" 'BEGIN{{ NB_FAMILY=0; Count_TE=0; }} OFS="\t"{{ if(NR!=1){{ NB_FAMILY += 1; Count_TE+=$3;}}  }} END{{print "NUMBER OF FAMILY := "NB_FAMILY"\\nNUMBER OF TE := "Count_TE;}}' {params.work_directory}/INSIDER/TE_DETECTION/${{type}}_COUNT_TE.csv
                echo -e "\n"
            fi;
        done;

        #INSERTION ON QUERY
        # test -s {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv && \
        #     awk 'NR>1 && OFS="\t"{{ split($2, a, ":"); split(a[6], b, "-"); print a[5], b[1], b[2], $1"|"a[1], a[7]}}' {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv > {output.bed} #{params.work_directory}/INSIDER/TE_DETECTION/INSERTION_TE.bed 

        ##can be false sometime [b[1]+$6, b[2]-( (b[2]-b[1]) - $7 )] 
        test -s {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_COMBINE_TE.csv && \
            awk 'NR>1 && OFS="\t"{{ split($2, a, ":"); split(a[6], b, "-"); print a[5], b[1]+$6, b[2]-((b[2]-b[1])-$7), $1"|"a[1], a[7]}}' {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_COMBINE_TE.csv > {output.bed} #{params.work_directory}/INSIDER/TE_DETECTION/INSERTION_TE.bed 


        ##INSERTION ON REF
        echo "CALCUL POSITION TE ON REF"
        test -s {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv && \
            awk 'NR>1{{ split($2, sp, ":"); print sp[1] }}' {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv > {params.work_directory}/tmp_ID.txt
        
        rm -f {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_TE_ON_REF.bed

        test -s {params.work_directory}/tmp_ID.txt && \
            for id in `cat {params.work_directory}/tmp_ID.txt`; do 
                read -r chrom start end _ <<< $(grep -w "$id" {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out.Assemblytics_structural_variants.bed | awk 'OFS="\t"{{print $1, $2, $3}}')
                TE=`grep -w "$id" {params.work_directory}/INSIDER/TE_DETECTION/INSERTION.csv | cut -f 1`;

                echo -e "$chrom\t$start\t$end\t$TE|$id" >> {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_TE_ON_REF.bed
            done;
        rm -f {params.work_directory}/tmp_ID.txt

        test -s {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_TE_ON_REF.bed && \
            ln -s -r -f {params.work_directory}/INSIDER/TE_DETECTION/INSERTION_TE_ON_REF.bed {params.work_directory}/POS_TE_INSIDER_ON_REF.bed


        #DELETION ON REF
        test -s {params.work_directory}/INSIDER/TE_DETECTION/DELETION.csv && \
            awk 'NR>1{{print $1":"$2}}' {params.work_directory}/INSIDER/TE_DETECTION/DELETION.csv | awk -F ":" 'OFS="\t"{{split($7, sp, "-"); print $6, sp[1], sp[2], $1"|"$2}}' > {params.work_directory}/INSIDER/TE_DETECTION/DELETION_TE_ON_REF.bed && \
            ln -s -f -r {params.work_directory}/INSIDER/TE_DETECTION/DELETION_TE_ON_REF.bed {params.work_directory}/


        #DELETION ON QUERY
        test -s {params.work_directory}/INSIDER/TE_DETECTION/DELETION.csv && \
            awk 'NR>1{{ split($2, sp, ":"); print sp[1] }}' {params.work_directory}/INSIDER/TE_DETECTION/DELETION.csv > {params.work_directory}/tmp_ID.txt
        

        rm -f {params.work_directory}/INSIDER/TE_DETECTION/DELETION_TE.bed
        test -s {params.work_directory}/tmp_ID.txt && \
            for id in `cat {params.work_directory}/tmp_ID.txt`; do 
                read -r chrom start end <<< $(grep -w "$id" {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out.Assemblytics_structural_variants.bed | cut -f 10 | awk -F ":" 'OFS="\t"{{split($2, pos, "-"); print $1, pos[1], pos[2]}}')
                TE=`grep -w "$id" {params.work_directory}/INSIDER/TE_DETECTION/DELETION.csv | cut -f 1`;
                echo -e "$chrom\t$start\t$end\t$TE|$id" >> {params.work_directory}/INSIDER/TE_DETECTION/DELETION_TE.bed
            done;
        rm -f {params.work_directory}/tmp_ID.txt

        test -s {params.work_directory}/INSIDER/TE_DETECTION/DELETION_TE.bed && \
            ln -s -f -r {params.work_directory}/INSIDER/TE_DETECTION/DELETION_TE.bed {params.work_directory}/

        test -s {output.bed} && \
            cat {output.bed}| bedtools sort | awk 'OFS="\t"{{ print $1, $2, $3, $4, $3-$2, $5 }}' > {params.work_directory}/POSITION_TE_INSIDER.bed

        test -s {output.bed} || fail_msg "  WARNING NO TE INSERTION FOUND\\n";
        test -s {params.work_directory}/INSIDER/TE_DETECTION/DELETION_TE.bed || fail_msg "  WARNING NO TE DELETION FOUND\\n";

        #
        rm -f {params.work_directory}/INSIDER/TE_DETECTION/Repeat*
        rm -f {params.work_directory}/INSIDER/TE_DETECTION/Tandem*
        rm -f {params.work_directory}/INSIDER/TE_DETECTION/*SEQ_ALL.fasta

        """


#END TE_INSIDER



rule SV_INSIDER:
    input:  
        ref         = config["DATA"]["REFERENCE"],
        genome      = config["DATA"]["GENOME"],

    output:
        sam   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/VARIANT_CALLING/pm_against_ref.sam",
        delta = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/VARIANT_CALLING/pm_against_ref.sam.delta",
        bed   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/VARIANT_CALLING/assemblytics_out.Assemblytics_structural_variants.bed",
        stats = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/VARIANT_CALLING/assemblytics_out.Assemblytics_assembly_stats.txt",


    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env,
        threads                 = config["PARAMS"]["THREADS"] if type(config["PARAMS"]["THREADS"]) == int and config["PARAMS"]["THREADS"] > 0 else 1,


        #COLOR 
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,

        step=0,

    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/SV_INSIDER"

    shell:
        """

        printf "\\n\\n•••\\n%s\\n•••\\n\\n" "{params.cmess} [SNK]--[`date`] GET SV INSIDER {params.cend}"

        echo "[`date`] STEP INSIDER {params.step} : {rule}" >> {params.work_directory}/resume_task.txt

        mkdir -p {params.work_directory}/INSIDER/VARIANT_CALLING/
        mkdir -p {params.work_directory}/log/

        path_to_pipline=`dirname {params.path_snk}`

        rm -f `find {params.work_directory} -name "*.fa*.fai"`
        rm -f {log}.err {log}.log

        echo "[`date`] LOG TASK {log}.log, {log}.err"

        echo "MAPPING GENOME ON REFERENCE..."
        #COMPARE GENOME
        minimap2 -ax asm5 --cs -t {params.threads} {input.ref} {input.genome} > {output.sam} 2> {params.work_directory}/log/pm_contigs_against_ref.sam.log
        
        #CHECK MAPPING
        test -s {output.sam} || ( fail_msg "ERROR : MAPPING FAILED\\n" && exit 2 )
        python3 ${{path_to_pipline}}/lib/python/assemblitics/sam2delta.py {output.sam} 2>> {log}.err;
        
        echo "GET SV WITH Assemblytics with alignment..."
        #GET SV
        ## GET SV 1 Assemblytics with alignment sam to delta
        python3 ${{path_to_pipline}}/lib/python/assemblitics/Assemblytics_uniq_anchor.py \
            --delta {output.delta} \
            --unique-length 20000 \
            --out {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out \
            --keep-small-uniques 2>> {log}.err;

        echo "GET SV WITH Assemblytics between alignment..."
        ## GET SV 2 Assemblytics between alignment
        perl ${{path_to_pipline}}/lib/perl/Assemblytics_between_alignments.pl \
            {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out.coords.tab \
            50 \
            20000 \
            all-chromosomes \
            exclude-longrange \
            bed > {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out.variants_between_alignments.bed \
            2>> {log}.err;

        echo "GET SV WITH Assemblytics within alignment..."
        ## GET SV 3 Assemblytics within alignment
        python3 ${{path_to_pipline}}/lib/python/assemblitics/Assemblytics_within_alignment.py \
            --delta {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out.Assemblytics.unique_length_filtered_l20000.delta \
            --min 50 > {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out.variants_within_alignments.bed \
            2>> {log}.err;

        (test -s {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out.variants_between_alignments.bed || \
        test -s {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out.variants_within_alignments.bed) && \
            cat {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out.variants_between_alignments.bed \
                {params.work_directory}/INSIDER/VARIANT_CALLING/assemblytics_out.variants_within_alignments.bed \
                > {output.bed}
        
        test -s {output.bed} || (fail_msg "[SNK ERROR `date`] NO SV FOUND" && exit 1)

        path_ref=`readlink -f {input.ref}`
        path_genome=`readlink -f {input.genome}`
        old_path=`pwd`
        old_log=`realpath {log}.err`
        
        cd {params.work_directory}/INSIDER/VARIANT_CALLING/
        python3 ${{path_to_pipline}}/lib/python/assemblitics/filter_gap_SVs.py ${{path_ref}} ${{path_genome}} 2>> $old_log
        cd ${{old_path}}


        ##
        name_ref=`basename {input.ref}`
        name_query=`basename {input.genome}`

        echo "NUMBER OF SV DETECTED :"`cat {output.bed} | wc -l`

        printf "%s\\n" "{params.cmess} [SNK]--[`date`]--[INFO] REFERENCE : $name_ref {params.cend}"
        printf "%s\\n\\n" "{params.cmess} [SNK]--[`date`]--[INFO] GENOME : $name_query {params.cend}"

        sed -i "s/file1/${{name_ref}}/g" {output.stats}
        sed -i "s/file2/${{name_query}}/g" {output.stats}

        """


#END SV_INSIDER

