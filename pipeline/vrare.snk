###################################################################################################################################
#
# Copyright 2019-2020 IRD-CNRS-Lyon1 University
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/> or
# write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301, USA.
#
# You should have received a copy of the CeCILL-C license with this program.
# If not see <http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.txt>
#
# Intellectual property belongs to authors and IRD, CNRS, and Lyon 1 University  for all versions
# Version 0.1 written by Mourdas Mohamed
#                                                                                                                                   
####################################################################################################################################


#IMPORT
import json
import os

#Class Color
class bcolors:
    VIOLET    = '\033[95m'
    RED       = '\033[91m'
    BLUE      = '\033[94m'
    CYAN      = '\033[96m'
    GREEN     = '\033[92m'
    WARNING   = '\033[93m'
    FAIL      = '\033[91m'
    BOLD      = '\033[1m'
    END       = '\033[0m'
    UNDERLINE = '\033[4m'

def message_color(color, text):
    return color + text + bcolors.END

# Create ouput folder
os.system("mkdir -p " + config["DATA"]["WORK_DIRECTORY"] + "/log")

# Remember the parameters associated with the output folder
with open(config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/params.log", "w") as file:
    file.write(json.dumps(config))


# Get path snakefile
path_snk = ""

i = 0
while i < len(sys.argv) and path_snk == "" :
    if sys.argv[i] == "--snakefile" :
        path_snk = sys.argv[i + 1]

    i += 1
#

env="source `dirname " + path_snk + "`/define_env.sh" 

os.system("cat `dirname " + path_snk + "`/TrEMOLO.txt")


rule TSD :
    input:
        "get_TE_seq.done",
        #directory(config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/" + "ET_FIND_FA"),
        fasta_TE  = config["DATA"]["TE_DB"],
        genome    = config["DATA"]["GENOME"],

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/report_TSD.txt",
        #directory(config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/" + "TSD"),

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),
        name_genome    = config["DATA"]["GENOME"].split("/")[-1].split(".")[0],

    shell:
        #TODO broullion
        """
        rm -f report_TSD.txt;
        touch report_TSD.txt;

        echo '-----------TSD----------' ;
        mkdir -p {params.work_directory}/TSD ;
        path_to_pipline=`dirname {params.path_snk}`
        
        read_directory="{params.work_directory}/READ_FASTQ_TE"
        fasta_dir_find="{params.work_directory}/FASTA_FIND"

        NB_FILE=`ls {params.work_directory}/ET_FIND_FA | wc -l` ;
        i=0 ;
        for TE_found_fa in `ls {params.work_directory}/ET_FIND_FA/`; do

            i=$(($i + 1)) ;
            echo "[TSD:snk] $i/$NB_FILE" ;
            nameTE=`echo $TE_found_fa | grep -o "_[^_]*\." | grep -o "[^_]*" | sed 's/\.$//g'` ;
            SIZE_TSD=`grep -w "${{nameTE}}" ${{path_to_pipline}}/lib/TSD/TE_SIZE_TSD.txt || echo "NONE"`; # EX: ZAM 4 :or: -1
            echo "SIZE_TSD--1   $SIZE_TSD"
            if [[ $SIZE_TSD != "NONE" ]]; then
                SIZE_TSD=`echo $SIZE_TSD | awk '{{print $2}}'`;
                echo "SIZE_TSD = $SIZE_TSD"

                size_tsd=`grep -w "${{nameTE}}" ${{path_to_pipline}}/lib/TSD/TE_SIZE_TSD.txt || echo NONE`
                echo "TE=$nameTE size_tsd=$size_tsd  SIZE_TSD=$SIZE_TSD" 
                sh ${{path_to_pipline}}/lib/TSD/find_fq_to_fasta.sh {params.work_directory}/ET_FIND_FA/$TE_found_fa \
                   ${{read_directory}} \
                   ${{fasta_dir_find}} ;

                sh ${{path_to_pipline}}/lib/TSD/tsd_te.sh {params.work_directory}/ET_FIND_FA/$TE_found_fa \
                    ${{read_directory}} \
                    ${{fasta_dir_find}} \
                    {input.fasta_TE} 30 $SIZE_TSD ;

                mv total_results_tsd.txt {params.work_directory}/TSD/TSD_${{nameTE}}.txt
                #mv total_results_tsd_${{nameTE}}.txt {params.work_directory}/TSD/TSD_${{nameTE}}.txt ;

                sh ${{path_to_pipline}}/lib/TSD/revise_TSD.sh {input.genome} \
                    {params.work_directory}/TSD/TSD_${{nameTE}}.txt \
                    30 \
                    $SIZE_TSD ;
                    
                echo ${{nameTE}} >> report_TSD.txt
                tail -n 8 {params.work_directory}/TSD/TSD_${{nameTE}}.txt >> {params.work_directory}/report_TSD.txt
            fi;
            
        done;

        """

#Get just sequence potentiel candidate of TE
rule GET_SEQ_TE :
    input:
        "extract_read.done",
        all_te            = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        snif_seqs         = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SEQUENCE_INDEL.fasta",

    output:
        temp(touch("get_TE_seq.done")),
        directory(config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/" + "ET_FIND_FA"),


    params:
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

    shell:
        """
        mkdir -p {params.work_directory}/ET_FIND_FA ;
        
        rep="{params.work_directory}/ET_FIND_FA" 
        prefix="TE_REPORT"

        cat {input.all_te} | sed -e 's/:[-+]//g' > {params.work_directory}/tmp_TE_all.csv
        head {params.work_directory}/tmp_TE_all.csv
        awk -v dir="$rep" -v prefix="$prefix" 'BEGIN{{OFS="\t"}} NR>1 {{if($8<$9){{print $2, $8-1, $9  >> dir"/"prefix"_find_"$1".bed"}} else{{print $2, $9-1, $8  >> dir"/"prefix"_find_"$1".bed"}} }}' {params.work_directory}/tmp_TE_all.csv ;
        for i in `ls {params.work_directory}/ET_FIND_FA | grep ".bed$"`; do
            bedtools getfasta -fi {input.snif_seqs} \
               -bed {params.work_directory}/ET_FIND_FA/$i > {params.work_directory}/ET_FIND_FA/TE_REPORT_find_`echo $i \
                | grep -o "_[^_]*\." | grep -o "[^_]*" | sed 's/\.$//g'`.fasta; 
        done ;

        rm -f {params.work_directory}/ET_FIND_FA/*.bed ;
        cat {params.work_directory}/ET_FIND_FA/* > {params.work_directory}/TE_REPORT_total_find.fasta ;
        """


rule assembly_flye :
    input:
        vcf      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SV.vcf",
        read     = config["DATA"]["SAMPLE"],
        fasta_TE = config["DATA"]["TE_DB"],
        all_te   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        bln      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/BLAST_SEQUENCE_INDEL_vs_DBTE.bln",
        active   = "extract_read.done" if config["LOCAL_ASSEMBLY"]["FLYE"] else [],

    output:
        temp(touch("FLYE")),

    group: "assembly"

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

    shell:
        """
        printf "%s\n" "{params.cmess} [SNK]--[`date`] ASSEMBLY FLYE [^-^] {params.cend}"

        path_to_pipline=`dirname {params.path_snk}`

        NB_FILE=`ls {params.work_directory}/ID_READS_TE | wc -l` ;
        i=0 ;
        for read_file in `ls {params.work_directory}/ID_READS_TE`; do
            region=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]"` ;
            id=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]" | cut -d":" -f 2`

            #nb_read=`grep ":$id:" {input.all_te} | cut -f 2 | cut -d ":" -f 6`
            nb_read=`awk -v ID="$id" '{{if($3 == ID){{print $0}}}}' {input.vcf} | grep -o -e "RE=[0-9]*" | cut -d"=" -f 2`
            TE=`grep ":$id:[0-9]*:[IP]" {input.all_te} | cut -f 1 || echo "NONE"`

            i=$(($i + 1)) ;
            echo "[extract_read:snk] $read_file"
            echo "[extract_read:snk] $i/$NB_FILE : nb_read=$nb_read : id=$id" ;

            ##if it is in TE REPORT
            (! test -e {params.work_directory}/READ_FASTQ_TE/reads_$region.fastq && grep -w $id {params.work_directory}/ID_TE_SV_REPORT.txt && samtools fqidx {input.read} -r {params.work_directory}/ID_READS_TE/$read_file > {params.work_directory}/READ_FASTQ_TE/reads_$region.fq) || echo "$id NOT FOUND" ;
            
            if ! test -e {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_Flye_${{region}}.fasta; then

                if [ $nb_read -ne 1 ]; then
                    ! test -e {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq && \
                    samtools fqidx {input.read} -r {params.work_directory}/ID_READS_TE/$read_file > {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq ;
                    #rm -f no_asm.txt;

                    ! test -e {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq && \
                    python3 ${{path_to_pipline}}/lib/python/fastq_to_fastq.py \
                     {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq \
                     {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq

                    rm -f {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq

                    if ! test -e {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_Flye_${{region}}.fasta; then
                        flye -t 8 --nano-raw {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq --out-dir {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/ASM_FLYE_$region \
                            --plasmids \
                            --genome-size 500K \
                            -i 4 -m 1000 \
                          || ( echo $id >> not_assembly.txt && touch no_asm.txt )
                        
                        if ! test -e no_asm.txt; then
                            printf "[extract_read:snk] BLAST ASSEMBLY $TE"
                            ### BLAST assembly on DATABASE TE
                            
                            blastn -db {input.fasta_TE} -query {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/ASM_FLYE_$region/assembly.fasta -outfmt 6 -out {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_Flye_${{region}}.bln ;
                            echo "[extract_read:snk] BLAST ASSEMBLY $TE PHASE 2"
                            echo "#ID:$id:$TE" >> {params.work_directory}/resume.bln ;
                            cat {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_Flye_${{region}}.bln >> {params.work_directory}/resume.bln ;

                            cat {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_Flye_${{region}}.bln | sort -k 12 -n | tail -n 1 | sed -e "s/contig_*/"$region"":""FLYE:$TE"/g" >> {params.work_directory}/all_TE_assembly.bln
                        fi;
                    fi;
                fi;
            fi;
        done;

        rm -fr {params.work_directory}/WTDGB/

        echo "ASSEMBLY DONE ----------------------------------------";

        for i in `cat {params.work_directory}/all_TE_assembly.bln | cut -f 1 | cut -d":" -f 2`; do 
            qseqid=`grep ":$i:" {params.work_directory}/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv | cut -f 2`;
            if [[ `echo $qseqid` = "" ]]; then 
                qseqid=`grep ":$i:" {params.work_directory}/BLAST_SEQUENCE_INDEL_vs_DBTE.bln | cut -f 1 | head -n 1`;
                qseqid=`echo $qseqid":ONLY_ASM"`
                ET=`grep ":$i:" {params.work_directory}/BLAST_SEQUENCE_INDEL_vs_DBTE.bln | cut -f 2 | head -n 1`;
            else
                ET=`grep ":$i:" {params.work_directory}/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv | cut -f 1`;
            fi;

            qid_old=`grep ":$i:" {params.work_directory}/all_TE_assembly.bln | cut -f 1`;
            echo "[extract_read:snk] $qseqid -- $qid_old -- $ET -- $i" ;
            cat {params.work_directory}/all_TE_assembly.bln | grep ":$i:" | sed "s/$qid_old/$qseqid":"$ET/g";
        done > {params.work_directory}/all_TE_assembly_format_old.bln;

        python3 ${{path_to_pipline}}/lib/python/parse_blast_main.py {params.work_directory}/all_TE_assembly_format_old.bln {params.work_directory}/all_TE_assembly.csv ;

        NB_REGION=`ls {params.work_directory}/ID_READS_TE | wc -l` ;
        NB_READS=`ls {params.work_directory}/READ_FASTQ_TE | wc -l` ;

        rm -f reads_format.fastq;

        #if [ $NB_REGION -ne $NB_READS ]; then rm -f {params.work_directory}/resume.txt ; echo 'Error : the number of files region it is not equal the number reads files'; fi;

        echo "[extract_read:snk] $NB_READS AND $NB_REGION";

        """



rule assembly_wdtgb :
    input:
        vcf      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SV.vcf",
        read     = config["DATA"]["SAMPLE"],
        fasta_TE = config["DATA"]["TE_DB"],
        all_te   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        bln      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/BLAST_SEQUENCE_INDEL_vs_DBTE.bln",
        active   = "extract_read.done" if config["LOCAL_ASSEMBLY"]["WTDGB"] else [],

    output:
        temp(touch("WTDGB")),

    group: "assembly"

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

    shell:
        """
        printf "%s\n" "{params.cmess} [SNK]--[`date`] ASSEMBLY WTDGB [^-^] {params.cend}"

        path_to_pipline=`dirname {params.path_snk}`

        makeblastdb -in {input.fasta_TE} -dbtype nucl ;

        NB_FILE=`ls {params.work_directory}/ID_READS_TE | wc -l` ;
        i=0 ;
        for read_file in `ls {params.work_directory}/ID_READS_TE`; do
            region=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]"` ;
            id=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]" | cut -d":" -f 2`

            #nb_read=`grep ":$id:" {input.all_te} | cut -f 2 | cut -d ":" -f 6`
            nb_read=`awk -v ID="$id" '{{if($3 == ID){{print $0}}}}' {input.vcf} | grep -o -e "RE=[0-9]*" | cut -d"=" -f 2`
            TE=`grep ":$id:[0-9]*:[IP]" {input.all_te} | cut -f 1 || echo "NONE"`

            i=$(($i + 1)) ;
            echo "[extract_read:snk] $read_file"
            echo "[extract_read:snk] $i/$NB_FILE : nb_read=$nb_read : id=$id" ;

            ##if it is in TE REPORT
            (! test -e {params.work_directory}/READ_FASTQ_TE/reads_$region.fastq && grep -w $id {params.work_directory}/ID_TE_SV_REPORT.txt && samtools fqidx {input.read} -r {params.work_directory}/ID_READS_TE/$read_file > {params.work_directory}/READ_FASTQ_TE/reads_$region.fq) || echo "$id NOT FOUND" ;
            
            ! test -e {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq && \
                python3 ${{path_to_pipline}}/lib/python/fastq_to_fastq.py \
                     {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq \
                     {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq

            if ! test -e {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_WTDBG_${{region}}.fasta; then

                if [ $nb_read -ne 1 ]; then
                    ! test -e {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq && \
                    samtools fqidx {input.read} -r {params.work_directory}/ID_READS_TE/$read_file > {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq ;
                    #rm -f no_asm.txt;

                    rm -f {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq

                    if ! test -e {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_WTDBG_${{region}}.fasta; then
                        mkdir -p {params.work_directory}/WTDGB
                        wtdbg2 -i {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq -fo {params.work_directory}/WTDGB/dbg || ( echo $id >> not_assembly.txt && touch no_asm.txt )
                        wtpoa-cns -t 6 -i {params.work_directory}/WTDGB/dbg.ctg.lay.gz -fo {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_WTDBG_${{region}}.fasta || ( echo $id >> not_assembly.txt && touch no_asm.txt && echo "PROBLEMEEEE" )
                    
                        if ! test -e no_asm.txt; then
                            printf "%s\n" "[extract_read:snk] BLAST ASSEMBLY $TE"
                            ### BLAST assembly on DATABASE TE
                            
                            blastn -db {input.fasta_TE} \
                               -query {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_WTDBG_${{region}}.fasta \
                               -outfmt 6 \
                               -out {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_WTDBG_${{region}}.bln ;

                            echo "[extract_read:snk] BLAST ASSEMBLY $TE PHASE 2"
                            echo "#ID:$id:$TE" >> {params.work_directory}/resume.bln ;
                            cat {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_WTDBG_${{region}}.bln >> {params.work_directory}/resume.bln ;

                            cat {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_WTDBG_${{region}}.bln | sort -k 12 -n | tail -n 1 | sed -e "s/ctg*/$region":WTDGB:"$TE/g" >> {params.work_directory}/all_TE_assembly.bln
                        fi;
                    fi;
                fi;
            fi;
        done;

        rm -fr {params.work_directory}/WTDGB/

        echo "ASSEMBLY DONE ----------------------------------------";

        for i in `cat {params.work_directory}/all_TE_assembly.bln | cut -f 1 | cut -d":" -f 2`; do 

            qseqid=`grep ":$i:" {params.work_directory}/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv | cut -f 2`;

            if [[ `echo $qseqid` = "" ]]; then 
                qseqid=`grep ":$i:" {params.work_directory}/BLAST_SEQUENCE_INDEL_vs_DBTE.bln | cut -f 1 | head -n 1`;
                qseqid=`echo $qseqid":ONLY_ASM"`
                ET=`grep ":$i:" {params.work_directory}/BLAST_SEQUENCE_INDEL_vs_DBTE.bln | cut -f 2 | head -n 1`;
            else
                ET=`grep ":$i:" {params.work_directory}/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv | cut -f 1`;
            fi;

            qid_old=`grep ":$i:" {params.work_directory}/all_TE_assembly.bln | cut -f 1`;
            echo "[extract_read:snk] $qseqid -- $qid_old -- $ET -- $i" ;
            cat {params.work_directory}/all_TE_assembly.bln | grep ":$i:" | sed "s/$qid_old/$qseqid":"$ET/g";
        done > {params.work_directory}/all_TE_assembly_format_old.bln;

        python3 ${{path_to_pipline}}/lib/python/parse_blast_main.py {params.work_directory}/all_TE_assembly_format_old.bln {params.work_directory}/all_TE_assembly.csv ;

        NB_REGION=`ls {params.work_directory}/ID_READS_TE | wc -l` ;
        NB_READS=`ls {params.work_directory}/READ_FASTQ_TE | wc -l` ;

        rm -f reads_format.fastq;

        #if [ $NB_REGION -ne $NB_READS ]; then rm -f {params.work_directory}/resume.txt ; echo 'Error : the number of files region it is not equal the number reads files'; fi;

        echo "[extract_read:snk] $NB_READS AND $NB_REGION";

        """

#Get reads supports
rule extract_read :
    input:
        vcf      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SV.vcf",
        read     = config["DATA"]["SAMPLE"],
        fasta_TE = config["DATA"]["TE_DB"],
        all_te   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        bln      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/BLAST_SEQUENCE_INDEL_vs_DBTE.bln",

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/ID_BEST_READ_TE.txt",
        touch("extract_read.done"),

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        #Choice
        FLYE           = config["CHOICE"]["OUTSIDER_VARIANT"]["LOCAL_ASSEMBLY"]["FLYE"],
        WTDGB          = config["CHOICE"]["OUTSIDER_VARIANT"]["LOCAL_ASSEMBLY"]["WTDGB"],

        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

    shell:
        """
        printf "%s\n" "{params.cmess} [SNK]--[`date`] GET READS AND ASSEMBLY [^-^] {params.cend}"

        #rm -fr {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/
        #rm -fr {params.work_directory}/READ_FASTQ_TE

        mkdir -p {params.work_directory}/READ_FASTQ_TE ;
        mkdir -p {params.work_directory}/READ_FASTQ_TE_ASSEMBLY ;

        #BUG
        test -e {params.work_directory}/all_TE_assembly.bln && cat {params.work_directory}/all_TE_assembly.bln > {params.work_directory}/all_TE_assembly_before.bln

        path_to_pipline=`dirname {params.path_snk}`

        ##only TE found
        awk 'NR>1 {{print $2}}' {input.all_te} | cut -d":" -f 5 > {params.work_directory}/ID_TE_SV_REPORT.txt ; 

        #GET ID match BLAST
        #cat {input.bln} | cut -f 1 | sort | uniq | cut -d":" -f 5 > {params.work_directory}/ID_SV_ALL.txt

        #TEST
        cat {params.work_directory}/ID_TE_SV_REPORT.txt > {params.work_directory}/ID_SV_ALL.txt

        python3 ${{path_to_pipline}}/lib/python/extract_region_reads_vcf.py {input.vcf} \
         -d {params.work_directory}/ID_READS_TE \
         -i {params.work_directory}/ID_SV_ALL.txt > {params.work_directory}/resume.txt;
        
        makeblastdb -in {input.fasta_TE} -dbtype nucl ;

        NB_FILE=`ls {params.work_directory}/ID_READS_TE | wc -l` ;
        i=0 ;
        for read_file in `ls {params.work_directory}/ID_READS_TE`; do
            region=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]"` ;
            id=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]" | cut -d":" -f 2`

            #nb_read=`awk -v ID="$id" '{{if($3 == ID){{print $0}}}}' {input.vcf} | grep -o -e "RE=[0-9]*" | cut -d"=" -f 2`
            #nb_read=`awk -v ID="$id" '{{if($3 == ID){{print $0}}}}' {input.vcf} | grep -o -e "SUPPORT=[0-9]*" | cut -d"=" -f 2`

            nb_read=`wc -l {params.work_directory}/ID_READS_TE/$read_file | cut -d " " -f 1`
            TE=`grep ":$id:[0-9]*:[IP]" {input.all_te} | cut -f 1 || echo "NONE"`

            i=$(($i + 1)) ;
            echo "      [extract_read:snk] $read_file"
            echo "      [extract_read:snk] $i/$NB_FILE : nb_read=$nb_read : id=$id" ;

            (! test -e {params.work_directory}/READ_FASTQ_TE/reads_$region.fastq && grep -w $id {params.work_directory}/ID_TE_SV_REPORT.txt && samtools fqidx {input.read} -r {params.work_directory}/ID_READS_TE/$read_file > {params.work_directory}/READ_FASTQ_TE/reads_$region.fq) || echo "$id NOT FOUND" ;
            
            if ! test -e {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_${{region}}.fasta; then

                if [ $nb_read -ne 1 ]; then
                    ! test -e {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq && \
                    samtools fqidx {input.read} -r {params.work_directory}/ID_READS_TE/$read_file > {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq ;

                    ! test -e {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq && \
                    python3 ${{path_to_pipline}}/lib/python/fastq_to_fastq.py \
                     {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq \
                     {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq

                    rm -f {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq
                fi;
            fi;
        done;

        NB_REGION=`ls {params.work_directory}/ID_READS_TE | wc -l` ;
        NB_READS=`ls {params.work_directory}/READ_FASTQ_TE | wc -l` ;

        awk 'NR>1 {{print $2}}' {input.all_te} | cut -d ":" -f 5,8 > {params.work_directory}/ID_RD_SEQ.txt

        for i in `cat {params.work_directory}/ID_RD_SEQ.txt`; 
        do 
            ID=`echo $i | cut -d ":" -f 1`; 
            num=`echo $i | cut -d ":" -f 2`; 
            name_file=`ls {params.work_directory}/ID_READS_TE/ | grep -w "$ID"`; 

            awk -v num="$num" 'NR-1 == num' {params.work_directory}/ID_READS_TE/$name_file; 
        done > {params.work_directory}/ID_BEST_READ_TE.txt;

        echo "     [extract_read:snk] $NB_READS AND $NB_REGION";

        """


#BLASt database of TE against SV (Structural variant)
rule DETECTION_TE :
    input:
        vcf      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SV.vcf",
        fasta_TE = config["DATA"]["TE_DB"],
        bam      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME_MD.sorted.bam",

    output:
        snif_seqs = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SEQUENCE_INDEL.fasta",
        bln       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/BLAST_SEQUENCE_INDEL_vs_DBTE.bln",
        all_te    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        depth_te  = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/DEPTH_TE.csv",
        
    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,
    log:
        blastn = touch("log/blastn.log")

    shell:
        """

        printf "%s\n" "{params.cmess} [SNK]--[`date`] DETECTION_TE [^-^] {params.cend}"

        path_to_pipline=`dirname {params.path_snk}`

        # GET SEQUENCE REPORT #
        printf "%s\n" "{params.cmess} [SNK]--[`date`] GET SEQUENCES VARIANTS [^-^] {params.cend}"
        python3 ${{path_to_pipline}}/lib/python/get_seq_vcf.py -m 150 {input.vcf} {output.snif_seqs} ;


        printf "%s\n" "{params.cmess} [SNK]--[`date`] BLAST SV TO TE [^-^] {params.cend}"
        # BLAST SEQUENCE VCF on DATABASE TE #
        makeblastdb -in {input.fasta_TE} -dbtype nucl 2> {log.blastn};
        blastn -db {input.fasta_TE} -query {output.snif_seqs} -outfmt 6 -out {output.bln} 2>> {log.blastn};
        printf "%s\n" "{params.cmess} [SNK]--[`date`] BLAST DONE CHECK logfile=={log.blastn} {params.cend}"


        printf "%s\n" "{params.cmess} [SNK]--[`date`] FILTER TE BLAST [^-^] {params.cend}"
        # FILTER TE BLAST #
        python3 ${{path_to_pipline}}/lib/python/parse_blast_main.py {output.bln} {input.fasta_TE} {output.all_te} -c;


        printf "%s\n" "{params.cmess} [SNK]--[`date`] CALCUL FREQUENCE TE [^-^] {params.cend}"
        
        # CALCUL FREQUENCE #
        i=0;
        while read line; do
            
            if [ $i -ne 0 ]; then
                region=`echo $line | awk '{{print $2}}' | awk -F ":" '{{print $1":"$3"-"$3}}'`
                TE=`echo $line | awk '{{print $1}}'`

                depth=`samtools depth {input.bam} -r $region`;
                
                info_TE=`echo $line | awk 'OFS="\t"{{print $1, $2}}'`
                NB_depth=`echo $depth | awk '{{print $3}}'`
                RS=`echo $line | awk '{{print $2}}' | awk -F ":" '{{print $6}}'`

                #echo $i : $info_TE : $depth
                printf "$depth\t$(($NB_depth-$RS))\t$RS\t%.4f\t$info_TE\n" "$(((10**6 * $RS/$NB_depth) * 100))e-6" | tr "," "." >> {output.depth_te}
            else
                printf "chrom\tposition\ttotal_depth\tdepth_empty_site\tread_support\tread_support_percent\tTE\tinfo_TE\n"  > {output.depth_te}
            fi;
            
            i=$(($i+1));

        done < {output.all_te};


        printf "%s\n" "{params.cmess} [SNK]--[`date`] GET BAM TE [^-^] {params.cend}"
        # GET BAM TE
        awk 'NR>1 {{print $2":"$1}}' {output.all_te} | awk -v size="15" -F ":" 'OFS="\t"{{print $1, $3-size, $3+size, $5":"$9}}' > {params.work_directory}/POSITION_START_TE.bed
        samtools view -h -b {input.bam} -L {params.work_directory}/POSITION_START_TE.bed > {params.work_directory}/MAPPING_POSTION_TE.bam
        """


#Get Strucural Variant (vcf file)
rule svim :
    input:
        genome = config["DATA"]["GENOME"],
        bam    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME_MD.sorted.bam",

    output:
        svim = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SVIM_RESULT/variants.vcf", 
        sv   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SV.vcf",
        
    params:
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        #COLORS
        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

    log:
        touch("log/svim.log")

    shell:
        """
        printf "%s\n" "{params.cmess} [SNK]--[`date`] SVIM DETECTION VARIANT [^-^] {params.cend}"

        svim alignment --read_names \
            --insertion_sequences \
            --minimum_depth 1 {params.work_directory}/SVIM_RESULT {input.bam} {input.genome} 2> {log}

        printf "%s\n" "{params.cmess} [SNK]--[`date`] SVIM DONE CHECK logfile=={log}"

        cp {params.work_directory}/SVIM_RESULT/variants.vcf {output.sv}
        """



#Get Strucural Variant (vcf file)
# rule sniffles :
#     input:
#         config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME_MD.sorted.bam",

#     output:
#         config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SV.vcf", 
        
#     params:
#         work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

#         cfail          = bcolors.FAIL,
#         cmess          = bcolors.CYAN,
#         cend           = bcolors.END,

#     shell:
#         """
#         printf "%s\n" "{params.cmess} [SNK]--[`date`] SNIFFLES [^-^] {params.cend}"

#         sniffles --report_seq -s 1 -m {input} -v {output} -n -1 ;
#         """


#Sort and callmd
rule samtools :
    input:
        sam    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME.sam",
        genome = config["DATA"]["GENOME"],

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME_MD.sorted.bam",
        
    params:
        #DATA
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),
        
        #PARAMS
        preset_view    = config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_VIEW"]["PRESET_OPTION"],
        preset_sort    = config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_SORT"]["PRESET_OPTION"],
        preset_callmd  = config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_CALLMD"]["PRESET_OPTION"],
        
        #COLORS
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,

    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/samtools"

    shell:
        """
        printf "\n%s\n\n" "{params.cmess} [SNK]--[`date`] SAMTOOLS [^-^] {params.cend}"

        echo "---view---"
        echo "---view---" > {log}
        #samtools view -h {params.preset_view} -b {input.sam} > {input.sam}.bam 2>> {log}.err;
        run_cmd "samtools view -h {params.preset_view} -b {input.sam} | tee {input.sam}.bam" "{log}" "SAMTOOLS_VIEW" "False";

        echo "---sort---"
        echo "---sort---" >> {log}
        #samtools sort {params.preset_sort} {input.sam}.bam -o {input.sam}.sorted.bam 2>> {log}.err;
        run_cmd "samtools sort {params.preset_sort} {input.sam}.bam -o {input.sam}.sorted.bam" "{log}" "SAMTOOLS_SORT" "False";

        echo "---calmd---"
        echo "---calmd---" >> {log}
        #samtools calmd {params.preset_callmd} -b {input.sam}.sorted.bam {input.genome} > {output} 2>> {log}; #CALL MD for sniffles
        run_cmd "samtools calmd {params.preset_callmd} -b {input.sam}.sorted.bam {input.genome} | tee {output}" "SAMTOOLS_CALLMD" "False";#CALL MD for sniffles

        echo "---index---"
        echo "---index---" >> {log}
        samtools index {output} 2>> {log}.err

        printf "\n%s\n\n" "{params.cmess} [SNK]--[`date`] SAMTOOLS DONE CHECK logfile=={log}"

        rm -f {input.sam} \
        {input.sam}.bam \
        {input.sam}.sorted.bam*;
        """


#Map reads on assembly genome
rule mapping :
    input:  
        read   = config["DATA"]["SAMPLE"],
        genome = config["DATA"]["GENOME"],

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME.sam",
    
    params:
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),
        config         = json.dumps(config),

        preset         = config["PARAMS"]["OUTSIDER_VARIANT"]["MINIMAP2"]["PRESET_OPTION"] if config["PARAMS"]["OUTSIDER_VARIANT"]["MINIMAP2"]["PRESET_OPTION"] != "" else "map-ont",
        option         = config["PARAMS"]["OUTSIDER_VARIANT"]["MINIMAP2"]["OPTION"],

        env            = env, #source environnement

        #COLOR 
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/minimap2"

    shell:
        """
        {params.env};

        printf "\n%s\n\n" "{params.cmess} [SNK]--[`date`] MINIMAP2 MAPPING {params.cend}"
        #run_cmd "echo ok" "log" "sisi" "True";
        
        #minimap2 -x  {params.preset} -d {input.genome}.mmi {input.genome} 2> {log};
        run_cmd "minimap2 -x  {params.preset} -d {input.genome}.mmi {input.genome}" "{log}" "MINIMAP2_INDEX" "False";
        
        #minimap2 -ax {params.preset} {params.option} {input.genome} {input.read} > {output} 2>> {log};
        run_cmd "minimap2 -ax {params.preset} {params.option} {input.genome} {input.read}" "{log}" "MINIMAP2" "False";
        """






