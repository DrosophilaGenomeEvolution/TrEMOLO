
####
####
############# OUTSIDER VARIANT
####
####


rule TSD :
    input:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/TE_REPORT_total_find.fasta",
        #directory(config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/" + "ET_FIND_FA"),
        fasta_TE  = config["DATA"]["TE_DB"],
        genome    = config["DATA"]["GENOME"],

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/VALUES_TSD_GROUP.csv",
        #directory(config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/" + "TSD"),

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),
        name_genome    = config["DATA"]["GENOME"].split("/")[-1].split(".")[0],

        env            = env, #source environnement

        #TSD
        FILE_SIZE_TE_TSD = config["PARAMS"]["OUTSIDER_VARIANT"]["TSD"]["FILE_SIZE_TE_TSD"],
        SIZE_FLANK       = config["PARAMS"]["OUTSIDER_VARIANT"]["TSD"]["SIZE_FLANK"],

        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/TSD",


    shell:
        #TODO broullion
        """
        {params.env}

        rm -f {log}.*

        echo -e "x\ty\tfill" > {params.work_directory}/VALUES_TSD.csv;
        echo -e "x\ty\tcondition" > {params.work_directory}/VALUES_TSD_GROUP.csv

        #echo '-----------TSD----------' ;
        printf "\n%s\n\n" "{params.cmess} [SNK]--[`date`] --- TSD --- {params.cend}"
        mkdir -p {params.work_directory}/TSD ;
        path_to_pipline=`dirname {params.path_snk}`
        
        read_directory="{params.work_directory}/READ_FASTQ_TE"
        fasta_dir_find="{params.work_directory}/FASTA_FIND"

        NB_FILE=`ls {params.work_directory}/ET_FIND_FA | wc -l` ;
        i=0 ;
        for TE_found_fa in `ls {params.work_directory}/ET_FIND_FA/`; do

            ###echo "[TSD:snk] $i/$NB_FILE" ;

            nameTE=`echo $TE_found_fa | grep -o "_[^_]*\." | grep -o "[^_]*" | sed 's/\.$//g'` ;
            
            ! test -e {params.FILE_SIZE_TE_TSD} && message_fail "  Warning FILE {params.FILE_SIZE_TE_TSD} NOT FOUND\n"
            
            SIZE_TSD=`grep -w "${{nameTE}}" {params.FILE_SIZE_TE_TSD} || echo "NONE"`; # EX: ZAM 4 :or: -1
            #SIZE_TSD=`grep -w "${{nameTE}}" ${{path_to_pipline}}/lib/TSD/TE_SIZE_TSD.txt || echo "NONE"`; # EX: ZAM 4 :or: -1
            
            echo "TE : $nameTE"
            
            if [[ $SIZE_TSD != "NONE" ]]; then
                SIZE_TSD=`echo $SIZE_TSD | awk '{{print $2}}'`;
                echo "SIZE TSD : $SIZE_TSD"

                #echo "TE=$nameTE ; SIZE TSD=$SIZE_TSD" 
                
                (bash ${{path_to_pipline}}/lib/bash/load.sh &) || echo
                sh ${{path_to_pipline}}/lib/TSD/find_fq_to_fasta.sh {params.work_directory}/ET_FIND_FA/$TE_found_fa \
                   ${{read_directory}} \
                   ${{fasta_dir_find}} >> {log}.out 2>> {log}.err;

                sh ${{path_to_pipline}}/lib/TSD/tsd_te.sh {params.work_directory}/ET_FIND_FA/$TE_found_fa \
                    ${{read_directory}} \
                    ${{fasta_dir_find}} \
                    {input.fasta_TE} \
                    {params.SIZE_FLANK} \
                    $SIZE_TSD >> {log}.out 2>> {log}.err;

                mv total_results_tsd.txt {params.work_directory}/TSD/TSD_${{nameTE}}.txt
                #mv total_results_tsd_${{nameTE}}.txt {params.work_directory}/TSD/TSD_${{nameTE}}.txt ;

                sh ${{path_to_pipline}}/lib/TSD/revise_TSD.sh {input.genome} \
                    {params.work_directory}/TSD/TSD_${{nameTE}}.txt \
                    {params.SIZE_FLANK} \
                    $SIZE_TSD >> {log}.out 2>> {log}.err;
                    
                sh ${{path_to_pipline}}/lib/bash/end_load.sh;
            else
                SIZE_TSD=-1;
                #echo "SIZE_TSD = $SIZE_TSD"

                #echo "TE=$nameTE ; SIZE TSD=?" 
                
                (bash ${{path_to_pipline}}/lib/bash/load.sh &) || echo
                sh ${{path_to_pipline}}/lib/TSD/find_fq_to_fasta.sh {params.work_directory}/ET_FIND_FA/$TE_found_fa \
                   ${{read_directory}} \
                   ${{fasta_dir_find}} >> {log}.out 2>> {log}.err;

                sh ${{path_to_pipline}}/lib/TSD/tsd_te.sh {params.work_directory}/ET_FIND_FA/$TE_found_fa \
                    ${{read_directory}} \
                    ${{fasta_dir_find}} \
                    {input.fasta_TE} \
                    {params.SIZE_FLANK} \
                    $SIZE_TSD >> {log}.out 2>> {log}.err;

                mv total_results_tsd.txt {params.work_directory}/TSD/TSD_${{nameTE}}.txt
                #mv total_results_tsd_${{nameTE}}.txt {params.work_directory}/TSD/TSD_${{nameTE}}.txt ;

                if [ 0 -ne `grep "^(" {params.work_directory}/TSD/TSD_${{nameTE}}.txt | grep "OK" -c` ]; then
                    SIZE_TSD_MOY=`grep "^(" {params.work_directory}/TSD/TSD_${{nameTE}}.txt | grep "OK" | tr -d ")" | cut -d "," -f 6 | awk 'BEGIN{{somme=0}}{{somme+=$0}}END{{print int(somme/NR)}}'`
                    echo "SIZE TSD MEAN : $SIZE_TSD_MOY ;"

                    sh ${{path_to_pipline}}/lib/TSD/revise_TSD.sh {input.genome} \
                        {params.work_directory}/TSD/TSD_${{nameTE}}.txt \
                        {params.SIZE_FLANK} \
                        $SIZE_TSD_MOY >> {log}.out 2>> {log}.err;
                fi;
                    
                sh ${{path_to_pipline}}/lib/bash/end_load.sh;
            fi;
            
            TOTAL=`grep "^OK/total" {params.work_directory}/TSD/TSD_${{nameTE}}.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 2`
            NB_TSD_OK=`grep "^OK/total" {params.work_directory}/TSD/TSD_${{nameTE}}.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 1`
            NB_TSD_KO=`grep "^KO/total" {params.work_directory}/TSD/TSD_${{nameTE}}.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 1`
            NB_TSD_K_gap_O=`grep "^K-O/total" {params.work_directory}/TSD/TSD_${{nameTE}}.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 1`


            if test -e {params.work_directory}/TSD/TSD_${{nameTE}}_KO_corrected.txt ; then
                NB_TSD_OK_corrected=`grep "OK/total" {params.work_directory}/TSD/TSD_${{nameTE}}_KO_corrected.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 1`
                NB_TSD_KO_corrected=`grep "KO/total" {params.work_directory}/TSD/TSD_${{nameTE}}_KO_corrected.txt | tr -d " " | cut -d ":" -f 2 | cut -d "/" -f 1`
            else
                NB_TSD_OK_corrected=0;
                NB_TSD_KO_corrected=0;
            fi;

            OK_K_gap_O=$(($NB_TSD_OK + $NB_TSD_K_gap_O + $NB_TSD_OK_corrected));
                        
            PERCENT=$(($OK_K_gap_O*100/$TOTAL))

            KO=$(($NB_TSD_KO-$NB_TSD_OK_corrected))

            echo "TOTAL TE:$TOTAL ; TSD [OK]:$NB_TSD_OK ; TSD [K-O]:$NB_TSD_K_gap_O ; TSD [KO]:$KO ; TSD CORRECTED [KO]:$NB_TSD_OK_corrected ;"

            echo -e "${{nameTE}}\t${{PERCENT}}\tTE" >> {params.work_directory}/VALUES_TSD.csv

            echo -e "${{nameTE}}\t${{OK_K_gap_O}}\tOK" >> {params.work_directory}/VALUES_TSD_GROUP.csv
            echo -e "${{nameTE}}\t${{KO}}\tKO" >> {params.work_directory}/VALUES_TSD_GROUP.csv
            
            i=$(($i + 1)) ;
            printf "%s\\n" "{params.cmess} [SNK]--[`date`] [TSD:snk] : $i/$NB_FILE {params.cend}"
        done;

        rm -f {params.work_directory}/TE_REPORT_total_find.fasta;
        rm -f TSM_OK.txt;
        rm -fr {params.work_directory}/TSD/DIR_SEQ_TE_READ_POS
        mv DIR_SEQ_TE_READ_POS {params.work_directory}/TSD/


        """

#END TSD



#Get just sequence potentiel candidate of TE
rule GET_SEQ_TE :
    input:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/ID_BEST_READ_TE.txt",
        all_te            = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        snif_seqs         = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SEQUENCE_INDEL.fasta",

    output:
        directory(config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/" + "ET_FIND_FA"),
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/TE_REPORT_total_find.fasta",

    params:
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

    shell:
        """
        {params.env}
        mkdir -p {params.work_directory}/ET_FIND_FA ;
        
        rep="{params.work_directory}/ET_FIND_FA" 
        prefix="TE_REPORT"

        cat {input.all_te} | sed -e 's/:[-+]//g' > {params.work_directory}/tmp_TE_all.csv
        
        ###head {params.work_directory}/tmp_TE_all.csv
        
        awk -v dir="$rep" -v prefix="$prefix" 'BEGIN{{OFS="\t"}} NR>1 {{if($8<$9){{print $2, $8-1, $9  >> dir"/"prefix"_find_"$1".bed"}} else{{print $2, $9-1, $8  >> dir"/"prefix"_find_"$1".bed"}} }}' {params.work_directory}/tmp_TE_all.csv ;
        for i in `ls {params.work_directory}/ET_FIND_FA | grep ".bed$"`; do
            bedtools getfasta -fi {input.snif_seqs} \
               -bed {params.work_directory}/ET_FIND_FA/$i > {params.work_directory}/ET_FIND_FA/TE_REPORT_find_`echo $i \
                | grep -o "_[^_]*\." | grep -o "[^_]*" | sed 's/\.$//g'`.fasta; 
        done ;

        rm -f {params.work_directory}/ET_FIND_FA/*.bed ;
        cat {params.work_directory}/ET_FIND_FA/* > {params.work_directory}/TE_REPORT_total_find.fasta ;
        """


#END GET_SEQ_TE


rule assembly_flye :
    input:
        vcf      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SV.vcf",
        read     = config["DATA"]["SAMPLE"],
        fasta_TE = config["DATA"]["TE_DB"],
        all_te   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        bln      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/BLAST_SEQUENCE_INDEL_vs_DBTE.bln",
        active   = "extract_read.done"

    output:
        temp(touch("FLYE")),

    group: "assembly"

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

    shell:
        """
        printf "%s\\n" "{params.cmess} [SNK]--[`date`] LOCAL ASSEMBLY FLYE [^-^] {params.cend}"

        path_to_pipline=`dirname {params.path_snk}`

        NB_FILE=`ls {params.work_directory}/ID_READS_TE | wc -l` ;
        i=0 ;
        for read_file in `ls {params.work_directory}/ID_READS_TE`; do
            region=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]"` ;
            id=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]" | cut -d":" -f 2`

            nb_read=`grep ":$id:" {input.all_te} | cut -f 2 | cut -d ":" -f 6`
            #nb_read=`awk -v ID="$id" '{{if($3 == ID){{print $0}}}}' {input.vcf} | grep -o -e "RE=[0-9]*" | cut -d"=" -f 2`
            TE=`grep ":$id:[0-9]*:[IP]" {input.all_te} | cut -f 1 || echo "NONE"`

            i=$(($i + 1)) ;
            echo "[extract_read:snk] $read_file"
            echo "[extract_read:snk] $i/$NB_FILE : nb_read=$nb_read : id=$id" ;

            ##if it is in TE REPORT
            (! test -e {params.work_directory}/READ_FASTQ_TE/reads_$region.fastq && grep -w $id {params.work_directory}/ID_TE_SV_REPORT.txt && samtools fqidx {input.read} -r {params.work_directory}/ID_READS_TE/$read_file > {params.work_directory}/READ_FASTQ_TE/reads_$region.fq) || echo "$id NOT FOUND" ;
            
            if ! test -e {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_Flye_${{region}}.fasta; then

                if [ $nb_read -ne 1 ]; then
                    ! test -e {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq && \
                    samtools fqidx {input.read} -r {params.work_directory}/ID_READS_TE/$read_file > {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq ;
                    #rm -f no_asm.txt;

                    ! test -e {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq && \
                    python3 ${{path_to_pipline}}/lib/python/fastq_to_fastq.py \
                     {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq \
                     {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq

                    rm -f {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq

                    if ! test -e {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_Flye_${{region}}.fasta; then
                        flye -t 8 --nano-raw {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq --out-dir {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/ASM_FLYE_$region \
                            --plasmids \
                            --genome-size 500K \
                            -i 4 -m 1000 \
                          || ( echo $id >> not_assembly.txt && touch no_asm.txt )
                        
                        if ! test -e no_asm.txt; then
                            printf "[extract_read:snk] BLAST ASSEMBLY $TE"
                            ### BLAST assembly on DATABASE TE
                            
                            blastn -db {input.fasta_TE} -query {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/ASM_FLYE_$region/assembly.fasta -outfmt 6 -out {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_Flye_${{region}}.bln ;
                            echo "[extract_read:snk] BLAST ASSEMBLY $TE PHASE 2"
                            echo "#ID:$id:$TE" >> {params.work_directory}/resume.bln ;
                            cat {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_Flye_${{region}}.bln >> {params.work_directory}/resume.bln ;

                            cat {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_Flye_${{region}}.bln | sort -k 12 -n | tail -n 1 | sed -e "s/contig_*/"$region"":""FLYE:$TE"/g" >> {params.work_directory}/all_TE_assembly.bln
                        fi;
                    fi;
                fi;
            fi;
        done;

        rm -fr {params.work_directory}/WTDGB/

        echo "ASSEMBLY DONE ----------------------------------------";

        for i in `cat {params.work_directory}/all_TE_assembly.bln | cut -f 1 | cut -d":" -f 2`; do 
            qseqid=`grep ":$i:" {params.work_directory}/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv | cut -f 2`;
            if [[ `echo $qseqid` = "" ]]; then 
                qseqid=`grep ":$i:" {params.work_directory}/BLAST_SEQUENCE_INDEL_vs_DBTE.bln | cut -f 1 | head -n 1`;
                qseqid=`echo $qseqid":ONLY_ASM"`
                ET=`grep ":$i:" {params.work_directory}/BLAST_SEQUENCE_INDEL_vs_DBTE.bln | cut -f 2 | head -n 1`;
            else
                ET=`grep ":$i:" {params.work_directory}/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv | cut -f 1`;
            fi;

            qid_old=`grep ":$i:" {params.work_directory}/all_TE_assembly.bln | cut -f 1`;
            echo "[extract_read:snk] $qseqid -- $qid_old -- $ET -- $i" ;
            cat {params.work_directory}/all_TE_assembly.bln | grep ":$i:" | sed "s/$qid_old/$qseqid":"$ET/g";
        done > {params.work_directory}/all_TE_assembly_format_old.bln;

        python3 ${{path_to_pipline}}/lib/python/parse_blast_main.py {params.work_directory}/all_TE_assembly_format_old.bln {params.work_directory}/all_TE_assembly.csv ;

        NB_REGION=`ls {params.work_directory}/ID_READS_TE | wc -l` ;
        NB_READS=`ls {params.work_directory}/READ_FASTQ_TE | wc -l` ;

        rm -f reads_format.fastq;

        #if [ $NB_REGION -ne $NB_READS ]; then rm -f {params.work_directory}/resume.txt ; echo 'Error : the number of files region it is not equal the number reads files'; fi;

        echo "[extract_read:snk] $NB_READS AND $NB_REGION";

        """


#END assembly_flye



rule assembly_wdtgb :
    input:
        vcf      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SV.vcf",
        read     = config["DATA"]["SAMPLE"],
        fasta_TE = config["DATA"]["TE_DB"],
        all_te   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        bln      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/BLAST_SEQUENCE_INDEL_vs_DBTE.bln",
        active   = "extract_read.done" if config["LOCAL_ASSEMBLY"]["WTDGB"] else [],

    output:
        temp(touch("WTDGB")),

    group: "assembly"

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

    shell:
        """
        printf "%s\\n" "{params.cmess} [SNK]--[`date`] ASSEMBLY WTDGB [^-^] {params.cend}"

        path_to_pipline=`dirname {params.path_snk}`

        makeblastdb -in {input.fasta_TE} -dbtype nucl ;

        NB_FILE=`ls {params.work_directory}/ID_READS_TE | wc -l` ;
        i=0 ;
        for read_file in `ls {params.work_directory}/ID_READS_TE`; do
            region=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]"` ;
            id=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]" | cut -d":" -f 2`

            #nb_read=`grep ":$id:" {input.all_te} | cut -f 2 | cut -d ":" -f 6`
            
            nb_read=`cat {params.work_directory}/ID_READS_TE/$read_file | sort | uniq | wc -l`
            TE=`grep ":$id:[0-9]*:[IP]" {input.all_te} | cut -f 1 || echo "NONE"`

            i=$(($i + 1)) ;
            echo "[extract_read:snk] $read_file"
            echo "[extract_read:snk] $i/$NB_FILE : nb_read=$nb_read : id=$id" ;

            ##if it is in TE REPORT
            (! test -e {params.work_directory}/READ_FASTQ_TE/reads_$region.fastq && grep -w $id {params.work_directory}/ID_TE_SV_REPORT.txt && samtools fqidx {input.read} -r {params.work_directory}/ID_READS_TE/$read_file > {params.work_directory}/READ_FASTQ_TE/reads_$region.fq) || echo "$id NOT FOUND" ;
            
            ! test -e {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq && \
                python3 ${{path_to_pipline}}/lib/python/fastq_to_fastq.py \
                     {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq \
                     {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq

            if ! test -e {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_WTDBG_${{region}}.fasta; then

                if [ $nb_read -ne 1 ]; then
                    ! test -e {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq && \
                    samtools fqidx {input.read} -r {params.work_directory}/ID_READS_TE/$read_file > {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq ;
                    #rm -f no_asm.txt;

                    rm -f {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq

                    if ! test -e {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_WTDBG_${{region}}.fasta; then
                        mkdir -p {params.work_directory}/WTDGB
                        wtdbg2 -i {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq -fo {params.work_directory}/WTDGB/dbg || ( echo $id >> not_assembly.txt && touch no_asm.txt )
                        wtpoa-cns -t 6 -i {params.work_directory}/WTDGB/dbg.ctg.lay.gz -fo {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_WTDBG_${{region}}.fasta || ( echo $id >> not_assembly.txt && touch no_asm.txt && echo "PROBLEMEEEE" )
                    
                        if ! test -e no_asm.txt; then
                            printf "%s\n" "[extract_read:snk] BLAST ASSEMBLY $TE"
                            ### BLAST assembly on DATABASE TE
                            
                            blastn -db {input.fasta_TE} \
                               -query {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_WTDBG_${{region}}.fasta \
                               -outfmt 6 \
                               -out {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_WTDBG_${{region}}.bln ;

                            echo "[extract_read:snk] BLAST ASSEMBLY $TE PHASE 2"
                            echo "#ID:$id:$TE" >> {params.work_directory}/resume.bln ;
                            cat {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_WTDBG_${{region}}.bln >> {params.work_directory}/resume.bln ;

                            cat {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/assembly_WTDBG_${{region}}.bln | sort -k 12 -n | tail -n 1 | sed -e "s/ctg*/$region":WTDGB:"$TE/g" >> {params.work_directory}/all_TE_assembly.bln
                        fi;
                    fi;
                fi;
            fi;
        done;

        rm -fr {params.work_directory}/WTDGB/

        echo "ASSEMBLY DONE ----------------------------------------";

        for i in `cat {params.work_directory}/all_TE_assembly.bln | cut -f 1 | cut -d":" -f 2`; do 

            qseqid=`grep ":$i:" {params.work_directory}/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv | cut -f 2`;

            if [[ `echo $qseqid` = "" ]]; then 
                qseqid=`grep ":$i:" {params.work_directory}/BLAST_SEQUENCE_INDEL_vs_DBTE.bln | cut -f 1 | head -n 1`;
                qseqid=`echo $qseqid":ONLY_ASM"`
                ET=`grep ":$i:" {params.work_directory}/BLAST_SEQUENCE_INDEL_vs_DBTE.bln | cut -f 2 | head -n 1`;
            else
                ET=`grep ":$i:" {params.work_directory}/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv | cut -f 1`;
            fi;

            qid_old=`grep ":$i:" {params.work_directory}/all_TE_assembly.bln | cut -f 1`;
            echo "[extract_read:snk] $qseqid -- $qid_old -- $ET -- $i" ;
            cat {params.work_directory}/all_TE_assembly.bln | grep ":$i:" | sed "s/$qid_old/$qseqid":"$ET/g";
        done > {params.work_directory}/all_TE_assembly_format_old.bln;

        python3 ${{path_to_pipline}}/lib/python/parse_blast_main.py {params.work_directory}/all_TE_assembly_format_old.bln {params.work_directory}/all_TE_assembly.csv ;

        NB_REGION=`ls {params.work_directory}/ID_READS_TE | wc -l` ;
        NB_READS=`ls {params.work_directory}/READ_FASTQ_TE | wc -l` ;

        rm -f reads_format.fastq;

        #if [ $NB_REGION -ne $NB_READS ]; then rm -f {params.work_directory}/resume.txt ; echo 'Error : the number of files region it is not equal the number reads files'; fi;

        echo "[extract_read:snk] $NB_READS AND $NB_REGION";

        """



#END assembly_wdtgb




#Get reads supports
rule extract_read :
    input:
        all_te   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        bln      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/BLAST_SEQUENCE_INDEL_vs_DBTE.bln",
        vcf      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SV.vcf",
        read     = config["DATA"]["SAMPLE"],
        fasta_TE = config["DATA"]["TE_DB"],

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/ID_BEST_READ_TE.txt",
        #touch("extract_read.done"),

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        #Choice
        FLYE           = config["CHOICE"]["OUTSIDER_VARIANT"]["LOCAL_ASSEMBLY"]["FLYE"],
        WTDGB          = config["CHOICE"]["OUTSIDER_VARIANT"]["LOCAL_ASSEMBLY"]["WTDGB"],

        CHROM_KEEP     = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["CHROM_KEEP"],

        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

    shell:
        """
        {params.env}
        printf "%s\\n" "{params.cmess} [SNK]--[`date`] GET READS AND ASSEMBLY [^-^] {params.cend}"

        #rm -fr {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/
        #rm -fr {params.work_directory}/READ_FASTQ_TE

        mkdir -p {params.work_directory}/READ_FASTQ_TE ;
        mkdir -p {params.work_directory}/READ_FASTQ_TE_ASSEMBLY ;

        #BUG
        test -e {params.work_directory}/all_TE_assembly.bln && \
        cat {params.work_directory}/all_TE_assembly.bln > {params.work_directory}/all_TE_assembly_before.bln

        path_to_pipline=`dirname {params.path_snk}`

        ##only TE found
        awk 'NR>1 {{print $2}}' {input.all_te} | cut -d":" -f 5 > {params.work_directory}/ID_TE_SV_REPORT.txt ; 

        python3 ${{path_to_pipline}}/lib/python/extract_region_reads_vcf.py -c {params.CHROM_KEEP} \
          {input.vcf} \
         -d {params.work_directory}/ID_READS_TE \
         -i {params.work_directory}/ID_TE_SV_REPORT.txt ;

        makeblastdb -in {input.fasta_TE} -dbtype nucl ;

        NB_FILE=`ls {params.work_directory}/ID_READS_TE | wc -l` ;
        i=0 ;
        for read_file in `ls {params.work_directory}/ID_READS_TE`; do

            region=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]"` ;
            
            if ! test -e {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq; then
                ####echo "REGION ------- {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq"

                id=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]" | cut -d":" -f 2`

                nb_read=`cat {params.work_directory}/ID_READS_TE/$read_file | sort | uniq | wc -l`
                TE=`grep ":$id:[0-9]*:[IP]" {input.all_te} | cut -f 1 || echo "NONE"`

                printf "%s\\n" "      {params.cmess} [SNK]--[`date`] [extract_read:snk] $read_file {params.cend}"
                printf "%s\\n" "      {params.cmess} [SNK]--[`date`] [extract_read:snk] [extract_read:snk] $i/$NB_FILE : nb_read=$nb_read : id=$id {params.cend}"
                
                (grep -w $id {params.work_directory}/ID_TE_SV_REPORT.txt && \
                samtools fqidx {input.read} -r {params.work_directory}/ID_READS_TE/$read_file > {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq) || echo "$id NOT FOUND ---------------------" ;

                ## FORMAT FASTQ
                test -e {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq && \
                python3 ${{path_to_pipline}}/lib/python/fastq_to_fastq.py \
                 {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq \
                 {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq

                (test -e {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq && echo "[OK]---" ) || echo "[NOOOOOOOOO]]----------------------------------"
                
                rm -f {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq
            fi;

            i=$(($i + 1));
        done;

        printf "%s\\n" "{params.cmess} [SNK]--[`date`] EXTRACT DONE ! {params.cend}"

        NB_REGION=`ls {params.work_directory}/ID_READS_TE | wc -l` ;
        NB_READS=`ls {params.work_directory}/READ_FASTQ_TE | wc -l` ;

        ####echo "     [extract_read:snk] $NB_READS AND $NB_REGION";

        ## GET BEST ID TE
        awk 'NR>1 {{print $2}}' {input.all_te} | cut -d ":" -f 5,8 > {params.work_directory}/tmp_ID_RD_SEQ.txt

        grep -w -f {params.work_directory}/ID_TE_SV_REPORT.txt {params.work_directory}/tmp_ID_RD_SEQ.txt > {params.work_directory}/ID_RD_SEQ.txt

        for i in `cat {params.work_directory}/ID_RD_SEQ.txt`; 
        do 
            ID=`echo $i | cut -d ":" -f 1`; 
            num=`echo $i | cut -d ":" -f 2`; 
            name_file=`ls {params.work_directory}/ID_READS_TE/ | grep -w "$ID"`; 

            awk -v num="$num" 'NR-1 == num' {params.work_directory}/ID_READS_TE/$name_file > {params.work_directory}/ID_BEST_READ_TE.txt;

        done 

        rm -f {params.work_directory}/ID_RD_SEQ.txt

        """



#END extract_read


#BLASt database of TE against SV (Structural variant)
rule DETECTION_TE :
    input:
        vcf      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SV.vcf",
        fasta_TE = config["DATA"]["TE_DB"],
        bam      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME_MD.sorted.bam",

    output:
        snif_seqs = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SEQUENCE_INDEL.fasta",
        bln       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/BLAST_SEQUENCE_INDEL_vs_DBTE.bln",
        all_te    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        depth_te  = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/DEPTH_TE.csv",
        
    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        CHROM_KEEP     = config["PARAMS"]["OUTSIDER_VARIANT"]["TE_DETECTION"]["CHROM_KEEP"],


        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,
    log:
        blastn = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/blastn"


    shell:
        """
        {params.env}
        printf "%s\\n" "{params.cmess} [SNK]--[`date`] DETECTION_TE [^-^] {params.cend}"

        path_to_pipline=`dirname {params.path_snk}`

        # GET SEQUENCE REPORT #
        printf "%s\\n" "{params.cmess} [SNK]--[`date`] GET SEQUENCES VARIANTS [^-^] {params.cend}"
        python3 ${{path_to_pipline}}/lib/python/get_seq_vcf.py -m 150 {input.vcf} {output.snif_seqs} -c {params.CHROM_KEEP} ;

        cp {output.snif_seqs} {params.work_directory}/tmp_seq.fasta

        printf "%s\\n" "{params.cmess} [SNK]--[`date`] BLAST SV TO TE [^-^] {params.cend}"
        # BLAST SEQUENCE VCF on DATABASE TE #
        makeblastdb -in {input.fasta_TE} -dbtype nucl 2> {log.blastn}.err;
        blastn -db {input.fasta_TE} -query {output.snif_seqs} -outfmt 6 -out {output.bln} 2>> {log.blastn}.err;
        printf "%s\\n" "{params.cmess} [SNK]--[`date`] BLAST DONE CHECK logfile=={log.blastn} {params.cend}"

        cp {output.bln} {params.work_directory}/tmp_blast.bln

        printf "%s\\n" "{params.cmess} [SNK]--[`date`] FILTER TE BLAST [^-^] {params.cend}"
        # FILTER TE BLAST #
        python3 ${{path_to_pipline}}/lib/python/parse_blast_main.py {output.bln} {input.fasta_TE} {output.all_te} -c --combine_name {params.work_directory}/COMBINE_TE.csv;

        samtools index {input.bam} #2> {log}.err

        printf "%s\\n" "{params.cmess} [SNK]--[`date`] CALCUL FREQUENCE TE [^-^] {params.cend}"
        
        # CALCUL FREQUENCE #
        i=0;
        while read line; do
            
            if [ $i -ne 0 ]; then
                region=`echo $line | awk '{{print $2}}' | awk -F ":" '{{print $1":"$3"-"$3}}'`
                depth=`samtools depth {input.bam} -r $region`;
                NB_depth=`echo $depth | awk '{{print $3}}'`

                TE=`echo $line | awk '{{print $1}}'`
                info_TE=`echo $line | awk 'OFS="\t"{{print $1, $2}}'`
                RS=`echo $line | awk '{{print $2}}' | awk -F ":" '{{print $6}}'`

                if [ -n "$depth" ]; then
                    ###echo "$i : $info_TE : $depth : RS=$RS : NB_depth=$NB_depth"
                    printf "$depth\t$(($NB_depth-$RS))\t$RS\t%.4f\t$info_TE\n" "$(((10**6 * $RS/$NB_depth) * 100))e-6" | tr "," "." >> {output.depth_te}
                else
                    printf "$depth\t$(($NB_depth-$RS))\t$RS\t%.4f\t${{info_TE}}|ERROR\n" "0" | tr "," "." >> {output.depth_te}
                    message_fail "ERROR FOR ${{info_TE}} \n ERROR GETTING DEPTH YOU NEED TO RECONSTRUCT YOUR BAM FILE\n";
                fi;

                
            else
                printf "chrom\tposition\ttotal_depth\tdepth_empty_site\tread_support\tread_support_percent\tTE\tinfo_TE\n" Â > {output.depth_te}
            fi;
            
            i=$(($i+1));

        done < {output.all_te};

        printf "%s\\n" "{params.cmess} [SNK]--[`date`] GET BAM TE [^-^] {params.cend}"
        # GET BAM TE
        awk 'NR>1 {{print $2":"$1}}' {output.all_te} | awk -v size="15" -F ":" 'OFS="\t"{{print $1, $3-size, $3+size, $5":"$9}}' > {params.work_directory}/POSITION_START_TE.bed
        samtools view -h -b {input.bam} -L {params.work_directory}/POSITION_START_TE.bed > {params.work_directory}/MAPPING_POSTION_TE.bam
        """



#END DETECTION_TE



#Get Strucural Variant (vcf file)
rule svim :
    input:
        genome = config["DATA"]["GENOME"],
        bam    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME_MD.sorted.bam",

    output:
        svim = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SVIM_RESULT/variants.vcf", 
        sv   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SV.vcf",
        
    params:
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        #COLORS
        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/svim"


    shell:
        """
        {params.env}
        printf "%s\\n" "{params.cmess} [SNK]--[`date`] SVIM DETECTION VARIANT [^-^] {params.cend}"

        # svim alignment --read_names \
        #      --insertion_sequences \
        #      --minimum_depth 1 {params.work_directory}/SVIM_RESULT {input.bam} {input.genome} 2> {log}.err

        ##printf "%s\\n" "{params.cmess} [SNK]--[`date`] SVIM DONE CHECK logfile=={log} {params.cend}"

        samtools index {input.bam} 2> {log}.err

        run_cmd "svim alignment --read_names --insertion_sequences --minimum_depth 1 {params.work_directory}/SVIM_RESULT {input.bam} {input.genome}" "{log}" "SVIM" "False";

        cp {params.work_directory}/SVIM_RESULT/variants.vcf {output.sv}
        """

#END svim



#Get Strucural Variant (vcf file)
rule sniffles :
    input:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME_MD.sorted.bam",

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SV.vcf", 
        
    params:
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/sniffles",

    shell:
        """
        {params.env}
        printf "%s\\n" "{params.cmess} [SNK]--[`date`] SNIFFLES [^-^] {params.cend}"

        samtools index {input} 2> {log}.err

        #sniffles --report-seq -s 1 -m {input} -v {output} -n -1 ;
        run_cmd "sniffles --report-seq -s 1 -m {input} -v {output} -n -1" "{log}" "SNIFFLES" "False";


        """

#END sniffles



#Sort and callmd
rule samtools :
    input:
        sam    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME.sam",
        genome = config["DATA"]["GENOME"],

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME_MD.sorted.bam",
        
    params:
        #DATA
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),
        env            = env, #source environnement
        
        #PARAMS
        preset_view    = config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_VIEW"]["PRESET_OPTION"],
        preset_sort    = config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_SORT"]["PRESET_OPTION"],
        preset_callmd  = config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_CALLMD"]["PRESET_OPTION"],
        
        #COLORS
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,

    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/samtools"

    shell:
        """
        {params.env}
        printf "\n%s\n\n" "{params.cmess} [SNK]--[`date`] SAMTOOLS [^-^] {params.cend}"

        echo "---view---" | tee {log}.out
        #samtools view -h {params.preset_view} -b {input.sam} > {input.sam}.bam 2>> {log}.err;
        run_cmd "samtools view -h {params.preset_view} -b {input.sam} | tee {input.sam}.bam" "{log}" "SAMTOOLS_VIEW" "False";

        echo "---sort---" | tee -a {log}.out
        #samtools sort {params.preset_sort} {input.sam}.bam -o {input.sam}.sorted.bam 2>> {log}.err;
        run_cmd "samtools sort {params.preset_sort} {input.sam}.bam -o {input.sam}.sorted.bam" "{log}" "SAMTOOLS_SORT" "False";

        echo "---calmd---" | tee -a {log}.out
        #samtools calmd {params.preset_callmd} -b {input.sam}.sorted.bam {input.genome} > {output} 2>> {log}; #CALL MD for sniffles
        run_cmd "samtools calmd {params.preset_callmd} -b {input.sam}.sorted.bam {input.genome} | tee {output}" "{log}" "SAMTOOLS_CALLMD" "False";#CALL MD for sniffles

        printf "\n%s\n\n" "{params.cmess} [SNK]--[`date`] SAMTOOLS DONE CHECK logfile=={log}"

        rm -f {input.sam} \
        {input.sam}.bam \
        {input.sam}.sorted.bam*;

        """


#END samtools




#Map reads on assembly genome
rule mapping :
    input:  
        read   = config["DATA"]["SAMPLE"],
        genome = config["DATA"]["GENOME"],

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME.sam",
    
    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),
        config         = json.dumps(config),

        preset         = config["PARAMS"]["OUTSIDER_VARIANT"]["MINIMAP2"]["PRESET_OPTION"] if config["PARAMS"]["OUTSIDER_VARIANT"]["MINIMAP2"]["PRESET_OPTION"] != "" else "map-ont",
        option         = config["PARAMS"]["OUTSIDER_VARIANT"]["MINIMAP2"]["OPTION"],

        env            = env, #source environnement


        #COLOR 
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/minimap2"

    shell:
        """
        {params.env};
        path_to_pipline=`dirname {params.path_snk}`

        printf "\n%s\n\n" "{params.cmess} [SNK]--[`date`] MINIMAP2 MAPPING {params.cend}"
        
        #minimap2 -x  {params.preset} -d {input.genome}.mmi {input.genome} 2> {log};
        run_cmd "minimap2 -x  {params.preset} -d {input.genome}.mmi {input.genome}" "{log}" "MINIMAP2_INDEX" "False" ;
        
        #minimap2 -ax {params.preset} {params.option} {input.genome} {input.read} > {output} 2>> {log};
        
       (bash ${{path_to_pipline}}/lib/bash/load.sh &) || echo
        run_cmd "minimap2 -ax {params.preset} {params.option} {input.genome} {input.read} | tee {output}" "{log}" "MINIMAP2" "False"; 
        sh ${{path_to_pipline}}/lib/bash/end_load.sh;

        """


#END mapping


####
####
############# INSIDER VARIANT
####
####



rule TE_INSIDER:
    input:  
        ref   = config["DATA"]["REFERENCE"],
        query = config["DATA"]["GENOME"],
        sam   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/pm_against_ref.sam",
        delta = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/pm_against_ref.sam.delta",
        bed   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/assemblytics_out.Assemblytics_structural_variants.bed",
        stats = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/assemblytics_out.Assemblytics_assembly_stats.txt",

        fasta_TE = config["DATA"]["TE_DB"],


    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/TE_INSIDER/INSERTION.csv",


    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env,
        
        #COLOR 
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/TE_INSIDER",

    shell:
        """
        #### STEP 2 GET TE
        {params.env}
        path_to_pipline=`dirname {params.path_snk}`
        
        mkdir -p {params.work_directory}/TE_INSIDER/

        array_type=( "INSERTION" "Repeat_expansion" "Tandem_expansion" );
        for type in "${{array_type[@]}}"
        do
            echo "type=$type";
            grep -i $type {input.bed} | awk '{{print $10":"$4}}' | awk -v type="$type" -F ":" 'OFS="\t"{{split($2, a, "-"); print $1 , a[1], a[2], $4":"$3":"type}}' > {params.work_directory}/TE_INSIDER/${{type}}.bed
            
            bedtools getfasta -fi {input.query} -bed {params.work_directory}/TE_INSIDER/${{type}}.bed -name > {params.work_directory}/TE_INSIDER/${{type}}_SEQ.fasta
        done;

        cat {params.work_directory}/TE_INSIDER/Tandem_expansion_SEQ.fasta {params.work_directory}/TE_INSIDER/Repeat_expansion_SEQ.fasta {params.work_directory}/TE_INSIDER/INSERTION_SEQ.fasta > {params.work_directory}/TE_INSIDER/INSERTION_SEQ_ALL.fasta
        cat {params.work_directory}/TE_INSIDER/INSERTION_SEQ_ALL.fasta > {params.work_directory}/TE_INSIDER/INSERTION_SEQ.fasta

        array_type_deletion=( "DELETION" "Repeat_contraction" "Tandem_contraction" );
        for type in "${{array_type_deletion[@]}}"
        do
            grep -i ${{type}}  {input.bed} | awk  -v type="$type" 'OFS="\t"{{print $1, $2, $3, $4":"$6":"type}}' > {params.work_directory}/TE_INSIDER/${{type}}.bed

            bedtools getfasta -fi {input.ref}  -bed {params.work_directory}/TE_INSIDER/${{type}}.bed -name > {params.work_directory}/TE_INSIDER/${{type}}_SEQ.fasta
        done;

        cat {params.work_directory}/TE_INSIDER/Tandem_contraction_SEQ.fasta {params.work_directory}/TE_INSIDER/Repeat_contraction_SEQ.fasta {params.work_directory}/TE_INSIDER/DELETION_SEQ.fasta > {params.work_directory}/TE_INSIDER/DELETION_SEQ_ALL.fasta
        cat {params.work_directory}/TE_INSIDER/DELETION_SEQ_ALL.fasta > {params.work_directory}/TE_INSIDER/DELETION_SEQ.fasta


        array_type=( "INSERTION" "Repeat_expansion" "Tandem_expansion" "DELETION" "Repeat_contraction" "Tandem_contraction" )
        for type in "${{array_type[@]}}"
        do
            echo "type=$type";

            makeblastdb -in {input.fasta_TE} -dbtype nucl  2> {log}.err 1> {log}.out;
            blastn -db {input.fasta_TE} \
            -query {params.work_directory}/TE_INSIDER/${{type}}_SEQ.fasta \
            -outfmt 6 \
            -out {params.work_directory}/TE_INSIDER/${{type}}.bln 2> {log}.err 1> {log}.out;
            
            test -s {params.work_directory}/TE_INSIDER/${{type}}.bln && \
                python3 ${{path_to_pipline}}/lib/python/global_sv.py --combine_name {params.work_directory}/TE_INSIDER/${{type}}_COMBINE_TE.csv \
                    {params.work_directory}/TE_INSIDER/${{type}}.bln \
                    {input.fasta_TE} \
                    {params.work_directory}/TE_INSIDER/${{type}}.csv 

            awk 'NR>1{{print $1}}' {params.work_directory}/TE_INSIDER/${{type}}.csv | sort | uniq -c | sort -k 1 -n | \
                awk 'BEGIN{{print "x\ty\tz"}} OFS="\t"{{print "", $2, $1}}' > {params.work_directory}/TE_INSIDER/${{type}}_COUNT_TE.csv
        done;

        cd {params.work_directory}/TE_INSIDER/
        
        rm -f Repeat*
        rm -f Tandem*
        rm -f *SEQ_ALL.fasta

        """


#END TE_INSIDER



rule sv_insider:
    input:  
        ref         = config["DATA"]["REFERENCE"],
        genome      = config["DATA"]["GENOME"],

    output:
        sam   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/pm_against_ref.sam",
        delta = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/pm_against_ref.sam.delta",
        bed   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/assemblytics_out.Assemblytics_structural_variants.bed",
        stats = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/INSIDER/assemblytics_out.Assemblytics_assembly_stats.txt",


    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env,

        #COLOR 
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,

    shell:
        """

        #### STEP 1 GET SV
        mkdir -p {params.work_directory}/INSIDER/
        mkdir -p {params.work_directory}/log/
        #cd {params.work_directory}/INSIDER/

        path_to_pipline=`dirname {params.path_snk}`

        minimap2 -ax asm5 --cs -t3 {input.ref} {input.genome} > {output.sam} 2> {params.work_directory}/log/pm_contigs_against_ref.sam.log
        
        python3 ${{path_to_pipline}}/lib/python/sam2delta.py {output.sam};
        

        python3 ${{path_to_pipline}}/lib/python/Assemblytics_uniq_anchor.py \
        --delta {output.delta} \
        --unique-length 10000 \
        --out {params.work_directory}/INSIDER/assemblytics_out \
        --keep-small-uniques;


        perl ${{path_to_pipline}}/lib/perl/Assemblytics_between_alignments.pl \
        {params.work_directory}/INSIDER/assemblytics_out.coords.tab \
        50 \
        10000 \
        all-chromosomes \
        exclude-longrange \
        bed > {params.work_directory}/INSIDER/assemblytics_out.variants_between_alignments.bed;


        python3 ${{path_to_pipline}}/lib/python/Assemblytics_within_alignment.py \
        --delta {params.work_directory}/INSIDER/assemblytics_out.Assemblytics.unique_length_filtered_l10000.delta \
        --min 50 > {params.work_directory}/INSIDER/assemblytics_out.variants_within_alignments.bed;


        cat {params.work_directory}/INSIDER/assemblytics_out.variants_between_alignments.bed \
        {params.work_directory}/INSIDER/assemblytics_out.variants_within_alignments.bed \
        > {output.bed}
        
        path_ref=`readlink -f {input.ref}`
        path_genome=`readlink -f {input.genome}`
        
        old_path=`pwd`
        
        cd {params.work_directory}/INSIDER/
        python3 ${{path_to_pipline}}/lib/python/filter_gap_SVs.py ${{path_ref}} ${{path_genome}}
        cd ${{old_path}}


        ## delet '/' for command sed
        name_ref=`echo {input.ref} | grep "[/]*[^/]*$" -o | tr -d "/"`
        name_query=`echo {input.genome} | grep "[/]*[^/]*$" -o | tr -d "/"`


        echo " -- $name_ref ; -- $name_query ;"


        sed -i "s/file1/${{name_ref}}/g" {output.stats}
        sed -i "s/file2/${{name_query}}/g" {output.stats}

        ##mv assemblytics_out* {params.work_directory}/INSIDER/

        """


#END sv_insider



####
####
############# ASSEMBLY GENOME
####
####

#TODO?????????
rule ragoo :
    input:  
        read          = config["DATA"]["SAMPLE"],
        assembly_flye = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/FLYE_OUT/assembly.fasta",

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME.sam",
    
    params:
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),
        config         = json.dumps(config),

        preset         = config["PARAMS"]["ASSEMBLY_GENOME"]["FLYE"]["PRESET_OPTION"] if config["PARAMS"]["ASSEMBLY_GENOME"]["FLYE"]["PRESET_OPTION"] != "" else "--nano-raw",
        option         = config["PARAMS"]["ASSEMBLY_GENOME"]["FLYE"]["OPTIONS"],

        #COLOR 
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
    shell:
        """
        printf "%s\\n" "{params.cmess} [SNK]--[`date`] RAGOO {params.cend}"

        ragoo.py 

        """


#END ragoo




rule polishing :
    input:  
        read          = config["DATA"]["SAMPLE"],
        assembly_flye = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/FLYE_OUT/assembly.fasta",

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME.sam",
    
    params:
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),
        config         = json.dumps(config),

        preset         = config["PARAMS"]["ASSEMBLY_GENOME"]["FLYE"]["PRESET_OPTION"] if config["PARAMS"]["ASSEMBLY_GENOME"]["FLYE"]["PRESET_OPTION"] != "" else "--nano-raw",
        option         = config["PARAMS"]["ASSEMBLY_GENOME"]["FLYE"]["OPTIONS"],

        #COLOR 
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
    shell:
        """
        printf "%s\\n" "{params.cmess} [SNK]--[`date`] RACON POLISHING {params.cend}"

        j={input.assembly_flye}
        base="base"
        for round in {1..4}
            do
                echo -e "\t$base round $round"
                minimap2 -t 20 -x map-ont -t 20 $j {input.read} | gzip -1 > {params.work_directory}/tempData/$base.$round.paf.gz
                racon -t 20 {input.read} {params.work_directory}/tempData/$base.$round.paf.gz $j > {params.work_directory}/tempData/tempRef.$round.fasta
                j={params.work_directory}/tempData/tempRef.$round.fasta
                #rm -rf {params.work_directory}/tempData/$base.$round.paf.gz
            done

        #rm -fr tempData

        printf "%s\n" "{params.cmess} [SNK]--[`date`]   STATISTICS {params.cend}"
        assembly-stats -t {params.work_directory}/tempData/*.fasta > {params.work_directory}/Stats/polisehdGlobalStats.csv


        """


#END polishing


#TODO
rule flye_genome :
    input:  
        read   = config["DATA"]["SAMPLE"],

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/FLYE_OUT/assembly.fasta",
    
    params:
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),
        config         = json.dumps(config),

        preset         = config["PARAMS"]["ASSEMBLY_GENOME"]["FLYE"]["PRESET_OPTION"] if config["PARAMS"]["ASSEMBLY_GENOME"]["FLYE"]["PRESET_OPTION"] != "" else "--nano-raw",
        option         = config["PARAMS"]["ASSEMBLY_GENOME"]["FLYE"]["OPTIONS"],

        #COLOR 
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
    shell:
        """
        printf "%s\\n" "{params.cmess} [SNK]--[`date`] ASSEMBLY READS WITH FLYE {params.cend}"

        echo "VERSION FLYE " `flye -v`; 
        flye {params.option} {params.preset} {input.read} --out-dir {params.work_directory}/FLYE_OUT 

        """


#END flye_genome








