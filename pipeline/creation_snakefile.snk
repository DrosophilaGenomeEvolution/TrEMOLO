###################################################################################################################################
#
# Copyright 2019-2020 IRD-CNRS-Lyon1 University
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/> or
# write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301, USA.
#
# You should have received a copy of the CeCILL-C license with this program.
# If not see <http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.txt>
#
# Intellectual property belongs to authors and IRD, CNRS, and Lyon 1 University  for all versions
# Version 0.1 written by Mourdas Mohamed
#                                                                                                                                   
####################################################################################################################################


#IMPORT
import json
import os

#Class Color
class bcolors:
    VIOLET    = '\033[95m'
    RED       = '\033[91m'
    BLUE      = '\033[94m'
    CYAN      = '\033[96m'
    GREEN     = '\033[92m'
    WARNING   = '\033[93m'
    FAIL      = '\033[91m'
    BOLD      = '\033[1m'
    END       = '\033[0m'
    UNDERLINE = '\033[4m'


def message_color(color, text):
    return color + text + bcolors.END



# Create ouput folder
os.system("mkdir -p " + config["DATA"]["WORK_DIRECTORY"])


# Remember the parameters associated with the output folder
with open(config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/params.log", "w") as file:
    file.write(json.dumps(config))


# Get path snakefile
path_snk = ""


i = 0
while i < len(sys.argv) and path_snk == "" :
    if sys.argv[i] == "--snakefile" :
        if "/" in sys.argv[i + 1] :
            path_snk = sys.argv[i + 1]
        else :
            path_snk = "./" + sys.argv[i + 1]

    i += 1
#

name_configfil = ""

i = 0
while i < len(sys.argv) and name_configfil == "" :
    if sys.argv[i] == "--configfile" :
        name_configfil = sys.argv[i + 1]

    i += 1
#
os.system("cp " + name_configfil + " " + config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/params.yaml")

#CMD DEFINE ENV
env="source `dirname " + path_snk + "`/define_env.sh" 

#SHOW TITLE
os.system("cat `dirname " + path_snk + "`/TrEMOLO.txt")

# onerror:
#     print("An error occurred")
onsuccess:
     print("Workflow finished, no error")
     shell("rm -fr tmp_snk/;")


#Map reads on assembly genome
rule create_snake_file :
    input:  

    output:
        temp("/".join(str(path_snk).split("/")[:-1]) + "/Snakefile"),
        temp("tmp_snk/tmp_end_pipeline.end"),
    
    params:
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),
        config         = json.dumps(config),

        path_snk       = path_snk,
        name_configfil = name_configfil,

        env            = env, #source environnement

        #CHOICE
        call_sv             = config["CHOICE"]["OUTSIDER_VARIANT"]["CALL_SV"],
        choice_outsider_sv  = config["CHOICE"]["PIPELINE"]["OUTSIDER_VARIANT"],
        #choice_asm          = config["CHOICE"]["PIPELINE"]["ASSEMBLY_GENOME"],
        choice_insider_sv   = config["CHOICE"]["PIPELINE"]["INSIDER_VARIANT"],

        LC_ASM_FLYE         = config["CHOICE"]["OUTSIDER_VARIANT"]["LOCAL_ASSEMBLY"]["FLYE"],
        LC_ASM_WTDGB        = config["CHOICE"]["OUTSIDER_VARIANT"]["LOCAL_ASSEMBLY"]["WTDGB"],

        INTEGRATE_TE_TO_GENOME = config["CHOICE"]["OUTSIDER_VARIANT"]["INTEGRATE_TE_TO_GENOME"],
        OPTIMIZE_FREQUENCE     = config["CHOICE"]["OUTSIDER_VARIANT"]["OPTIMIZE_FREQUENCE"],

        REPORT                 = config["CHOICE"]["PIPELINE"]["REPORT"],

        #COLOR 
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,

    shell:
        """
        
        {params.env};
        path_to_pipline=`dirname {params.path_snk}`

        mkdir -p {params.work_directory}/SNAKE_USED/
        mkdir -p {params.work_directory}/log/
        mkdir -p tmp_snk/

        rm -f ${{path_to_pipline}}/Snakefile*
        
        printf "%s\\n" "{params.cmess} [SNK] CREATION SNAKEFILE {params.cend}"
        
        ###
        #INSIDER
        ###

        if [ {params.choice_insider_sv} = "True" ]; then

            rm -f {params.work_directory}/SNAKE_USED/Snakefile_insider.snk

            ## Exemple les instructions par default obligatoir
            printf "%s" "SV_INSIDER > TE_INSIDER:N " > instruction.txt

            if [ {params.REPORT} ] && [ {params.choice_outsider_sv} != "True" ]; then
                sed -i  's/TE_INSIDER:N/TE_INSIDER/g' instruction.txt
                printf "%s" "> REPORT " >> instruction.txt
            fi
            
            echo "" >> instruction.txt

            ## BUILD SNAKEFILE en fonctions des instructions
            python3 ${{path_to_pipline}}/lib/python/make_snk.py \
                instruction.txt \
                ${{path_to_pipline}}/list_rules.snk \
                ${{path_to_pipline}}/Snakefile \
                -t ${{path_to_pipline}}/template.snk

            cp ${{path_to_pipline}}/Snakefile {params.work_directory}/SNAKE_USED/Snakefile_insider.snk

            printf "%b\\n" "{params.cmess} [SNK] CREATION SNAKEFILE INSIDER DONE ! {params.cend}"

            printf "%b\\n\\n" "{params.cmess} [SNK] DRY RUN SNAKEFILE {params.cend}"

            snakemake --snakefile ${{path_to_pipline}}/Snakefile --configfile {params.name_configfil} --dryrun \
                || (message_fail "\n[SNK INFO] DRY RUN ERROR PIPELINE : please check your config file\n\n" && exit 1)
            
            if [ $? -eq 0 ]; then
                printf "%b\\n\\n" "{params.cmess} [SNK] RUNNING SNAKEFILE {params.cend}"
                snakemake --snakefile ${{path_to_pipline}}/Snakefile --configfile {params.name_configfil} | tee {params.work_directory}/log/Snakefile_insider.log \
                    || (message_fail "\n[SNK INFO] ERROR PIPELINE; snakefile used : {params.work_directory}/SNAKE_USED/Snakefile_insider.snk\n\n" && rm -f ${{path_to_pipline}}/Snakefile*);
            fi;
        fi;

        

        ###
        #OUTSIDER
        ###

        if [ {params.choice_outsider_sv} = "True" ]; then

            rm -f {params.work_directory}/SNAKE_USED/Snakefile_outsider.snk
            
            ## Exemple les instruction par default obligatoir
            if [ {params.OPTIMIZE_FREQUENCE} = True ]; then
                printf "%s" "mapping > samtools > {params.call_sv} > DETECTION_TE > FREQ_GLOBAL > FREQUENCE > extract_read " > instruction.txt
            else
                printf "%s" "mapping > samtools > {params.call_sv} > DETECTION_TE > extract_read:NI " > instruction.txt
            fi
            
            ## Depend du fichier de config
            if [ {params.LC_ASM_FLYE} = "True" ]; then
                printf "%s" "> assembly_flye "  >> instruction.txt
            fi;

            ## Depend du fichier de config
            if [ {params.LC_ASM_WTDGB} = "True" ]; then
                printf "%s" "> assembly_wdtgb "  >> instruction.txt
            fi;
            
            ## Exemple les instruction par default obligatoir
            printf "%s" "> GET_SEQ_TE " >> instruction.txt

            if [ {params.choice_insider_sv} = "True" ]; then
                printf "%s" "> TE_TOWARD_GENOME " >> instruction.txt
                printf "%s" "> FIND_SV_ON_REF" >> instruction.txt
                printf "%s" "> FIND_TE_ON_REF " >> instruction.txt
                printf "%s" "> TSD" >> instruction.txt
            else
                if [ {params.INTEGRATE_TE_TO_GENOME} = True ]; then
                    printf "%s" "> TE_TOWARD_GENOME " >> instruction.txt
                    printf "%s" "> TSD" >> instruction.txt
                else
                    #:NI = NO INPUT
                    printf "%s" "> TSD:NI" >> instruction.txt
                fi;
            fi;

            if [ {params.REPORT} ]; then
                printf "%s" "> REPORT " >> instruction.txt
            fi
            
            echo "" >> instruction.txt

            ## Creation du snake file en fonction des instructions
            python3 ${{path_to_pipline}}/lib/python/make_snk.py \
                instruction.txt \
                ${{path_to_pipline}}/list_rules.snk \
                ${{path_to_pipline}}/Snakefile \
                -t ${{path_to_pipline}}/template.snk

            cp ${{path_to_pipline}}/Snakefile {params.work_directory}/SNAKE_USED/Snakefile_outsider.snk

            printf "%b\\n" "{params.cmess} [SNK] CREATION SNAKEFILE OUTSIDER DONE ! {params.cend}"

            printf "%b\\n\\n" "{params.cmess} [SNK] DRY RUN SNAKEFILE {params.cend}"

            snakemake --snakefile ${{path_to_pipline}}/Snakefile --configfile {params.name_configfil} --dryrun \
                || (message_fail "\n[SNK INFO] DRY RUN ERROR PIPELINE : please check your config file\n\n" && exit 1)
            
            if [ $? -eq 0 ]; then
                printf "%b\\n\\n" "{params.cmess} [SNK] RUNNING SNAKEFILE {params.cend}"
                snakemake --snakefile ${{path_to_pipline}}/Snakefile --configfile {params.name_configfil} | tee {params.work_directory}/log/Snakefile_outsider.log \
                    || (message_fail "\n[SNK INFO] ERROR PIPELINE; snakefile used : {params.work_directory}/SNAKE_USED/Snakefile_outsider.snk\n\n" && rm -f ${{path_to_pipline}}/Snakefile*);
            fi;
        fi;

        touch tmp_snk/tmp_end_pipeline.end
        ##rm -f ${{path_to_pipline}}/Snakefile*

        

        """

