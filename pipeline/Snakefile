###################################################################################################################################
#
# Copyright 2019-2020 IRD-CNRS-Lyon1 University
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/> or
# write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301, USA.
#
# You should have received a copy of the CeCILL-C license with this program.
# If not see <http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.txt>
#
# Intellectual property belongs to authors and IRD, CNRS, and Lyon 1 University  for all versions
# Version 0.1 written by Mourdas Mohamed
#                                                                                                                                   
####################################################################################################################################


#IMPORT
import json
import os

#Class Color
class bcolors:
    VIOLET    = '\033[95m'
    RED       = '\033[91m'
    BLUE      = '\033[94m'
    CYAN      = '\033[96m'
    GREEN     = '\033[92m'
    WARNING   = '\033[93m'
    FAIL      = '\033[91m'
    BOLD      = '\033[1m'
    END       = '\033[0m'
    UNDERLINE = '\033[4m'

def message_color(color, text):
    return color + text + bcolors.END

# Create ouput folder
os.system("mkdir -p " + config["DATA"]["WORK_DIRECTORY"])

# Remember the parameters associated with the output folder
with open(config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/params.log", "w") as file:
    file.write(json.dumps(config))


# Get path snakefile
path_snk = ""

i = 0
while i < len(sys.argv) and path_snk == "" :
    if sys.argv[i] == "--snakefile" :
        path_snk = sys.argv[i + 1]

    i += 1
#

#os.system("cat `dirname " + path_snk + "`/TrEMOLO.txt")

#CMD DEFINE ENV
env="source `dirname " + path_snk + "`/define_env.sh" 




rule TSD :
    input:
        "get_TE_seq.done",
        #directory(config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/" + "ET_FIND_FA"),
        fasta_TE  = config["DATA"]["TE_DB"],
        genome    = config["DATA"]["GENOME"],

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/report_TSD.txt",
        #directory(config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/" + "TSD"),

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),
        name_genome    = config["DATA"]["GENOME"].split("/")[-1].split(".")[0],

        env            = env, #source environnement

        #TSD
        FILE_SIZE_TE_TSD = config["PARAMS"]["OUTSIDER_VARIANT"]["TSD"]["FILE_SIZE_TE_TSD"],
        SIZE_FLANK       = config["PARAMS"]["OUTSIDER_VARIANT"]["TSD"]["SIZE_FLANK"],

        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/TSD",

    threads: 30
    shell:
        #TODO broullion
        """
        {params.env}
        rm -f {params.work_directory}/report_TSD.txt;
        touch {params.work_directory}/report_TSD.txt;

        echo '-----------TSD----------' ;
        mkdir -p {params.work_directory}/TSD ;
        path_to_pipline=`dirname {params.path_snk}`
        
        read_directory="{params.work_directory}/READ_FASTQ_TE"
        fasta_dir_find="{params.work_directory}/FASTA_FIND"

        NB_FILE=`ls {params.work_directory}/ET_FIND_FA | wc -l` ;
        i=0 ;
        for TE_found_fa in `ls {params.work_directory}/ET_FIND_FA/`; do

            ###echo "[TSD:snk] $i/$NB_FILE" ;

            nameTE=`echo $TE_found_fa | grep -o "_[^_]*\." | grep -o "[^_]*" | sed 's/\.$//g'` ;
            
            ! test -e {params.FILE_SIZE_TE_TSD} && message_fail "Warning FILE {params.FILE_SIZE_TE_TSD} NOT FOUND\n"
            
            SIZE_TSD=`grep -w "${{nameTE}}" {params.FILE_SIZE_TE_TSD} || echo "NONE"`; # EX: ZAM 4 :or: -1
            #SIZE_TSD=`grep -w "${{nameTE}}" ${{path_to_pipline}}/lib/TSD/TE_SIZE_TSD.txt || echo "NONE"`; # EX: ZAM 4 :or: -1
            
            echo "TE=$nameTE ; SIZE_TSD == $SIZE_TSD"
            
            if [[ $SIZE_TSD != "NONE" ]]; then
                SIZE_TSD=`echo $SIZE_TSD | awk '{{print $2}}'`;
                #echo "SIZE_TSD = $SIZE_TSD"

                size_tsd=`grep -w "${{nameTE}}" ${{path_to_pipline}}/lib/TSD/TE_SIZE_TSD.txt || echo NONE`
                echo "TE=$nameTE size_tsd=$size_tsd  SIZE_TSD=$SIZE_TSD" 
                sh ${{path_to_pipline}}/lib/TSD/find_fq_to_fasta.sh {params.work_directory}/ET_FIND_FA/$TE_found_fa \
                   ${{read_directory}} \
                   ${{fasta_dir_find}} > {log}.out 2> {log}.err;

                sh ${{path_to_pipline}}/lib/TSD/tsd_te.sh {params.work_directory}/ET_FIND_FA/$TE_found_fa \
                    ${{read_directory}} \
                    ${{fasta_dir_find}} \
                    {input.fasta_TE} 10 $SIZE_TSD > {log}.out 2> {log}.err;

                mv total_results_tsd.txt {params.work_directory}/TSD/TSD_${{nameTE}}.txt
                #mv total_results_tsd_${{nameTE}}.txt {params.work_directory}/TSD/TSD_${{nameTE}}.txt ;

                sh ${{path_to_pipline}}/lib/TSD/revise_TSD.sh {input.genome} \
                    {params.work_directory}/TSD/TSD_${{nameTE}}.txt \
                    {params.SIZE_FLANK} \
                    $SIZE_TSD > {log}.out 2> {log}.err;
                    
                echo ${{nameTE}} >> {params.work_directory}/report_TSD.txt
                tail -n 8 {params.work_directory}/TSD/TSD_${{nameTE}}.txt >> {params.work_directory}/report_TSD.txt
            else
                SIZE_TSD=-1;
                #echo "SIZE_TSD = $SIZE_TSD"

                size_tsd=`grep -w "${{nameTE}}" ${{path_to_pipline}}/lib/TSD/TE_SIZE_TSD.txt || echo NONE`
                echo "TE=$nameTE size_tsd=$size_tsd  SIZE_TSD=$SIZE_TSD" 
                sh ${{path_to_pipline}}/lib/TSD/find_fq_to_fasta.sh {params.work_directory}/ET_FIND_FA/$TE_found_fa \
                   ${{read_directory}} \
                   ${{fasta_dir_find}} > {log}.out 2> {log}.err;

                sh ${{path_to_pipline}}/lib/TSD/tsd_te.sh {params.work_directory}/ET_FIND_FA/$TE_found_fa \
                    ${{read_directory}} \
                    ${{fasta_dir_find}} \
                    {input.fasta_TE} {params.SIZE_FLANK} $SIZE_TSD > {log}.out 2> {log}.err;

                mv total_results_tsd.txt {params.work_directory}/TSD/TSD_${{nameTE}}.txt
                #mv total_results_tsd_${{nameTE}}.txt {params.work_directory}/TSD/TSD_${{nameTE}}.txt ;

                # sh ${{path_to_pipline}}/lib/TSD/revise_TSD.sh {input.genome} \
                #     {params.work_directory}/TSD/TSD_${{nameTE}}.txt \
                #     {params.SIZE_FLANK} \
                #     $SIZE_TSD > {log}.out 2> {log}.err;

                # sh ${{path_to_pipline}}/lib/TSD/revise_TSD.sh {input.genome} \
                #     {params.work_directory}/TSD/TSD_${{nameTE}}.txt \
                #     {params.SIZE_FLANK} \
                #     4 > {log}.out 2> {log}.err;
                    
                echo ${{nameTE}} >> {params.work_directory}/report_TSD.txt
                tail -n 8 {params.work_directory}/TSD/TSD_${{nameTE}}.txt >> {params.work_directory}/report_TSD.txt
            fi;
            
            
            
            i=$(($i + 1)) ;
            printf "%s\\n" "{params.cmess} [SNK]--[`date`] [TSD:snk] : $i/$NB_FILE {params.cend}"
        done;

        """

rule GET_SEQ_TE :
    input:
        "extract_read.done",
        all_te            = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        snif_seqs         = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SEQUENCE_INDEL.fasta",

    output:
        temp(touch("get_TE_seq.done")),
        directory(config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/" + "ET_FIND_FA"),




    params:
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement
    threads: 30
    shell:
        """
        {params.env}
        mkdir -p {params.work_directory}/ET_FIND_FA ;
        
        rep="{params.work_directory}/ET_FIND_FA" 
        prefix="TE_REPORT"

        cat {input.all_te} | sed -e 's/:[-+]//g' > {params.work_directory}/tmp_TE_all.csv
        
        ###head {params.work_directory}/tmp_TE_all.csv
        
        awk -v dir="$rep" -v prefix="$prefix" 'BEGIN{{OFS="\t"}} NR>1 {{if($8<$9){{print $2, $8-1, $9  >> dir"/"prefix"_find_"$1".bed"}} else{{print $2, $9-1, $8  >> dir"/"prefix"_find_"$1".bed"}} }}' {params.work_directory}/tmp_TE_all.csv ;
        for i in `ls {params.work_directory}/ET_FIND_FA | grep ".bed$"`; do
            bedtools getfasta -fi {input.snif_seqs} \
               -bed {params.work_directory}/ET_FIND_FA/$i > {params.work_directory}/ET_FIND_FA/TE_REPORT_find_`echo $i \
                | grep -o "_[^_]*\." | grep -o "[^_]*" | sed 's/\.$//g'`.fasta; 
        done ;

        rm -f {params.work_directory}/ET_FIND_FA/*.bed ;
        cat {params.work_directory}/ET_FIND_FA/* > {params.work_directory}/TE_REPORT_total_find.fasta ;
        """


rule extract_read :
    input:
        all_te   = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        bln      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/BLAST_SEQUENCE_INDEL_vs_DBTE.bln",
        vcf      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SV.vcf",
        read     = config["DATA"]["SAMPLE"],
        fasta_TE = config["DATA"]["TE_DB"],

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/ID_BEST_READ_TE.txt",
        touch("extract_read.done"),

    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        #Choice
        FLYE           = config["CHOICE"]["OUTSIDER_VARIANT"]["LOCAL_ASSEMBLY"]["FLYE"],
        WTDGB          = config["CHOICE"]["OUTSIDER_VARIANT"]["LOCAL_ASSEMBLY"]["WTDGB"],

        #Color message
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
        cbold          = bcolors.BOLD,

    shell:
        """
        {params.env}
        printf "%s\\n" "{params.cmess} [SNK]--[`date`] GET READS AND ASSEMBLY [^-^] {params.cend}"

        #rm -fr {params.work_directory}/READ_FASTQ_TE_ASSEMBLY/
        #rm -fr {params.work_directory}/READ_FASTQ_TE

        mkdir -p {params.work_directory}/READ_FASTQ_TE ;
        mkdir -p {params.work_directory}/READ_FASTQ_TE_ASSEMBLY ;

        #BUG
        test -e {params.work_directory}/all_TE_assembly.bln && \
        cat {params.work_directory}/all_TE_assembly.bln > {params.work_directory}/all_TE_assembly_before.bln

        path_to_pipline=`dirname {params.path_snk}`

        ##only TE found
        awk 'NR>1 {{print $2}}' {input.all_te} | cut -d":" -f 5 > {params.work_directory}/ID_TE_SV_REPORT.txt ; 
        echo "ok------"
        python3 ${{path_to_pipline}}/lib/python/extract_region_reads_vcf.py -c "." \
          {input.vcf} \
         -d {params.work_directory}/ID_READS_TE \
         -i {params.work_directory}/ID_TE_SV_REPORT.txt ;

        echo "ok------"
        makeblastdb -in {input.fasta_TE} -dbtype nucl ;

        NB_FILE=`ls {params.work_directory}/ID_READS_TE | wc -l` ;
        i=0 ;
        for read_file in `ls {params.work_directory}/ID_READS_TE`; do

            region=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]"` ;
            
            if ! test -e {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq; then
                echo "REGION ------- {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq"

                id=`echo $read_file | grep -o "[_].*\." | grep -o "[^_].*[^.]" | cut -d":" -f 2`

                #nb_read=`awk -v ID="$id" '{{if($3 == ID){{print $0}}}}' {input.vcf} | grep -o -e "RE=[0-9]*" | cut -d"=" -f 2`
                #nb_read=`awk -v ID="$id" '{{if($3 == ID){{print $0}}}}' {input.vcf} | grep -o -e "SUPPORT=[0-9]*" | cut -d"=" -f 2`

                nb_read=`wc -l {params.work_directory}/ID_READS_TE/$read_file | cut -d " " -f 1`
                TE=`grep ":$id:[0-9]*:[IP]" {input.all_te} | cut -f 1 || echo "NONE"`

                printf "%s\\n" "      {params.cmess} [SNK]--[`date`] [extract_read:snk] $read_file {params.cend}"
                printf "%s\\n" "      {params.cmess} [SNK]--[`date`] [extract_read:snk] [extract_read:snk] $i/$NB_FILE : nb_read=$nb_read : id=$id {params.cend}"
                
                (grep -w $id {params.work_directory}/ID_TE_SV_REPORT.txt && \
                samtools fqidx {input.read} -r {params.work_directory}/ID_READS_TE/$read_file > {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq) || echo "$id NOT FOUND ---------------------" ;

                ## FORMAT FASTQ
                test -e {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq && \
                python3 ${{path_to_pipline}}/lib/python/fastq_to_fastq.py \
                 {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq \
                 {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq

                (test -e {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fastq && echo "[OK]---" ) || echo "[NOOOOOOOOO]]----------------------------------"
                
                rm -f {params.work_directory}/READ_FASTQ_TE/reads_${{region}}.fq
            fi;

            i=$(($i + 1));
        done;

        printf "%s\\n" "{params.cmess} [SNK]--[`date`] EXTRACT DONE ! {params.cend}"

        NB_REGION=`ls {params.work_directory}/ID_READS_TE | wc -l` ;
        NB_READS=`ls {params.work_directory}/READ_FASTQ_TE | wc -l` ;

        #echo "     [extract_read:snk] $NB_READS AND $NB_REGION";

        ## GET BEST ID TE
        awk 'NR>1 {{print $2}}' {input.all_te} | cut -d ":" -f 5,8 > {params.work_directory}/tmp_ID_RD_SEQ.txt

        grep -w -f {params.work_directory}/ID_TE_SV_REPORT.txt {params.work_directory}/tmp_ID_RD_SEQ.txt > {params.work_directory}/ID_RD_SEQ.txt

        for i in `cat {params.work_directory}/ID_RD_SEQ.txt`; 
        do 
            ID=`echo $i | cut -d ":" -f 1`; 
            num=`echo $i | cut -d ":" -f 2`; 
            name_file=`ls {params.work_directory}/ID_READS_TE/ | grep -w "$ID"`; 

            awk -v num="$num" 'NR-1 == num' {params.work_directory}/ID_READS_TE/$name_file > {params.work_directory}/ID_BEST_READ_TE.txt;

        done 

        rm -f {params.work_directory}/ID_RD_SEQ.txt

        """



rule DETECTION_TE :
    input:
        vcf      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SV.vcf",
        fasta_TE = config["DATA"]["TE_DB"],
        bam      = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME_MD.sorted.bam",

    output:
        snif_seqs = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SEQUENCE_INDEL.fasta",
        bln       = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/BLAST_SEQUENCE_INDEL_vs_DBTE.bln",
        all_te    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/FILTER_BLAST_SEQUENCE_INDEL_vs_DBTE.csv",
        depth_te  = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/DEPTH_TE.csv",
        
    params:
        path_snk       = path_snk,
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,
    log:
        blastn = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/blastn"

    threads: 30
    shell:
        """
        {params.env}
        printf "%s\\n" "{params.cmess} [SNK]--[`date`] DETECTION_TE [^-^] {params.cend}"

        path_to_pipline=`dirname {params.path_snk}`

        # GET SEQUENCE REPORT #
        printf "%s\\n" "{params.cmess} [SNK]--[`date`] GET SEQUENCES VARIANTS [^-^] {params.cend}"
        python3 ${{path_to_pipline}}/lib/python/get_seq_vcf.py -m 150 {input.vcf} {output.snif_seqs} -c "." ;

        cp {output.snif_seqs} {params.work_directory}/tmp_seq.fasta

        printf "%s\\n" "{params.cmess} [SNK]--[`date`] BLAST SV TO TE [^-^] {params.cend}"
        # BLAST SEQUENCE VCF on DATABASE TE #
        makeblastdb -in {input.fasta_TE} -dbtype nucl 2> {log.blastn}.err;
        blastn -db {input.fasta_TE} -query {output.snif_seqs} -outfmt 6 -out {output.bln} 2>> {log.blastn}.err;
        printf "%s\\n" "{params.cmess} [SNK]--[`date`] BLAST DONE CHECK logfile=={log.blastn} {params.cend}"

        cp {output.bln} {params.work_directory}/tmp_blast.bln

        printf "%s\\n" "{params.cmess} [SNK]--[`date`] FILTER TE BLAST [^-^] {params.cend}"
        # FILTER TE BLAST #
        python3 ${{path_to_pipline}}/lib/python/parse_blast_main.py {output.bln} {input.fasta_TE} {output.all_te} -c --combine_name {params.work_directory}/COMBINE_TE.csv;

        samtools index {input.bam} #2> {log}.err

        printf "%s\\n" "{params.cmess} [SNK]--[`date`] CALCUL FREQUENCE TE [^-^] {params.cend}"
        
        # CALCUL FREQUENCE #
        i=0;
        while read line; do
            
            if [ $i -ne 0 ]; then
                region=`echo $line | awk '{{print $2}}' | awk -F ":" '{{print $1":"$3"-"$3}}'`
                depth=`samtools depth {input.bam} -r $region`;
                NB_depth=`echo $depth | awk '{{print $3}}'`

                TE=`echo $line | awk '{{print $1}}'`
                info_TE=`echo $line | awk 'OFS="\t"{{print $1, $2}}'`
                RS=`echo $line | awk '{{print $2}}' | awk -F ":" '{{print $6}}'`

                if [ -n "$depth" ]; then
                    ###echo "$i : $info_TE : $depth : RS=$RS : NB_depth=$NB_depth"
                    printf "$depth\t$(($NB_depth-$RS))\t$RS\t%.4f\t$info_TE\n" "$(((10**6 * $RS/$NB_depth) * 100))e-6" | tr "," "." >> {output.depth_te}
                else
                    printf "$depth\t$(($NB_depth-$RS))\t$RS\t%.4f\t${{info_TE}}|ERROR\n" "0" | tr "," "." >> {output.depth_te}
                    message_fail "ERROR FOR ${{info_TE}} \n ERROR GETTING DEPTH YOU NEED TO RECONSTRUCT YOUR BAM FILE\n";
                fi;

                
            else
                printf "chrom\tposition\ttotal_depth\tdepth_empty_site\tread_support\tread_support_percent\tTE\tinfo_TE\n"  > {output.depth_te}
            fi;
            
            i=$(($i+1));

        done < {output.all_te};

        printf "%s\\n" "{params.cmess} [SNK]--[`date`] GET BAM TE [^-^] {params.cend}"
        # GET BAM TE
        awk 'NR>1 {{print $2":"$1}}' {output.all_te} | awk -v size="15" -F ":" 'OFS="\t"{{print $1, $3-size, $3+size, $5":"$9}}' > {params.work_directory}/POSITION_START_TE.bed
        samtools view -h -b {input.bam} -L {params.work_directory}/POSITION_START_TE.bed > {params.work_directory}/MAPPING_POSTION_TE.bam
        """



rule sniffles :
    input:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME_MD.sorted.bam",

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SV.vcf", 
        
    params:
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),

        env            = env, #source environnement

        cfail          = bcolors.FAIL,
        cmess          = bcolors.CYAN,
        cend           = bcolors.END,

    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/sniffles",

    threads: 30
    shell:
        """
        {params.env}
        printf "%s\\n" "{params.cmess} [SNK]--[`date`] SNIFFLES [^-^] {params.cend}"

        samtools index {input.bam} 2> {log}.err

        #sniffles --report-seq -s 1 -m {input} -v {output} -n -1 ;
        run_cmd "sniffles --report-seq -s 1 -m {input} -v {output} -n -1" "{log}" "SNIFFLES" "False";


        """

rule samtools :
    input:
        sam    = config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME.sam",
        genome = config["DATA"]["GENOME"],

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME_MD.sorted.bam",
        
    params:
        #DATA
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),
        env            = env, #source environnement
        
        #PARAMS
        preset_view    = config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_VIEW"]["PRESET_OPTION"],
        preset_sort    = config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_SORT"]["PRESET_OPTION"],
        preset_callmd  = config["PARAMS"]["OUTSIDER_VARIANT"]["SAMTOOLS_CALLMD"]["PRESET_OPTION"],
        
        #COLORS
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,

    threads: 30

    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/samtools"

    shell:
        """
        {params.env}
        printf "\n%s\n\n" "{params.cmess} [SNK]--[`date`] SAMTOOLS [^-^] {params.cend}"

        echo "---view---" | tee {log}.out
        #samtools view -h {params.preset_view} -b {input.sam} > {input.sam}.bam 2>> {log}.err;
        run_cmd "samtools view -h {params.preset_view} -b {input.sam} | tee {input.sam}.bam" "{log}" "SAMTOOLS_VIEW" "False";

        echo "---sort---" | tee -a {log}.out
        #samtools sort {params.preset_sort} {input.sam}.bam -o {input.sam}.sorted.bam 2>> {log}.err;
        run_cmd "samtools sort {params.preset_sort} {input.sam}.bam -o {input.sam}.sorted.bam" "{log}" "SAMTOOLS_SORT" "False";

        echo "---calmd---" | tee -a {log}.out
        #samtools calmd {params.preset_callmd} -b {input.sam}.sorted.bam {input.genome} > {output} 2>> {log}; #CALL MD for sniffles
        run_cmd "samtools calmd {params.preset_callmd} -b {input.sam}.sorted.bam {input.genome} | tee {output}" "{log}" "SAMTOOLS_CALLMD" "False";#CALL MD for sniffles

        printf "\n%s\n\n" "{params.cmess} [SNK]--[`date`] SAMTOOLS DONE CHECK logfile=={log}"

        rm -f {input.sam} \
        {input.sam}.bam \
        {input.sam}.sorted.bam*;

        """


rule mapping :
    input:  
        read   = config["DATA"]["SAMPLE"],
        genome = config["DATA"]["GENOME"],

    output:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/SAMPLE_mapping_GENOME.sam",
    
    params:
        work_directory = config["DATA"]["WORK_DIRECTORY"].rstrip("/"),
        config         = json.dumps(config),

        preset         = config["PARAMS"]["OUTSIDER_VARIANT"]["MINIMAP2"]["PRESET_OPTION"] if config["PARAMS"]["OUTSIDER_VARIANT"]["MINIMAP2"]["PRESET_OPTION"] != "" else "map-ont",
        option         = config["PARAMS"]["OUTSIDER_VARIANT"]["MINIMAP2"]["OPTION"],

        env            = env, #source environnement

        #COLOR 
        cmess          = bcolors.CYAN,
        cfail          = bcolors.FAIL,
        cend           = bcolors.END,
    log:
        config["DATA"]["WORK_DIRECTORY"].rstrip("/") + "/log/minimap2"
    threads: 30

    shell:
        """
        {params.env};

        printf "\n%s\n\n" "{params.cmess} [SNK]--[`date`] MINIMAP2 MAPPING {params.cend}"
        
        #minimap2 -x  {params.preset} -d {input.genome}.mmi {input.genome} 2> {log};
        run_cmd "minimap2 -x  {params.preset} -d {input.genome}.mmi {input.genome}" "{log}" "MINIMAP2_INDEX" "False";
        
        #minimap2 -ax {params.preset} {params.option} {input.genome} {input.read} > {output} 2>> {log};
        run_cmd "minimap2 -ax {params.preset} {params.option} {input.genome} {input.read} | tee {output}" "{log}" "MINIMAP2" "False";
        """


